import{g as po,a as fs}from"./chunk-eruda-DzYfmTx_.js";import{y as yo,z as go,A as bo,B as _o,C as ko,D as vo,F as So,H as $o,J as xo,K as Eo,L as jo,O as Ro}from"./chunk-vendor-B7JAH77y.js";var Si,Jr;function Ai(){if(Jr)return Si;Jr=1;function P(g){if(g.length===0)return".";let p=m(g);return p=p.reduce(x,[]),B(...p)}function A(...g){let p="";for(let U of g)U.startsWith("/")?p=U:p=P(B(p,U));return p}function B(...g){if(g.length===0)return"";let p=g.join("/");return p=p.replace(/\/{2,}/g,"/"),p}function m(g){if(g.length===0)return[];if(g==="/")return["/"];let p=g.split("/");return p[p.length-1]===""&&p.pop(),g[0]==="/"?p[0]="/":p[0]!=="."&&p.unshift("."),p}function I(g){const p=g.lastIndexOf("/");if(p===-1)throw new Error(`Cannot get dirname of "${g}"`);return p===0?"/":g.slice(0,p)}function D(g){if(g==="/")throw new Error(`Cannot get basename of "${g}"`);const p=g.lastIndexOf("/");return p===-1?g:g.slice(p+1)}function x(g,p){if(g.length===0)return g.push(p),g;if(p===".")return g;if(p===".."){if(g.length===1){if(g[0]==="/")throw new Error("Unable to normalize path - traverses above root directory");if(g[0]===".")return g.push(p),g}return g[g.length-1]===".."?(g.push(".."),g):(g.pop(),g)}return g.push(p),g}return Si={join:B,normalize:P,split:m,basename:D,dirname:I,resolve:A},Si}var $i,Kr;function us(){if(Kr)return $i;Kr=1;function P(g){return class extends Error{constructor(...p){super(...p),this.code=g,this.message?this.message=g+": "+this.message:this.message=g}}}const A=P("EEXIST"),B=P("ENOENT"),m=P("ENOTDIR"),I=P("ENOTEMPTY"),D=P("ETIMEDOUT"),x=P("EISDIR");return $i={EEXIST:A,ENOENT:B,ENOTDIR:m,ENOTEMPTY:I,ETIMEDOUT:D,EISDIR:x},$i}var xi,ts;function Oo(){if(ts)return xi;ts=1;const P=Ai(),{EEXIST:A,ENOENT:B,ENOTDIR:m,ENOTEMPTY:I,EISDIR:D}=us(),x=0;return xi=class{constructor(){}_makeRoot(p=new Map){return p.set(x,{mode:511,type:"dir",size:0,ino:0,mtimeMs:Date.now()}),p}activate(p=null){p===null?this._root=new Map([["/",this._makeRoot()]]):typeof p=="string"?this._root=new Map([["/",this._makeRoot(this.parse(p))]]):this._root=p}get activated(){return!!this._root}deactivate(){this._root=void 0}size(){return this._countInodes(this._root.get("/"))-1}_countInodes(p){let U=1;for(let[j,L]of p)j!==x&&(U+=this._countInodes(L));return U}autoinc(){return this._maxInode(this._root.get("/"))+1}_maxInode(p){let U=p.get(x).ino;for(let[j,L]of p)j!==x&&(U=Math.max(U,this._maxInode(L)));return U}print(p=this._root.get("/")){let U="";const j=(L,M)=>{for(let[R,H]of L){if(R===0)continue;let G=H.get(x),V=G.mode.toString(8);U+=`${"	".repeat(M)}${R}	${V}`,G.type==="file"?U+=`	${G.size}	${G.mtimeMs}
`:(U+=`
`,j(H,M+1))}};return j(p,0),U}parse(p){let U=0;function j(H){const G=++U,V=H.length===1?"dir":"file";let[K,Z,gt]=H;return K=parseInt(K,8),Z=Z?parseInt(Z):0,gt=gt?parseInt(gt):Date.now(),new Map([[x,{mode:K,type:V,size:Z,mtimeMs:gt,ino:G}]])}let L=p.trim().split(`
`),M=this._makeRoot(),R=[{indent:-1,node:M},{indent:0,node:null}];for(let H of L){let V=H.match(/^\t*/)[0].length;H=H.slice(V);let[K,...Z]=H.split("	"),gt=j(Z);if(V<=R[R.length-1].indent)for(;V<=R[R.length-1].indent;)R.pop();R.push({indent:V,node:gt}),R[R.length-2].node.set(K,gt)}return M}_lookup(p,U=!0){let j=this._root,L="/",M=P.split(p);for(let R=0;R<M.length;++R){let H=M[R];if(j=j.get(H),!j)throw new B(p);if(U||R<M.length-1){const G=j.get(x);if(G.type==="symlink"){let V=P.resolve(L,G.target);j=this._lookup(V)}L?L=P.join(L,H):L=H}}return j}mkdir(p,{mode:U}){if(p==="/")throw new A;let j=this._lookup(P.dirname(p)),L=P.basename(p);if(j.has(L))throw new A;let M=new Map,R={mode:U,type:"dir",size:0,mtimeMs:Date.now(),ino:this.autoinc()};M.set(x,R),j.set(L,M)}rmdir(p){let U=this._lookup(p);if(U.get(x).type!=="dir")throw new m;if(U.size>1)throw new I;let j=this._lookup(P.dirname(p)),L=P.basename(p);j.delete(L)}readdir(p){let U=this._lookup(p);if(U.get(x).type!=="dir")throw new m;return[...U.keys()].filter(j=>typeof j=="string")}writeStat(p,U,{mode:j}){let L,M;try{M=this.stat(p)}catch{}if(M!==void 0){if(M.type==="dir")throw new D;j==null&&(j=M.mode),L=M.ino}j==null&&(j=438),L==null&&(L=this.autoinc());let R=this._lookup(P.dirname(p)),H=P.basename(p),G={mode:j,type:"file",size:U,mtimeMs:Date.now(),ino:L},V=new Map;return V.set(x,G),R.set(H,V),G}unlink(p){let U=this._lookup(P.dirname(p)),j=P.basename(p);U.delete(j)}rename(p,U){let j=P.basename(U),L=this._lookup(p);this._lookup(P.dirname(U)).set(j,L),this.unlink(p)}stat(p){return this._lookup(p).get(x)}lstat(p){return this._lookup(p,!1).get(x)}readlink(p){return this._lookup(p,!1).get(x).target}symlink(p,U){let j,L;try{let V=this.stat(U);L===null&&(L=V.mode),j=V.ino}catch{}L==null&&(L=40960),j==null&&(j=this.autoinc());let M=this._lookup(P.dirname(U)),R=P.basename(U),H={mode:L,type:"symlink",target:p,size:0,mtimeMs:Date.now(),ino:j},G=new Map;return G.set(x,H),M.set(R,G),H}_du(p){let U=0;for(const[j,L]of p.entries())j===x?U+=L.size:U+=this._du(L);return U}du(p){let U=this._lookup(p);return this._du(U)}},xi}class hs{constructor(A="keyval-store",B="keyval"){this.storeName=B,this._dbName=A,this._storeName=B,this._init()}_init(){this._dbp||(this._dbp=new Promise((A,B)=>{const m=indexedDB.open(this._dbName);m.onerror=()=>B(m.error),m.onsuccess=()=>A(m.result),m.onupgradeneeded=()=>{m.result.createObjectStore(this._storeName)}}))}_withIDBStore(A,B){return this._init(),this._dbp.then(m=>new Promise((I,D)=>{const x=m.transaction(this.storeName,A);x.oncomplete=()=>I(),x.onabort=x.onerror=()=>D(x.error),B(x.objectStore(this.storeName))}))}_close(){return this._init(),this._dbp.then(A=>{A.close(),this._dbp=void 0})}}let Ei;function Wt(){return Ei||(Ei=new hs),Ei}function Bo(P,A=Wt()){let B;return A._withIDBStore("readwrite",m=>{B=m.get(P)}).then(()=>B.result)}function Io(P,A,B=Wt()){return B._withIDBStore("readwrite",m=>{m.put(A,P)})}function Po(P,A,B=Wt()){return B._withIDBStore("readwrite",m=>{const I=m.get(P);I.onsuccess=()=>{m.put(A(I.result),P)}})}function To(P,A=Wt()){return A._withIDBStore("readwrite",B=>{B.delete(P)})}function Co(P=Wt()){return P._withIDBStore("readwrite",A=>{A.clear()})}function Ao(P=Wt()){const A=[];return P._withIDBStore("readwrite",B=>{(B.openKeyCursor||B.openCursor).call(B).onsuccess=function(){this.result&&(A.push(this.result.key),this.result.continue())}}).then(()=>A)}function Do(P=Wt()){return P._close()}const No=Object.freeze(Object.defineProperty({__proto__:null,Store:hs,clear:Co,close:Do,del:To,get:Bo,keys:Ao,set:Io,update:Po},Symbol.toStringTag,{value:"Module"})),ds=po(No);var ji,es;function Mo(){if(es)return ji;es=1;const P=ds;return ji=class{constructor(B,m){this._database=B,this._storename=m,this._store=new P.Store(this._database,this._storename)}saveSuperblock(B){return P.set("!root",B,this._store)}loadSuperblock(){return P.get("!root",this._store)}readFile(B){return P.get(B,this._store)}writeFile(B,m){return P.set(B,m,this._store)}unlink(B){return P.del(B,this._store)}wipe(){return P.clear(this._store)}close(){return P.close(this._store)}},ji}var Ri,is;function Fo(){return is||(is=1,Ri=class{constructor(A){this._url=A}loadSuperblock(){return fetch(this._url+"/.superblock.txt").then(A=>A.ok?A.text():null)}async readFile(A){const B=await fetch(this._url+A);if(B.status===200)return B.arrayBuffer();throw new Error("ENOENT")}async sizeFile(A){const B=await fetch(this._url+A,{method:"HEAD"});if(B.status===200)return B.headers.get("content-length");throw new Error("ENOENT")}}),Ri}var Oi,ns;function Uo(){if(ns)return Oi;ns=1;const P=ds,A=B=>new Promise(m=>setTimeout(m,B));return Oi=class{constructor(m,I){this._id=Math.random(),this._database=m,this._storename=I,this._store=new P.Store(this._database,this._storename),this._lock=null}async has({margin:m=2e3}={}){if(this._lock&&this._lock.holder===this._id){const I=Date.now();return this._lock.expires>I+m?!0:await this.renew()}else return!1}async renew({ttl:m=5e3}={}){let I;return await P.update("lock",D=>{const g=Date.now()+m;return I=D&&D.holder===this._id,this._lock=I?{holder:this._id,expires:g}:D,this._lock},this._store),I}async acquire({ttl:m=5e3}={}){let I,D,x;if(await P.update("lock",g=>{const p=Date.now(),U=p+m;return D=g&&g.expires<p,I=g===void 0||D,x=g&&g.holder===this._id,this._lock=I?{holder:this._id,expires:U}:g,this._lock},this._store),x)throw new Error("Mutex double-locked");return I}async wait({interval:m=100,limit:I=6e3,ttl:D}={}){for(;I--;){if(await this.acquire({ttl:D}))return!0;await A(m)}throw new Error("Mutex timeout")}async release({force:m=!1}={}){let I,D,x;if(await P.update("lock",g=>(I=m||g&&g.holder===this._id,D=g===void 0,x=g&&g.holder!==this._id,this._lock=I?void 0:g,this._lock),this._store),await P.close(this._store),!I&&!m){if(D)throw new Error("Mutex double-freed");if(x)throw new Error("Mutex lost ownership")}return I}},Oi}var Bi,rs;function Ho(){return rs||(rs=1,Bi=class{constructor(A){this._id=Math.random(),this._database=A,this._has=!1,this._release=null}async has(){return this._has}async acquire(){return new Promise(A=>{navigator.locks.request(this._database+"_lock",{ifAvailable:!0},B=>(this._has=!!B,A(!!B),new Promise(m=>{this._release=m})))})}async wait({timeout:A=6e5}={}){return new Promise((B,m)=>{const I=new AbortController;setTimeout(()=>{I.abort(),m(new Error("Mutex timeout"))},A),navigator.locks.request(this._database+"_lock",{signal:I.signal},D=>(this._has=!!D,B(!!D),new Promise(x=>{this._release=x})))})}async release({force:A=!1}={}){this._has=!1,this._release?this._release():A&&navigator.locks.request(this._database+"_lock",{steal:!0},B=>!0)}}),Bi}var Ii,ss;function zo(){if(ss)return Ii;ss=1;const{encode:P,decode:A}=yo(),B=go(),m=Oo(),{ENOENT:I,ENOTEMPTY:D,ETIMEDOUT:x}=us(),g=Mo(),p=Fo(),U=Uo(),j=Ho(),L=Ai();return Ii=class{constructor(){this.saveSuperblock=B(()=>{this.flush()},500)}async init(R,{wipe:H,url:G,urlauto:V,fileDbName:K=R,db:Z=null,fileStoreName:gt=R+"_files",lockDbName:Et=R+"_lock",lockStoreName:Xe=R+"_lock"}={}){this._name=R,this._idb=Z||new g(K,gt),this._mutex=navigator.locks?new j(R):new U(Et,Xe),this._cache=new m(R),this._opts={wipe:H,url:G},this._needsWipe=!!H,G&&(this._http=new p(G),this._urlauto=!!V)}async activate(){if(this._cache.activated)return;this._needsWipe&&(this._needsWipe=!1,await this._idb.wipe(),await this._mutex.release({force:!0})),await this._mutex.has()||await this._mutex.wait();const R=await this._idb.loadSuperblock();if(R)this._cache.activate(R);else if(this._http){const H=await this._http.loadSuperblock();this._cache.activate(H),await this._saveSuperblock()}else this._cache.activate();if(!await this._mutex.has())throw new x}async deactivate(){await this._mutex.has()&&await this._saveSuperblock(),this._cache.deactivate();try{await this._mutex.release()}catch(R){console.log(R)}await this._idb.close()}async _saveSuperblock(){this._cache.activated&&(this._lastSavedAt=Date.now(),await this._idb.saveSuperblock(this._cache._root))}_writeStat(R,H,G){let V=L.split(L.dirname(R)),K=V.shift();for(let Z of V){K=L.join(K,Z);try{this._cache.mkdir(K,{mode:511})}catch{}}return this._cache.writeStat(R,H,G)}async readFile(R,H){const G=typeof H=="string"?H:H&&H.encoding;if(G&&G!=="utf8")throw new Error('Only "utf8" encoding is supported in readFile');let V=null,K=null;try{K=this._cache.stat(R),V=await this._idb.readFile(K.ino)}catch(Z){if(!this._urlauto)throw Z}if(!V&&this._http){let Z=this._cache.lstat(R);for(;Z.type==="symlink";)R=L.resolve(L.dirname(R),Z.target),Z=this._cache.lstat(R);V=await this._http.readFile(R)}if(V&&((!K||K.size!=V.byteLength)&&(K=await this._writeStat(R,V.byteLength,{mode:K?K.mode:438}),this.saveSuperblock()),G==="utf8"?V=A(V):V.toString=()=>A(V)),!K)throw new I(R);return V}async writeFile(R,H,G){const{mode:V,encoding:K="utf8"}=G;if(typeof H=="string"){if(K!=="utf8")throw new Error('Only "utf8" encoding is supported in writeFile');H=P(H)}const Z=await this._cache.writeStat(R,H.byteLength,{mode:V});await this._idb.writeFile(Z.ino,H)}async unlink(R,H){const G=this._cache.lstat(R);this._cache.unlink(R),G.type!=="symlink"&&await this._idb.unlink(G.ino)}readdir(R,H){return this._cache.readdir(R)}mkdir(R,H){const{mode:G=511}=H;this._cache.mkdir(R,{mode:G})}rmdir(R,H){if(R==="/")throw new D;this._cache.rmdir(R)}rename(R,H){this._cache.rename(R,H)}stat(R,H){return this._cache.stat(R)}lstat(R,H){return this._cache.lstat(R)}readlink(R,H){return this._cache.readlink(R)}symlink(R,H){this._cache.symlink(R,H)}async backFile(R,H){let G=await this._http.sizeFile(R);await this._writeStat(R,G,H)}du(R){return this._cache.du(R)}flush(){return this._saveSuperblock()}},Ii}var Pi,as;function qo(){return as||(as=1,Pi=class{constructor(A){this.type=A.type,this.mode=A.mode,this.size=A.size,this.ino=A.ino,this.mtimeMs=A.mtimeMs,this.ctimeMs=A.ctimeMs||A.mtimeMs,this.uid=1,this.gid=1,this.dev=1}isFile(){return this.type==="file"}isDirectory(){return this.type==="dir"}isSymbolicLink(){return this.type==="symlink"}}),Pi}var Ti,os;function Lo(){if(os)return Ti;os=1;const P=zo(),A=qo(),B=Ai();function m(x,g,...p){return x=B.normalize(x),(typeof g>"u"||typeof g=="function")&&(g={}),typeof g=="string"&&(g={encoding:g}),[x,g,...p]}function I(x,g,p,...U){return x=B.normalize(x),(typeof p>"u"||typeof p=="function")&&(p={}),typeof p=="string"&&(p={encoding:p}),[x,g,p,...U]}function D(x,g,...p){return[B.normalize(x),B.normalize(g),...p]}return Ti=class{constructor(g,p={}){this.init=this.init.bind(this),this.readFile=this._wrap(this.readFile,m,!1),this.writeFile=this._wrap(this.writeFile,I,!0),this.unlink=this._wrap(this.unlink,m,!0),this.readdir=this._wrap(this.readdir,m,!1),this.mkdir=this._wrap(this.mkdir,m,!0),this.rmdir=this._wrap(this.rmdir,m,!0),this.rename=this._wrap(this.rename,D,!0),this.stat=this._wrap(this.stat,m,!1),this.lstat=this._wrap(this.lstat,m,!1),this.readlink=this._wrap(this.readlink,m,!1),this.symlink=this._wrap(this.symlink,D,!0),this.backFile=this._wrap(this.backFile,m,!0),this.du=this._wrap(this.du,m,!1),this._deactivationPromise=null,this._deactivationTimeout=null,this._activationPromise=null,this._operations=new Set,g&&this.init(g,p)}async init(...g){return this._initPromiseResolve&&await this._initPromise,this._initPromise=this._init(...g),this._initPromise}async _init(g,p={}){await this._gracefulShutdown(),this._activationPromise&&await this._deactivate(),this._backend&&this._backend.destroy&&await this._backend.destroy(),this._backend=p.backend||new P,this._backend.init&&await this._backend.init(g,p),this._initPromiseResolve&&(this._initPromiseResolve(),this._initPromiseResolve=null),p.defer||this.stat("/")}async _gracefulShutdown(){this._operations.size>0&&(this._isShuttingDown=!0,await new Promise(g=>this._gracefulShutdownResolve=g),this._isShuttingDown=!1,this._gracefulShutdownResolve=null)}_wrap(g,p,U){return async(...j)=>{j=p(...j);let L={name:g.name,args:j};this._operations.add(L);try{return await this._activate(),await g.apply(this,j)}finally{this._operations.delete(L),U&&this._backend.saveSuperblock(),this._operations.size===0&&(this._deactivationTimeout||clearTimeout(this._deactivationTimeout),this._deactivationTimeout=setTimeout(this._deactivate.bind(this),500))}}}async _activate(){this._initPromise||console.warn(new Error(`Attempted to use LightningFS ${this._name} before it was initialized.`)),await this._initPromise,this._deactivationTimeout&&(clearTimeout(this._deactivationTimeout),this._deactivationTimeout=null),this._deactivationPromise&&await this._deactivationPromise,this._deactivationPromise=null,this._activationPromise||(this._activationPromise=this._backend.activate?this._backend.activate():Promise.resolve()),await this._activationPromise}async _deactivate(){return this._activationPromise&&await this._activationPromise,this._deactivationPromise||(this._deactivationPromise=this._backend.deactivate?this._backend.deactivate():Promise.resolve()),this._activationPromise=null,this._gracefulShutdownResolve&&this._gracefulShutdownResolve(),this._deactivationPromise}async readFile(g,p){return this._backend.readFile(g,p)}async writeFile(g,p,U){return await this._backend.writeFile(g,p,U),null}async unlink(g,p){return await this._backend.unlink(g,p),null}async readdir(g,p){return this._backend.readdir(g,p)}async mkdir(g,p){return await this._backend.mkdir(g,p),null}async rmdir(g,p){return await this._backend.rmdir(g,p),null}async rename(g,p){return await this._backend.rename(g,p),null}async stat(g,p){const U=await this._backend.stat(g,p);return new A(U)}async lstat(g,p){const U=await this._backend.lstat(g,p);return new A(U)}async readlink(g,p){return this._backend.readlink(g,p)}async symlink(g,p){return await this._backend.symlink(g,p),null}async backFile(g,p){return await this._backend.backFile(g,p),null}async du(g){return this._backend.du(g)}async flush(){return this._backend.flush()}},Ti}var Ci,cs;function Wo(){if(cs)return Ci;cs=1;const P=bo(),A=Lo();function B(m,I){return typeof m=="function"&&(I=m),I=P(I),[(...x)=>I(null,...x),I]}return Ci=class{constructor(...I){this.promises=new A(...I),this.init=this.init.bind(this),this.readFile=this.readFile.bind(this),this.writeFile=this.writeFile.bind(this),this.unlink=this.unlink.bind(this),this.readdir=this.readdir.bind(this),this.mkdir=this.mkdir.bind(this),this.rmdir=this.rmdir.bind(this),this.rename=this.rename.bind(this),this.stat=this.stat.bind(this),this.lstat=this.lstat.bind(this),this.readlink=this.readlink.bind(this),this.symlink=this.symlink.bind(this),this.backFile=this.backFile.bind(this),this.du=this.du.bind(this),this.flush=this.flush.bind(this)}init(I,D){return this.promises.init(I,D)}readFile(I,D,x){const[g,p]=B(D,x);this.promises.readFile(I,D).then(g).catch(p)}writeFile(I,D,x,g){const[p,U]=B(x,g);this.promises.writeFile(I,D,x).then(p).catch(U)}unlink(I,D,x){const[g,p]=B(D,x);this.promises.unlink(I,D).then(g).catch(p)}readdir(I,D,x){const[g,p]=B(D,x);this.promises.readdir(I,D).then(g).catch(p)}mkdir(I,D,x){const[g,p]=B(D,x);this.promises.mkdir(I,D).then(g).catch(p)}rmdir(I,D,x){const[g,p]=B(D,x);this.promises.rmdir(I,D).then(g).catch(p)}rename(I,D,x){const[g,p]=B(x);this.promises.rename(I,D).then(g).catch(p)}stat(I,D,x){const[g,p]=B(D,x);this.promises.stat(I).then(g).catch(p)}lstat(I,D,x){const[g,p]=B(D,x);this.promises.lstat(I).then(g).catch(p)}readlink(I,D,x){const[g,p]=B(D,x);this.promises.readlink(I).then(g).catch(p)}symlink(I,D,x){const[g,p]=B(x);this.promises.symlink(I,D).then(g).catch(p)}backFile(I,D,x){const[g,p]=B(D,x);this.promises.backFile(I,D).then(g).catch(p)}du(I,D){const[x,g]=B(D);this.promises.du(I).then(x).catch(g)}flush(I){const[D,x]=B(I);this.promises.flush().then(D).catch(x)}},Ci}var Go=Wo();const ac=fs(Go);var T={},ls;function Vo(){if(ls)return T;ls=1,Object.defineProperty(T,"__esModule",{value:!0});function P(n){return n&&typeof n=="object"&&"default"in n?n.default:n}var A=P(_o()),B=P(ko()),m=vo(),I=P(So()),D=P($o()),x=P(jo()),g=P(xo()),p=P(Eo()),U=P(Ro());class j extends Error{constructor(t){super(t),this.caller=""}toJSON(){return{code:this.code,data:this.data,caller:this.caller,message:this.message,stack:this.stack}}fromJSON(t){const e=new j(t.message);return e.code=t.code,e.data=t.data,e.caller=t.caller,e.stack=t.stack,e}get isIsomorphicGitError(){return!0}}class L extends j{constructor(t){super(`Modifying the index is not possible because you have unmerged files: ${t.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`),this.code=this.name=L.code,this.data={filepaths:t}}}L.code="UnmergedPathsError";class M extends j{constructor(t){super(`An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${t}`),this.code=this.name=M.code,this.data={message:t}}}M.code="InternalError";class R extends j{constructor(t){super(`The filepath "${t}" contains unsafe character sequences`),this.code=this.name=R.code,this.data={filepath:t}}}R.code="UnsafeFilepathError";class H{constructor(t){this.buffer=t,this._start=0}eof(){return this._start>=this.buffer.length}tell(){return this._start}seek(t){this._start=t}slice(t){const e=this.buffer.slice(this._start,this._start+t);return this._start+=t,e}toString(t,e){const i=this.buffer.toString(t,this._start,this._start+e);return this._start+=e,i}write(t,e,i){const r=this.buffer.write(t,this._start,e,i);return this._start+=e,r}copy(t,e,i){const r=t.copy(this.buffer,this._start,e,i);return this._start+=r,r}readUInt8(){const t=this.buffer.readUInt8(this._start);return this._start+=1,t}writeUInt8(t){const e=this.buffer.writeUInt8(t,this._start);return this._start+=1,e}readUInt16BE(){const t=this.buffer.readUInt16BE(this._start);return this._start+=2,t}writeUInt16BE(t){const e=this.buffer.writeUInt16BE(t,this._start);return this._start+=2,e}readUInt32BE(){const t=this.buffer.readUInt32BE(this._start);return this._start+=4,t}writeUInt32BE(t){const e=this.buffer.writeUInt32BE(t,this._start);return this._start+=4,e}}function G(n,t){return-(n<t)||+(n>t)}function V(n,t){return G(n.path,t.path)}function K(n){let t=n>0?n>>12:0;t!==4&&t!==8&&t!==10&&t!==14&&(t=8);let e=n&511;return e&73?e=493:e=420,t!==8&&(e=0),(t<<12)+e}const Z=2**32;function gt(n,t,e,i){if(n!==void 0&&t!==void 0)return[n,t];e===void 0&&(e=i.valueOf());const r=Math.floor(e/1e3),s=(e-r*1e3)*1e6;return[r,s]}function Et(n){const[t,e]=gt(n.ctimeSeconds,n.ctimeNanoseconds,n.ctimeMs,n.ctime),[i,r]=gt(n.mtimeSeconds,n.mtimeNanoseconds,n.mtimeMs,n.mtime);return{ctimeSeconds:t%Z,ctimeNanoseconds:e%Z,mtimeSeconds:i%Z,mtimeNanoseconds:r%Z,dev:n.dev%Z,ino:n.ino%Z,mode:K(n.mode%Z),uid:n.uid%Z,gid:n.gid%Z,size:n.size>-1?n.size%Z:0}}function Xe(n){let t="";for(const e of new Uint8Array(n))e<16&&(t+="0"),t+=e.toString(16);return t}let Ye=null;async function jt(n){return Ye===null&&(Ye=await ms()),Ye?Di(n):ws(n)}function ws(n){return new B().update(n).digest("hex")}async function Di(n){const t=await crypto.subtle.digest("SHA-1",n);return Xe(t)}async function ms(){try{return await Di(new Uint8Array([]))==="da39a3ee5e6b4b0d3255bfef95601890afd80709"}catch{}return!1}function ps(n){return{assumeValid:!!(n&32768),extended:!!(n&16384),stage:(n&12288)>>12,nameLength:n&4095}}function ys(n){const t=n.flags;return t.extended=!1,t.nameLength=Math.min(Buffer.from(n.path).length,4095),(t.assumeValid?32768:0)+(t.extended?16384:0)+((t.stage&3)<<12)+(t.nameLength&4095)}class Nt{constructor(t,e){this._dirty=!1,this._unmergedPaths=e||new Set,this._entries=t||new Map}_addEntry(t){if(t.flags.stage===0)t.stages=[t],this._entries.set(t.path,t),this._unmergedPaths.delete(t.path);else{let e=this._entries.get(t.path);e||(this._entries.set(t.path,t),e=t),e.stages[t.flags.stage]=t,this._unmergedPaths.add(t.path)}}static async from(t){if(Buffer.isBuffer(t))return Nt.fromBuffer(t);if(t===null)return new Nt(null);throw new M("invalid type passed to GitIndex.from")}static async fromBuffer(t){if(t.length===0)throw new M("Index file is empty (.git/index)");const e=new Nt,i=new H(t),r=i.toString("utf8",4);if(r!=="DIRC")throw new M(`Invalid dircache magic file number: ${r}`);const s=await jt(t.slice(0,-20)),a=t.slice(-20).toString("hex");if(a!==s)throw new M(`Invalid checksum in GitIndex buffer: expected ${a} but saw ${s}`);const o=i.readUInt32BE();if(o!==2)throw new M(`Unsupported dircache version: ${o}`);const f=i.readUInt32BE();let l=0;for(;!i.eof()&&l<f;){const c={};c.ctimeSeconds=i.readUInt32BE(),c.ctimeNanoseconds=i.readUInt32BE(),c.mtimeSeconds=i.readUInt32BE(),c.mtimeNanoseconds=i.readUInt32BE(),c.dev=i.readUInt32BE(),c.ino=i.readUInt32BE(),c.mode=i.readUInt32BE(),c.uid=i.readUInt32BE(),c.gid=i.readUInt32BE(),c.size=i.readUInt32BE(),c.oid=i.slice(20).toString("hex");const h=i.readUInt16BE();c.flags=ps(h);const u=t.indexOf(0,i.tell()+1)-i.tell();if(u<1)throw new M(`Got a path length of: ${u}`);if(c.path=i.toString("utf8",u),c.path.includes("..\\")||c.path.includes("../"))throw new R(c.path);let d=8-(i.tell()-12)%8;for(d===0&&(d=8);d--;){const y=i.readUInt8();if(y!==0)throw new M(`Expected 1-8 null characters but got '${y}' after ${c.path}`);if(i.eof())throw new M("Unexpected end of file")}c.stages=[],e._addEntry(c),l++}return e}get unmergedPaths(){return[...this._unmergedPaths]}get entries(){return[...this._entries.values()].sort(V)}get entriesMap(){return this._entries}get entriesFlat(){return[...this.entries].flatMap(t=>t.stages.length>1?t.stages.filter(e=>e):t)}*[Symbol.iterator](){for(const t of this.entries)yield t}insert({filepath:t,stats:e,oid:i,stage:r=0}){e||(e={ctimeSeconds:0,ctimeNanoseconds:0,mtimeSeconds:0,mtimeNanoseconds:0,dev:0,ino:0,mode:0,uid:0,gid:0,size:0}),e=Et(e);const s=Buffer.from(t),a={ctimeSeconds:e.ctimeSeconds,ctimeNanoseconds:e.ctimeNanoseconds,mtimeSeconds:e.mtimeSeconds,mtimeNanoseconds:e.mtimeNanoseconds,dev:e.dev,ino:e.ino,mode:e.mode||33188,uid:e.uid,gid:e.gid,size:e.size,path:t,oid:i,flags:{assumeValid:!1,extended:!1,stage:r,nameLength:s.length<4095?s.length:4095},stages:[]};this._addEntry(a),this._dirty=!0}delete({filepath:t}){if(this._entries.has(t))this._entries.delete(t);else for(const e of this._entries.keys())e.startsWith(t+"/")&&this._entries.delete(e);this._unmergedPaths.has(t)&&this._unmergedPaths.delete(t),this._dirty=!0}clear(){this._entries.clear(),this._dirty=!0}has({filepath:t}){return this._entries.has(t)}render(){return this.entries.map(t=>`${t.mode.toString(8)} ${t.oid}    ${t.path}`).join(`
`)}static async _entryToBuffer(t){const e=Buffer.from(t.path),i=Math.ceil((62+e.length+1)/8)*8,r=Buffer.alloc(i),s=new H(r),a=Et(t);return s.writeUInt32BE(a.ctimeSeconds),s.writeUInt32BE(a.ctimeNanoseconds),s.writeUInt32BE(a.mtimeSeconds),s.writeUInt32BE(a.mtimeNanoseconds),s.writeUInt32BE(a.dev),s.writeUInt32BE(a.ino),s.writeUInt32BE(a.mode),s.writeUInt32BE(a.uid),s.writeUInt32BE(a.gid),s.writeUInt32BE(a.size),s.write(t.oid,20,"hex"),s.writeUInt16BE(ys(t)),s.write(t.path,e.length,"utf8"),r}async toObject(){const t=Buffer.alloc(12),e=new H(t);e.write("DIRC",4,"utf8"),e.writeUInt32BE(2),e.writeUInt32BE(this.entriesFlat.length);let i=[];for(const o of this.entries)if(i.push(Nt._entryToBuffer(o)),o.stages.length>1)for(const f of o.stages)f&&f!==o&&i.push(Nt._entryToBuffer(f));i=await Promise.all(i);const r=Buffer.concat(i),s=Buffer.concat([t,r]),a=await jt(s);return Buffer.concat([s,Buffer.from(a,"hex")])}}function Ie(n,t,e=!0,i=!0){const r=Et(n),s=Et(t);return e&&r.mode!==s.mode||r.mtimeSeconds!==s.mtimeSeconds||r.ctimeSeconds!==s.ctimeSeconds||r.uid!==s.uid||r.gid!==s.gid||i&&r.ino!==s.ino||r.size!==s.size}let Ze=null;const Qe=Symbol("IndexCache");function gs(){return{map:new Map,stats:new Map}}async function bs(n,t,e){const[i,r]=await Promise.all([n.lstat(t),n.read(t)]),s=await Nt.from(r);e.map.set(t,s),e.stats.set(t,i)}async function _s(n,t,e){const i=e.stats.get(t);if(i===void 0)return!0;if(i===null)return!1;const r=await n.lstat(t);return r===null?!1:Ie(i,r)}class st{static async acquire({fs:t,gitdir:e,cache:i,allowUnmerged:r=!0},s){i[Qe]||(i[Qe]=gs());const a=`${e}/index`;Ze===null&&(Ze=new A({maxPending:1/0}));let o,f=[];return await Ze.acquire(a,async()=>{const l=i[Qe];await _s(t,a,l)&&await bs(t,a,l);const c=l.map.get(a);if(f=c.unmergedPaths,f.length&&!r)throw new L(f);if(o=await s(c),c._dirty){const h=await c.toObject();await t.write(a,h),l.stats.set(a,await t.lstat(a)),c._dirty=!1}}),o}}function Pe(n){const t=Math.max(n.lastIndexOf("/"),n.lastIndexOf("\\"));return t>-1&&(n=n.slice(t+1)),n}function Gt(n){const t=Math.max(n.lastIndexOf("/"),n.lastIndexOf("\\"));return t===-1?".":t===0?"/":n.slice(0,t)}function Ni(n){const t=new Map,e=function(r){if(!t.has(r)){const s={type:"tree",fullpath:r,basename:Pe(r),metadata:{},children:[]};t.set(r,s),s.parent=e(Gt(r)),s.parent&&s.parent!==s&&s.parent.children.push(s)}return t.get(r)},i=function(r,s){if(!t.has(r)){const a={type:"blob",fullpath:r,basename:Pe(r),metadata:s,parent:e(Gt(r)),children:[]};a.parent&&a.parent.children.push(a),t.set(r,a)}return t.get(r)};e(".");for(const r of n)i(r.path,r);return t}function ks(n){switch(n){case 16384:return"tree";case 33188:return"blob";case 33261:return"blob";case 40960:return"blob";case 57344:return"commit"}throw new M(`Unexpected GitTree entry mode: ${n.toString(8)}`)}class vs{constructor({fs:t,gitdir:e,cache:i}){this.treePromise=st.acquire({fs:t,gitdir:e,cache:i},async function(s){return Ni(s.entries)});const r=this;this.ConstructEntry=class{constructor(a){this._fullpath=a,this._type=!1,this._mode=!1,this._stat=!1,this._oid=!1}async type(){return r.type(this)}async mode(){return r.mode(this)}async stat(){return r.stat(this)}async content(){return r.content(this)}async oid(){return r.oid(this)}}}async readdir(t){const e=t._fullpath,r=(await this.treePromise).get(e);if(!r||r.type==="blob")return null;if(r.type!=="tree")throw new Error(`ENOTDIR: not a directory, scandir '${e}'`);const s=r.children.map(a=>a.fullpath);return s.sort(G),s}async type(t){return t._type===!1&&await t.stat(),t._type}async mode(t){return t._mode===!1&&await t.stat(),t._mode}async stat(t){if(t._stat===!1){const i=(await this.treePromise).get(t._fullpath);if(!i)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);const r=i.type==="tree"?{}:Et(i.metadata);t._type=i.type==="tree"?"tree":ks(r.mode),t._mode=r.mode,i.type==="tree"?t._stat=void 0:t._stat=r}return t._stat}async content(t){}async oid(t){if(t._oid===!1){const i=(await this.treePromise).get(t._fullpath);t._oid=i.metadata.oid}return t._oid}}const Te=Symbol("GitWalkSymbol");function Mt(){const n=Object.create(null);return Object.defineProperty(n,Te,{value:function({fs:t,gitdir:e,cache:i}){return new vs({fs:t,gitdir:e,cache:i})}}),Object.freeze(n),n}class Q extends j{constructor(t){super(`Could not find ${t}.`),this.code=this.name=Q.code,this.data={what:t}}}Q.code="NotFoundError";class dt extends j{constructor(t,e,i,r){super(`Object ${t} ${r?`at ${r}`:""}was anticipated to be a ${i} but it is a ${e}.`),this.code=this.name=dt.code,this.data={oid:t,actual:e,expected:i,filepath:r}}}dt.code="ObjectTypeError";class Bt extends j{constructor(t){super(`Expected a 40-char hex object id but saw "${t}".`),this.code=this.name=Bt.code,this.data={value:t}}}Bt.code="InvalidOidError";class ce extends j{constructor(t){super(`Could not find a fetch refspec for remote "${t}". Make sure the config file has an entry like the following:
[remote "${t}"]
	fetch = +refs/heads/*:refs/remotes/origin/*
`),this.code=this.name=ce.code,this.data={remote:t}}}ce.code="NoRefspecError";class Ce{constructor(t){if(this.refs=new Map,this.parsedConfig=[],t){let e=null;this.parsedConfig=t.trim().split(`
`).map(i=>{if(/^\s*#/.test(i))return{line:i,comment:!0};const r=i.indexOf(" ");if(i.startsWith("^")){const s=i.slice(1);return this.refs.set(e+"^{}",s),{line:i,ref:e,peeled:s}}else{const s=i.slice(0,r);return e=i.slice(r+1),this.refs.set(e,s),{line:i,ref:e,oid:s}}})}return this}static from(t){return new Ce(t)}delete(t){this.parsedConfig=this.parsedConfig.filter(e=>e.ref!==t),this.refs.delete(t)}toString(){return this.parsedConfig.map(({line:t})=>t).join(`
`)+`
`}}class Ae{constructor({remotePath:t,localPath:e,force:i,matchPrefix:r}){Object.assign(this,{remotePath:t,localPath:e,force:i,matchPrefix:r})}static from(t){const[e,i,r,s,a]=t.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1),o=e==="+",f=r==="*";if(f!==(a==="*"))throw new M("Invalid refspec");return new Ae({remotePath:i,localPath:s,force:o,matchPrefix:f})}translate(t){if(this.matchPrefix){if(t.startsWith(this.remotePath))return this.localPath+t.replace(this.remotePath,"")}else if(t===this.remotePath)return this.localPath;return null}reverseTranslate(t){if(this.matchPrefix){if(t.startsWith(this.localPath))return this.remotePath+t.replace(this.localPath,"")}else if(t===this.localPath)return this.remotePath;return null}}class Je{constructor(t=[]){this.rules=t}static from(t){const e=[];for(const i of t)e.push(Ae.from(i));return new Je(e)}add(t){const e=Ae.from(t);this.rules.push(e)}translate(t){const e=[];for(const i of this.rules)for(const r of t){const s=i.translate(r);s&&e.push([r,s])}return e}translateOne(t){let e=null;for(const i of this.rules){const r=i.translate(t);r&&(e=r)}return e}localNamespaces(){return this.rules.filter(t=>t.matchPrefix).map(t=>t.localPath.replace(/\/$/,""))}}function Ss(n,t){const e=n.replace(/\^\{\}$/,""),i=t.replace(/\^\{\}$/,""),r=-(e<i)||+(e>i);return r===0?n.endsWith("^{}")?1:-1:r}const $s=n=>{if(typeof n=="number")return n;n=n.toLowerCase();let t=parseInt(n);return n.endsWith("k")&&(t*=1024),n.endsWith("m")&&(t*=1024*1024),n.endsWith("g")&&(t*=1024*1024*1024),t},le=n=>{if(typeof n=="boolean")return n;if(n=n.trim().toLowerCase(),n==="true"||n==="yes"||n==="on")return!0;if(n==="false"||n==="no"||n==="off")return!1;throw Error(`Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${n}`)},Mi={core:{filemode:le,bare:le,logallrefupdates:le,symlinks:le,ignorecase:le,bigFileThreshold:$s}},xs=/^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/,Es=/^[A-Za-z0-9-.]+$/,js=/^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/,Rs=/^[A-Za-z][A-Za-z-]*$/,Os=/^(.*?)( *[#;].*)$/,Bs=n=>{const t=xs.exec(n);if(t!=null){const[e,i]=t.slice(1);return[e,i]}return null},Is=n=>{const t=js.exec(n);if(t!=null){const[e,i="true"]=t.slice(1),r=Ps(i),s=Ts(r);return[e,s]}return null},Ps=n=>{const t=Os.exec(n);if(t==null)return n;const[e,i]=t.slice(1);return Fi(e)&&Fi(i)?`${e}${i}`:e},Fi=n=>(n.match(/(?:^|[^\\])"/g)||[]).length%2!==0,Ts=n=>n.split("").reduce((t,e,i,r)=>{const s=e==='"'&&r[i-1]!=="\\",a=e==="\\"&&r[i+1]==='"';return s||a?t:t+e},""),Ui=n=>n!=null?n.toLowerCase():null,Ke=(n,t,e)=>[Ui(n),t,Ui(e)].filter(i=>i!=null).join("."),Hi=n=>{const t=n.split("."),e=t.shift(),i=t.pop(),r=t.length?t.join("."):void 0;return{section:e,subsection:r,name:i,path:Ke(e,r,i),sectionPath:Ke(e,r,null),isSection:!!e}},Cs=(n,t)=>n.reduce((e,i,r)=>t(i)?r:e,-1);class ti{constructor(t){let e=null,i=null;this.parsedConfig=t?t.split(`
`).map(r=>{let s=null,a=null;const o=r.trim(),f=Bs(o),l=f!=null;if(l)[e,i]=f;else{const h=Is(o);h!=null&&([s,a]=h)}const c=Ke(e,i,s);return{line:r,isSection:l,section:e,subsection:i,name:s,value:a,path:c}}):[]}static from(t){return new ti(t)}async get(t,e=!1){const i=Hi(t).path,r=this.parsedConfig.filter(s=>s.path===i).map(({section:s,name:a,value:o})=>{const f=Mi[s]&&Mi[s][a];return f?f(o):o});return e?r:r.pop()}async getall(t){return this.get(t,!0)}async getSubsections(t){return this.parsedConfig.filter(e=>e.isSection&&e.section===t).map(e=>e.subsection)}async deleteSection(t,e){this.parsedConfig=this.parsedConfig.filter(i=>!(i.section===t&&i.subsection===e))}async append(t,e){return this.set(t,e,!0)}async set(t,e,i=!1){const{section:r,subsection:s,name:a,path:o,sectionPath:f,isSection:l}=Hi(t),c=Cs(this.parsedConfig,h=>h.path===o);if(e==null)c!==-1&&this.parsedConfig.splice(c,1);else if(c!==-1){const h=this.parsedConfig[c],u=Object.assign({},h,{name:a,value:e,modified:!0});i?this.parsedConfig.splice(c+1,0,u):this.parsedConfig[c]=u}else{const h=this.parsedConfig.findIndex(d=>d.path===f),u={section:r,subsection:s,name:a,value:e,modified:!0,path:o};if(Es.test(r)&&Rs.test(a))if(h>=0)this.parsedConfig.splice(h+1,0,u);else{const d={isSection:l,section:r,subsection:s,modified:!0,path:f};this.parsedConfig.push(d,u)}}}toString(){return this.parsedConfig.map(({line:t,section:e,subsection:i,name:r,value:s,modified:a=!1})=>a?r!=null&&s!=null?typeof s=="string"&&/[#;]/.test(s)?`	${r} = "${s}"`:`	${r} = ${s}`:i!=null?`[${e} "${i}"]`:`[${e}]`:t).join(`
`)}}class rt{static async get({fs:t,gitdir:e}){const i=await t.read(`${e}/config`,{encoding:"utf8"});return ti.from(i)}static async save({fs:t,gitdir:e,config:i}){await t.write(`${e}/config`,i.toString(),{encoding:"utf8"})}}const De=n=>[`${n}`,`refs/${n}`,`refs/tags/${n}`,`refs/heads/${n}`,`refs/remotes/${n}`,`refs/remotes/${n}/HEAD`],As=["config","description","index","shallow","commondir"];let ei;async function It(n,t){return ei===void 0&&(ei=new A),ei.acquire(n,t)}class S{static async updateRemoteRefs({fs:t,gitdir:e,remote:i,refs:r,symrefs:s,tags:a,refspecs:o=void 0,prune:f=!1,pruneTags:l=!1}){for(const _ of r.values())if(!_.match(/[0-9a-f]{40}/))throw new Bt(_);const c=await rt.get({fs:t,gitdir:e});if(!o){if(o=await c.getall(`remote.${i}.fetch`),o.length===0)throw new ce(i);o.unshift(`+HEAD:refs/remotes/${i}/HEAD`)}const h=Je.from(o),u=new Map;if(l){const _=await S.listRefs({fs:t,gitdir:e,filepath:"refs/tags"});await S.deleteRefs({fs:t,gitdir:e,refs:_.map(k=>`refs/tags/${k}`)})}if(a){for(const _ of r.keys())if(_.startsWith("refs/tags")&&!_.endsWith("^{}")&&!await S.exists({fs:t,gitdir:e,ref:_})){const k=r.get(_);u.set(_,k)}}const d=h.translate([...r.keys()]);for(const[_,k]of d){const v=r.get(_);u.set(k,v)}const y=h.translate([...s.keys()]);for(const[_,k]of y){const v=s.get(_),O=h.translateOne(v);O&&u.set(k,`ref: ${O}`)}const b=[];if(f){for(const _ of h.localNamespaces()){const k=(await S.listRefs({fs:t,gitdir:e,filepath:_})).map(v=>`${_}/${v}`);for(const v of k)u.has(v)||b.push(v)}b.length>0&&await S.deleteRefs({fs:t,gitdir:e,refs:b})}for(const[_,k]of u)await It(_,async()=>t.write(m.join(e,_),`${k.trim()}
`,"utf8"));return{pruned:b}}static async writeRef({fs:t,gitdir:e,ref:i,value:r}){if(!r.match(/[0-9a-f]{40}/))throw new Bt(r);await It(i,async()=>t.write(m.join(e,i),`${r.trim()}
`,"utf8"))}static async writeSymbolicRef({fs:t,gitdir:e,ref:i,value:r}){await It(i,async()=>t.write(m.join(e,i),`ref: ${r.trim()}
`,"utf8"))}static async deleteRef({fs:t,gitdir:e,ref:i}){return S.deleteRefs({fs:t,gitdir:e,refs:[i]})}static async deleteRefs({fs:t,gitdir:e,refs:i}){await Promise.all(i.map(o=>t.rm(m.join(e,o))));let r=await It("packed-refs",async()=>t.read(`${e}/packed-refs`,{encoding:"utf8"}));const s=Ce.from(r),a=s.refs.size;for(const o of i)s.refs.has(o)&&s.delete(o);s.refs.size<a&&(r=s.toString(),await It("packed-refs",async()=>t.write(`${e}/packed-refs`,r,{encoding:"utf8"})))}static async resolve({fs:t,gitdir:e,ref:i,depth:r=void 0}){if(r!==void 0&&(r--,r===-1))return i;if(i.startsWith("ref: "))return i=i.slice(5),S.resolve({fs:t,gitdir:e,ref:i,depth:r});if(i.length===40&&/[0-9a-f]{40}/.test(i))return i;const s=await S.packedRefs({fs:t,gitdir:e}),a=De(i).filter(o=>!As.includes(o));for(const o of a){const f=await It(o,async()=>await t.read(`${e}/${o}`,{encoding:"utf8"})||s.get(o));if(f)return S.resolve({fs:t,gitdir:e,ref:f.trim(),depth:r})}throw new Q(i)}static async exists({fs:t,gitdir:e,ref:i}){try{return await S.expand({fs:t,gitdir:e,ref:i}),!0}catch{return!1}}static async expand({fs:t,gitdir:e,ref:i}){if(i.length===40&&/[0-9a-f]{40}/.test(i))return i;const r=await S.packedRefs({fs:t,gitdir:e}),s=De(i);for(const a of s)if(await It(a,async()=>t.exists(`${e}/${a}`))||r.has(a))return a;throw new Q(i)}static async expandAgainstMap({ref:t,map:e}){const i=De(t);for(const r of i)if(await e.has(r))return r;throw new Q(t)}static resolveAgainstMap({ref:t,fullref:e=t,depth:i=void 0,map:r}){if(i!==void 0&&(i--,i===-1))return{fullref:e,oid:t};if(t.startsWith("ref: "))return t=t.slice(5),S.resolveAgainstMap({ref:t,fullref:e,depth:i,map:r});if(t.length===40&&/[0-9a-f]{40}/.test(t))return{fullref:e,oid:t};const s=De(t);for(const a of s){const o=r.get(a);if(o)return S.resolveAgainstMap({ref:o.trim(),fullref:a,depth:i,map:r})}throw new Q(t)}static async packedRefs({fs:t,gitdir:e}){const i=await It("packed-refs",async()=>t.read(`${e}/packed-refs`,{encoding:"utf8"}));return Ce.from(i).refs}static async listRefs({fs:t,gitdir:e,filepath:i}){const r=S.packedRefs({fs:t,gitdir:e});let s=null;try{s=await t.readdirDeep(`${e}/${i}`),s=s.map(a=>a.replace(`${e}/${i}/`,""))}catch{s=[]}for(let a of(await r).keys())a.startsWith(i)&&(a=a.replace(i+"/",""),s.includes(a)||s.push(a));return s.sort(Ss),s}static async listBranches({fs:t,gitdir:e,remote:i}){return i?S.listRefs({fs:t,gitdir:e,filepath:`refs/remotes/${i}`}):S.listRefs({fs:t,gitdir:e,filepath:"refs/heads"})}static async listTags({fs:t,gitdir:e}){return(await S.listRefs({fs:t,gitdir:e,filepath:"refs/tags"})).filter(r=>!r.endsWith("^{}"))}}function Ds(n,t){return G(zi(n),zi(t))}function zi(n){return n.mode==="040000"?n.path+"/":n.path}function qi(n){switch(n){case"040000":return"tree";case"100644":return"blob";case"100755":return"blob";case"120000":return"blob";case"160000":return"commit"}throw new M(`Unexpected GitTree entry mode: ${n}`)}function Ns(n){const t=[];let e=0;for(;e<n.length;){const i=n.indexOf(32,e);if(i===-1)throw new M(`GitTree: Error parsing buffer at byte location ${e}: Could not find the next space character.`);const r=n.indexOf(0,e);if(r===-1)throw new M(`GitTree: Error parsing buffer at byte location ${e}: Could not find the next null character.`);let s=n.slice(e,i).toString("utf8");s==="40000"&&(s="040000");const a=qi(s),o=n.slice(i+1,r).toString("utf8");if(o.includes("\\")||o.includes("/"))throw new R(o);const f=n.slice(r+1,r+21).toString("hex");e=r+21,t.push({mode:s,path:o,oid:f,type:a})}return t}function Ms(n){if(typeof n=="number"&&(n=n.toString(8)),n.match(/^0?4.*/))return"040000";if(n.match(/^1006.*/))return"100644";if(n.match(/^1007.*/))return"100755";if(n.match(/^120.*/))return"120000";if(n.match(/^160.*/))return"160000";throw new M(`Could not understand file mode: ${n}`)}function Fs(n){return!n.oid&&n.sha&&(n.oid=n.sha),n.mode=Ms(n.mode),n.type||(n.type=qi(n.mode)),n}class mt{constructor(t){if(Buffer.isBuffer(t))this._entries=Ns(t);else if(Array.isArray(t))this._entries=t.map(Fs);else throw new M("invalid type passed to GitTree constructor");this._entries.sort(V)}static from(t){return new mt(t)}render(){return this._entries.map(t=>`${t.mode} ${t.type} ${t.oid}    ${t.path}`).join(`
`)}toObject(){const t=[...this._entries];return t.sort(Ds),Buffer.concat(t.map(e=>{const i=Buffer.from(e.mode.replace(/^0/,"")),r=Buffer.from(" "),s=Buffer.from(e.path,"utf8"),a=Buffer.from([0]),o=Buffer.from(e.oid,"hex");return Buffer.concat([i,r,s,a,o])}))}entries(){return this._entries}*[Symbol.iterator](){for(const t of this._entries)yield t}}class Vt{static wrap({type:t,object:e}){const i=`${t} ${e.length}\0`,r=i.length,s=r+e.length,a=new Uint8Array(s);for(let o=0;o<r;o++)a[o]=i.charCodeAt(o);return a.set(e,r),a}static unwrap(t){const e=t.indexOf(32),i=t.indexOf(0),r=t.slice(0,e).toString("utf8"),s=t.slice(e+1,i).toString("utf8"),a=t.length-(i+1);if(parseInt(s)!==a)throw new M(`Length mismatch: expected ${s} bytes but got ${a} instead.`);return{type:r,object:Buffer.from(t.slice(i+1))}}}async function Li({fs:n,gitdir:t,oid:e}){const i=`objects/${e.slice(0,2)}/${e.slice(2)}`,r=await n.read(`${t}/${i}`);return r?{object:r,format:"deflated",source:i}:null}function Us(n,t){const e=new H(n),i=Wi(e);if(i!==t.byteLength)throw new M(`applyDelta expected source buffer to be ${i} bytes but the provided buffer was ${t.length} bytes`);const r=Wi(e);let s;const a=Vi(e,t);if(a.byteLength===r)s=a;else{s=Buffer.alloc(r);const o=new H(s);for(o.copy(a);!e.eof();)o.copy(Vi(e,t));const f=o.tell();if(r!==f)throw new M(`applyDelta expected target buffer to be ${r} bytes but the resulting buffer was ${f} bytes`)}return s}function Wi(n){let t=0,e=0,i=null;do i=n.readUInt8(),t|=(i&127)<<e,e+=7;while(i&128);return t}function Gi(n,t,e){let i=0,r=0;for(;e--;)t&1&&(i|=n.readUInt8()<<r),t>>=1,r+=8;return i}function Vi(n,t){const e=n.readUInt8(),i=128,r=15,s=112;if(e&i){const a=Gi(n,e&r,4);let o=Gi(n,(e&s)>>4,3);return o===0&&(o=65536),t.slice(a,a+o)}else return n.slice(e)}function Hs(n){let t=[n];return{next(){return Promise.resolve({done:t.length===0,value:t.pop()})},return(){return t=[],{}},[Symbol.asyncIterator](){return this}}}function Xi(n){return n[Symbol.asyncIterator]?n[Symbol.asyncIterator]():n[Symbol.iterator]?n[Symbol.iterator]():n.next?n:Hs(n)}class Yi{constructor(t){if(typeof Buffer>"u")throw new Error("Missing Buffer dependency");this.stream=Xi(t),this.buffer=null,this.cursor=0,this.undoCursor=0,this.started=!1,this._ended=!1,this._discardedBytes=0}eof(){return this._ended&&this.cursor===this.buffer.length}tell(){return this._discardedBytes+this.cursor}async byte(){if(!this.eof()&&(this.started||await this._init(),!(this.cursor===this.buffer.length&&(await this._loadnext(),this._ended))))return this._moveCursor(1),this.buffer[this.undoCursor]}async chunk(){if(!this.eof()&&(this.started||await this._init(),!(this.cursor===this.buffer.length&&(await this._loadnext(),this._ended))))return this._moveCursor(this.buffer.length),this.buffer.slice(this.undoCursor,this.cursor)}async read(t){if(!this.eof())return this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t),this.buffer.slice(this.undoCursor,this.cursor)}async skip(t){this.eof()||(this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t))}async undo(){this.cursor=this.undoCursor}async _next(){this.started=!0;let{done:t,value:e}=await this.stream.next();return t&&(this._ended=!0,!e)?Buffer.alloc(0):(e&&(e=Buffer.from(e)),e)}_trim(){this.buffer=this.buffer.slice(this.undoCursor),this.cursor-=this.undoCursor,this._discardedBytes+=this.undoCursor,this.undoCursor=0}_moveCursor(t){this.undoCursor=this.cursor,this.cursor+=t,this.cursor>this.buffer.length&&(this.cursor=this.buffer.length)}async _accumulate(t){if(this._ended)return;const e=[this.buffer];for(;this.cursor+t>zs(e);){const i=await this._next();if(this._ended)break;e.push(i)}this.buffer=Buffer.concat(e)}async _loadnext(){this._discardedBytes+=this.buffer.length,this.undoCursor=0,this.cursor=0,this.buffer=await this._next()}async _init(){this.buffer=await this._next()}}function zs(n){return n.reduce((t,e)=>t+e.length,0)}async function qs(n,t){const e=new Yi(n);let i=await e.read(4);if(i=i.toString("utf8"),i!=="PACK")throw new M(`Invalid PACK header '${i}'`);let r=await e.read(4);if(r=r.readUInt32BE(0),r!==2)throw new M(`Invalid packfile version: ${r}`);let s=await e.read(4);if(s=s.readUInt32BE(0),!(s<1))for(;!e.eof()&&s--;){const a=e.tell(),{type:o,length:f,ofs:l,reference:c}=await Ls(e),h=new D.Inflate;for(;!h.result;){const u=await e.chunk();if(!u)break;if(h.push(u,!1),h.err)throw new M(`Pako error: ${h.msg}`);if(h.result){if(h.result.length!==f)throw new M("Inflated object size is different from that stated in packfile.");await e.undo(),await e.read(u.length-h.strm.avail_in);const d=e.tell();await t({data:h.result,type:o,num:s,offset:a,end:d,reference:c,ofs:l})}}}}async function Ls(n){let t=await n.byte();const e=t>>4&7;let i=t&15;if(t&128){let a=4;do t=await n.byte(),i|=(t&127)<<a,a+=7;while(t&128)}let r,s;if(e===6){let a=0;r=0;const o=[];do t=await n.byte(),r|=(t&127)<<a,a+=7,o.push(t);while(t&128);s=Buffer.from(o)}return e===7&&(s=await n.read(20)),{type:e,length:i,ofs:r,reference:s}}async function Zi(n){return D.inflate(n)}function Ws(n){const t=[];let e=0,i=0;do{e=n.readUInt8();const r=e&127;t.push(r),i=e&128}while(i);return t.reduce((r,s)=>r+1<<7|s,-1)}function Gs(n,t){let e=t,i=4,r=null;do r=n.readUInt8(),e|=(r&127)<<i,i+=7;while(r&128);return e}class Xt{constructor(t){Object.assign(this,t),this.offsetCache={}}static async fromIdx({idx:t,getExternalRefDelta:e}){const i=new H(t);if(i.slice(4).toString("hex")!=="ff744f63")return;const s=i.readUInt32BE();if(s!==2)throw new M(`Unable to read version ${s} packfile IDX. (Only version 2 supported)`);if(t.byteLength>2048*1024*1024)throw new M("To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.");i.seek(i.tell()+1020);const a=i.readUInt32BE(),o=[];for(let c=0;c<a;c++){const h=i.slice(20).toString("hex");o[c]=h}i.seek(i.tell()+4*a);const f=new Map;for(let c=0;c<a;c++)f.set(o[c],i.readUInt32BE());const l=i.slice(20).toString("hex");return new Xt({hashes:o,crcs:{},offsets:f,packfileSha:l,getExternalRefDelta:e})}static async fromPack({pack:t,getExternalRefDelta:e,onProgress:i}){const r={1:"commit",2:"tree",3:"blob",4:"tag",6:"ofs-delta",7:"ref-delta"},s={},a=t.slice(-20).toString("hex"),o=[],f={},l=new Map;let c=null,h=null;await qs([t],async({data:_,type:k,reference:v,offset:O,num:F})=>{c===null&&(c=F);const q=Math.floor((c-F)*100/c);q!==h&&i&&await i({phase:"Receiving objects",loaded:c-F,total:c}),h=q,k=r[k],["commit","tree","blob","tag"].includes(k)?s[O]={type:k,offset:O}:k==="ofs-delta"?s[O]={type:k,offset:O}:k==="ref-delta"&&(s[O]={type:k,offset:O})});const u=Object.keys(s).map(Number);for(const[_,k]of u.entries()){const v=_+1===u.length?t.byteLength-20:u[_+1],O=s[k],F=I.buf(t.slice(k,v))>>>0;O.end=v,O.crc=F}const d=new Xt({pack:Promise.resolve(t),packfileSha:a,crcs:f,hashes:o,offsets:l,getExternalRefDelta:e});h=null;let y=0;const b=[0,0,0,0,0,0,0,0,0,0,0,0];for(let _ in s){_=Number(_);const k=Math.floor(y*100/c);k!==h&&i&&await i({phase:"Resolving deltas",loaded:y,total:c}),y++,h=k;const v=s[_];if(!v.oid)try{d.readDepth=0,d.externalReadDepth=0;const{type:O,object:F}=await d.readSlice({start:_});b[d.readDepth]+=1;const q=await jt(Vt.wrap({type:O,object:F}));v.oid=q,o.push(q),l.set(q,_),f[q]=v.crc}catch{continue}}return o.sort(),d}async toBuffer(){const t=[],e=(l,c)=>{t.push(Buffer.from(l,c))};e("ff744f63","hex"),e("00000002","hex");const i=new H(Buffer.alloc(256*4));for(let l=0;l<256;l++){let c=0;for(const h of this.hashes)parseInt(h.slice(0,2),16)<=l&&c++;i.writeUInt32BE(c)}t.push(i.buffer);for(const l of this.hashes)e(l,"hex");const r=new H(Buffer.alloc(this.hashes.length*4));for(const l of this.hashes)r.writeUInt32BE(this.crcs[l]);t.push(r.buffer);const s=new H(Buffer.alloc(this.hashes.length*4));for(const l of this.hashes)s.writeUInt32BE(this.offsets.get(l));t.push(s.buffer),e(this.packfileSha,"hex");const a=Buffer.concat(t),o=await jt(a),f=Buffer.alloc(20);return f.write(o,"hex"),Buffer.concat([a,f])}async load({pack:t}){this.pack=t}async unload(){this.pack=null}async read({oid:t}){if(!this.offsets.get(t)){if(this.getExternalRefDelta)return this.externalReadDepth++,this.getExternalRefDelta(t);throw new M(`Could not read object ${t} from packfile`)}const e=this.offsets.get(t);return this.readSlice({start:e})}async readSlice({start:t}){if(this.offsetCache[t])return Object.assign({},this.offsetCache[t]);this.readDepth++;const e={16:"commit",32:"tree",48:"blob",64:"tag",96:"ofs_delta",112:"ref_delta"};if(!this.pack)throw new M("Tried to read from a GitPackIndex with no packfile loaded into memory");const i=(await this.pack).slice(t),r=new H(i),s=r.readUInt8(),a=s&112;let o=e[a];if(o===void 0)throw new M("Unrecognized type: 0b"+a.toString(2));const f=s&15;let l=f;s&128&&(l=Gs(r,f));let h=null,u=null;if(o==="ofs_delta"){const y=Ws(r),b=t-y;({object:h,type:o}=await this.readSlice({start:b}))}if(o==="ref_delta"){const y=r.slice(20).toString("hex");({object:h,type:o}=await this.read({oid:y}))}const d=i.slice(r.tell());if(u=Buffer.from(await Zi(d)),u.byteLength!==l)throw new M(`Packfile told us object would have length ${l} but it had length ${u.byteLength}`);return h&&(u=Buffer.from(Us(u,h))),this.readDepth>3&&(this.offsetCache[t]={type:o,object:u}),{type:o,format:"content",object:u}}}const Ne=Symbol("PackfileCache");async function Vs({fs:n,filename:t,getExternalRefDelta:e,emitter:i,emitterPrefix:r}){const s=await n.read(t);return Xt.fromIdx({idx:s,getExternalRefDelta:e})}function ii({fs:n,cache:t,filename:e,getExternalRefDelta:i,emitter:r,emitterPrefix:s}){t[Ne]||(t[Ne]=new Map);let a=t[Ne].get(e);return a||(a=Vs({fs:n,filename:e,getExternalRefDelta:i,emitter:r,emitterPrefix:s}),t[Ne].set(e,a)),a}async function Xs({fs:n,cache:t,gitdir:e,oid:i,format:r="content",getExternalRefDelta:s}){let a=await n.readdir(m.join(e,"objects/pack"));a=a.filter(o=>o.endsWith(".idx"));for(const o of a){const f=`${e}/objects/pack/${o}`,l=await ii({fs:n,cache:t,filename:f,getExternalRefDelta:s});if(l.error)throw new M(l.error);if(l.offsets.has(i)){if(!l.pack){const h=f.replace(/idx$/,"pack");l.pack=n.read(h)}const c=await l.read({oid:i,getExternalRefDelta:s});return c.format="content",c.source=`objects/pack/${o.replace(/idx$/,"pack")}`,c}}return null}async function tt({fs:n,cache:t,gitdir:e,oid:i,format:r="content"}){const s=c=>tt({fs:n,cache:t,gitdir:e,oid:c});let a;if(i==="4b825dc642cb6eb9a060e54bf8d69288fbee4904"&&(a={format:"wrapped",object:Buffer.from("tree 0\0")}),a||(a=await Li({fs:n,gitdir:e,oid:i})),!a){if(a=await Xs({fs:n,cache:t,gitdir:e,oid:i,getExternalRefDelta:s}),!a)throw new Q(i);return a}if(r==="deflated"||(a.format==="deflated"&&(a.object=Buffer.from(await Zi(a.object)),a.format="wrapped"),r==="wrapped"))return a;const o=await jt(a.object);if(o!==i)throw new M(`SHA check failed! Expected ${i}, computed ${o}`);const{object:f,type:l}=Vt.unwrap(a.object);if(a.type=l,a.object=f,a.format="content",r==="content")return a;throw new M(`invalid requested format "${r}"`)}class vt extends j{constructor(t,e,i=!0){super(`Failed to create ${t} at ${e} because it already exists.${i?` (Hint: use 'force: true' parameter to overwrite existing ${t}.)`:""}`),this.code=this.name=vt.code,this.data={noun:t,where:e,canForce:i}}}vt.code="AlreadyExistsError";class fe extends j{constructor(t,e,i){super(`Found multiple ${t} matching "${e}" (${i.join(", ")}). Use a longer abbreviation length to disambiguate them.`),this.code=this.name=fe.code,this.data={nouns:t,short:e,matches:i}}}fe.code="AmbiguousError";class ue extends j{constructor(t){super(`Your local changes to the following files would be overwritten by checkout: ${t.join(", ")}`),this.code=this.name=ue.code,this.data={filepaths:t}}}ue.code="CheckoutConflictError";class he extends j{constructor(t,e){super(`Failed to checkout "${t}" because commit ${e} is not available locally. Do a git fetch to make the branch available locally.`),this.code=this.name=he.code,this.data={ref:t,oid:e}}}he.code="CommitNotFetchedError";class de extends j{constructor(){super("Empty response from git server."),this.code=this.name=de.code,this.data={}}}de.code="EmptyServerResponseError";class we extends j{constructor(){super("A simple fast-forward merge was not possible."),this.code=this.name=we.code,this.data={}}}we.code="FastForwardError";class me extends j{constructor(t,e){super(`One or more branches were not updated: ${t}`),this.code=this.name=me.code,this.data={prettyDetails:t,result:e}}}me.code="GitPushError";class Yt extends j{constructor(t,e,i){super(`HTTP Error: ${t} ${e}`),this.code=this.name=Yt.code,this.data={statusCode:t,statusMessage:e,response:i}}}Yt.code="HttpError";class Pt extends j{constructor(t){let e="invalid filepath";t==="leading-slash"||t==="trailing-slash"?e='"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.':t==="directory"&&(e='"filepath" should not be a directory.'),super(e),this.code=this.name=Pt.code,this.data={reason:t}}}Pt.code="InvalidFilepathError";class St extends j{constructor(t,e){super(`"${t}" would be an invalid git reference. (Hint: a valid alternative would be "${e}".)`),this.code=this.name=St.code,this.data={ref:t,suggestion:e}}}St.code="InvalidRefNameError";class pe extends j{constructor(t){super(`Maximum search depth of ${t} exceeded.`),this.code=this.name=pe.code,this.data={depth:t}}}pe.code="MaxDepthError";class Zt extends j{constructor(){super("Merges with conflicts are not supported yet."),this.code=this.name=Zt.code,this.data={}}}Zt.code="MergeNotSupportedError";class Qt extends j{constructor(t,e,i,r){super(`Automatic merge failed with one or more merge conflicts in the following files: ${t.toString()}. Fix conflicts then commit the result.`),this.code=this.name=Qt.code,this.data={filepaths:t,bothModified:e,deleteByUs:i,deleteByTheirs:r}}}Qt.code="MergeConflictError";class ut extends j{constructor(t){super(`No name was provided for ${t} in the argument or in the .git/config file.`),this.code=this.name=ut.code,this.data={role:t}}}ut.code="MissingNameError";class pt extends j{constructor(t){super(`The function requires a "${t}" parameter but none was provided.`),this.code=this.name=pt.code,this.data={parameter:t}}}pt.code="MissingParameterError";class ye extends j{constructor(t){super('There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more'),this.code=this.name=ye.code,this.data={errors:t},this.errors=t}}ye.code="MultipleGitError";class Ft extends j{constructor(t,e){super(`Expected "${t}" but received "${e}".`),this.code=this.name=Ft.code,this.data={expected:t,actual:e}}}Ft.code="ParseError";class Jt extends j{constructor(t){let e="";t==="not-fast-forward"?e=" because it was not a simple fast-forward":t==="tag-exists"&&(e=" because tag already exists"),super(`Push rejected${e}. Use "force: true" to override.`),this.code=this.name=Jt.code,this.data={reason:t}}}Jt.code="PushRejectedError";class Tt extends j{constructor(t,e){super(`Remote does not support the "${t}" so the "${e}" parameter cannot be used.`),this.code=this.name=Tt.code,this.data={capability:t,parameter:e}}}Tt.code="RemoteCapabilityError";class ge extends j{constructor(t,e){super(`Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${t}`),this.code=this.name=ge.code,this.data={preview:t,response:e}}}ge.code="SmartHttpError";class be extends j{constructor(t,e,i){super(`Git remote "${t}" uses an unrecognized transport protocol: "${e}"`),this.code=this.name=be.code,this.data={url:t,transport:e,suggestion:i}}}be.code="UnknownTransportError";class _e extends j{constructor(t){super(`Cannot parse remote URL: "${t}"`),this.code=this.name=_e.code,this.data={url:t}}}_e.code="UrlParseError";class Kt extends j{constructor(){super("The operation was canceled."),this.code=this.name=Kt.code,this.data={}}}Kt.code="UserCanceledError";class ke extends j{constructor(t){super(`Could not merge index: Entry for '${t}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged changes.`),this.code=this.name=ke.code,this.data={filepath:t}}}ke.code="IndexResetError";class ve extends j{constructor(t){super(`"${t}" does not point to any commit. You're maybe working on a repository with no commits yet. `),this.code=this.name=ve.code,this.data={ref:t}}}ve.code="NoCommitError";var Qi=Object.freeze({__proto__:null,AlreadyExistsError:vt,AmbiguousError:fe,CheckoutConflictError:ue,CommitNotFetchedError:he,EmptyServerResponseError:de,FastForwardError:we,GitPushError:me,HttpError:Yt,InternalError:M,InvalidFilepathError:Pt,InvalidOidError:Bt,InvalidRefNameError:St,MaxDepthError:pe,MergeNotSupportedError:Zt,MergeConflictError:Qt,MissingNameError:ut,MissingParameterError:pt,MultipleGitError:ye,NoRefspecError:ce,NotFoundError:Q,ObjectTypeError:dt,ParseError:Ft,PushRejectedError:Jt,RemoteCapabilityError:Tt,SmartHttpError:ge,UnknownTransportError:be,UnsafeFilepathError:R,UrlParseError:_e,UserCanceledError:Kt,UnmergedPathsError:L,IndexResetError:ke,NoCommitError:ve});function ni({name:n,email:t,timestamp:e,timezoneOffset:i}){return i=Ys(i),`${n} <${t}> ${e} ${i}`}function Ys(n){const t=Zs(Qs(n));n=Math.abs(n);const e=Math.floor(n/60);n-=e*60;let i=String(e),r=String(n);return i.length<2&&(i="0"+i),r.length<2&&(r="0"+r),(t===-1?"-":"+")+i+r}function Zs(n){return Math.sign(n)||(Object.is(n,-0)?-1:1)}function Qs(n){return n===0?n:-n}function Rt(n){return n=n.replace(/\r/g,""),n=n.replace(/^\n+/,""),n=n.replace(/\n+$/,"")+`
`,n}function Me(n){const[,t,e,i,r]=n.match(/^(.*) <(.*)> (.*) (.*)$/);return{name:t,email:e,timestamp:Number(i),timezoneOffset:Js(r)}}function Js(n){let[,t,e,i]=n.match(/(\+|-)(\d\d)(\d\d)/);return i=(t==="+"?1:-1)*(Number(e)*60+Number(i)),Ks(i)}function Ks(n){return n===0?n:-n}class wt{constructor(t){if(typeof t=="string")this._tag=t;else if(Buffer.isBuffer(t))this._tag=t.toString("utf8");else if(typeof t=="object")this._tag=wt.render(t);else throw new M("invalid type passed to GitAnnotatedTag constructor")}static from(t){return new wt(t)}static render(t){return`object ${t.object}
type ${t.type}
tag ${t.tag}
tagger ${ni(t.tagger)}

${t.message}
${t.gpgsig?t.gpgsig:""}`}justHeaders(){return this._tag.slice(0,this._tag.indexOf(`

`))}message(){const t=this.withoutSignature();return t.slice(t.indexOf(`

`)+2)}parse(){return Object.assign(this.headers(),{message:this.message(),gpgsig:this.gpgsig()})}render(){return this._tag}headers(){const t=this.justHeaders().split(`
`),e=[];for(const r of t)r[0]===" "?e[e.length-1]+=`
`+r.slice(1):e.push(r);const i={};for(const r of e){const s=r.slice(0,r.indexOf(" ")),a=r.slice(r.indexOf(" ")+1);Array.isArray(i[s])?i[s].push(a):i[s]=a}return i.tagger&&(i.tagger=Me(i.tagger)),i.committer&&(i.committer=Me(i.committer)),i}withoutSignature(){const t=Rt(this._tag);return t.indexOf(`
-----BEGIN PGP SIGNATURE-----`)===-1?t:t.slice(0,t.lastIndexOf(`
-----BEGIN PGP SIGNATURE-----`))}gpgsig(){if(this._tag.indexOf(`
-----BEGIN PGP SIGNATURE-----`)===-1)return;const t=this._tag.slice(this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),this._tag.indexOf("-----END PGP SIGNATURE-----")+27);return Rt(t)}payload(){return this.withoutSignature()+`
`}toObject(){return Buffer.from(this._tag,"utf8")}static async sign(t,e,i){const r=t.payload();let{signature:s}=await e({payload:r,secretKey:i});s=Rt(s);const a=r+s;return wt.from(a)}}function ri(n){return n.trim().split(`
`).map(t=>" "+t).join(`
`)+`
`}function ta(n){return n.split(`
`).map(t=>t.replace(/^ /,"")).join(`
`)}class et{constructor(t){if(typeof t=="string")this._commit=t;else if(Buffer.isBuffer(t))this._commit=t.toString("utf8");else if(typeof t=="object")this._commit=et.render(t);else throw new M("invalid type passed to GitCommit constructor")}static fromPayloadSignature({payload:t,signature:e}){const i=et.justHeaders(t),r=et.justMessage(t),s=Rt(i+`
gpgsig`+ri(e)+`
`+r);return new et(s)}static from(t){return new et(t)}toObject(){return Buffer.from(this._commit,"utf8")}headers(){return this.parseHeaders()}message(){return et.justMessage(this._commit)}parse(){return Object.assign({message:this.message()},this.headers())}static justMessage(t){return Rt(t.slice(t.indexOf(`

`)+2))}static justHeaders(t){return t.slice(0,t.indexOf(`

`))}parseHeaders(){const t=et.justHeaders(this._commit).split(`
`),e=[];for(const r of t)r[0]===" "?e[e.length-1]+=`
`+r.slice(1):e.push(r);const i={parent:[]};for(const r of e){const s=r.slice(0,r.indexOf(" ")),a=r.slice(r.indexOf(" ")+1);Array.isArray(i[s])?i[s].push(a):i[s]=a}return i.author&&(i.author=Me(i.author)),i.committer&&(i.committer=Me(i.committer)),i}static renderHeaders(t){let e="";if(t.tree?e+=`tree ${t.tree}
`:e+=`tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`,t.parent){if(t.parent.length===void 0)throw new M("commit 'parent' property should be an array");for(const s of t.parent)e+=`parent ${s}
`}const i=t.author;e+=`author ${ni(i)}
`;const r=t.committer||t.author;return e+=`committer ${ni(r)}
`,t.gpgsig&&(e+="gpgsig"+ri(t.gpgsig)),e}static render(t){return et.renderHeaders(t)+`
`+Rt(t.message)}render(){return this._commit}withoutSignature(){const t=Rt(this._commit);if(t.indexOf(`
gpgsig`)===-1)return t;const e=t.slice(0,t.indexOf(`
gpgsig`)),i=t.slice(t.indexOf(`-----END PGP SIGNATURE-----
`)+28);return Rt(e+`
`+i)}isolateSignature(){const t=this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),this._commit.indexOf("-----END PGP SIGNATURE-----")+27);return ta(t)}static async sign(t,e,i){const r=t.withoutSignature(),s=et.justMessage(t._commit);let{signature:a}=await e({payload:r,secretKey:i});a=Rt(a);const f=et.justHeaders(t._commit)+`
gpgsig`+ri(a)+`
`+s;return et.from(f)}}async function te({fs:n,cache:t,gitdir:e,oid:i}){if(i==="4b825dc642cb6eb9a060e54bf8d69288fbee4904")return{tree:mt.from([]),oid:i};const{type:r,object:s}=await tt({fs:n,cache:t,gitdir:e,oid:i});if(r==="tag")return i=wt.from(s).parse().object,te({fs:n,cache:t,gitdir:e,oid:i});if(r==="commit")return i=et.from(s).parse().tree,te({fs:n,cache:t,gitdir:e,oid:i});if(r!=="tree")throw new dt(i,r,"tree");return{tree:mt.from(s),oid:i}}class ea{constructor({fs:t,gitdir:e,ref:i,cache:r}){this.fs=t,this.cache=r,this.gitdir=e,this.mapPromise=(async()=>{const a=new Map;let o;try{o=await S.resolve({fs:t,gitdir:e,ref:i})}catch(l){l instanceof Q&&(o="4b825dc642cb6eb9a060e54bf8d69288fbee4904")}const f=await te({fs:t,cache:this.cache,gitdir:e,oid:o});return f.type="tree",f.mode="40000",a.set(".",f),a})();const s=this;this.ConstructEntry=class{constructor(o){this._fullpath=o,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return s.type(this)}async mode(){return s.mode(this)}async stat(){return s.stat(this)}async content(){return s.content(this)}async oid(){return s.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:i,cache:r,gitdir:s}=this,a=await this.mapPromise,o=a.get(e);if(!o)throw new Error(`No obj for ${e}`);const f=o.oid;if(!f)throw new Error(`No oid for obj ${JSON.stringify(o)}`);if(o.type!=="tree")return null;const{type:l,object:c}=await tt({fs:i,cache:r,gitdir:s,oid:f});if(l!==o.type)throw new dt(f,l,o.type);const h=mt.from(c);for(const u of h)a.set(m.join(e,u.path),u);return h.entries().map(u=>m.join(e,u.path))}async type(t){if(t._type===!1){const e=await this.mapPromise,{type:i}=e.get(t._fullpath);t._type=i}return t._type}async mode(t){if(t._mode===!1){const e=await this.mapPromise,{mode:i}=e.get(t._fullpath);t._mode=K(parseInt(i,8))}return t._mode}async stat(t){}async content(t){if(t._content===!1){const e=await this.mapPromise,{fs:i,cache:r,gitdir:s}=this,o=e.get(t._fullpath).oid,{type:f,object:l}=await tt({fs:i,cache:r,gitdir:s,oid:o});f!=="blob"?t._content=void 0:t._content=new Uint8Array(l)}return t._content}async oid(t){if(t._oid===!1){const i=(await this.mapPromise).get(t._fullpath);t._oid=i.oid}return t._oid}}function bt({ref:n="HEAD"}={}){const t=Object.create(null);return Object.defineProperty(t,Te,{value:function({fs:e,gitdir:i,cache:r}){return new ea({fs:e,gitdir:i,ref:n,cache:r})}}),Object.freeze(t),t}class ia{constructor({fs:t,dir:e,gitdir:i,cache:r}){this.fs=t,this.cache=r,this.dir=e,this.gitdir=i,this.config=null;const s=this;this.ConstructEntry=class{constructor(o){this._fullpath=o,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return s.type(this)}async mode(){return s.mode(this)}async stat(){return s.stat(this)}async content(){return s.content(this)}async oid(){return s.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:i,dir:r}=this,s=await i.readdir(m.join(r,e));return s===null?null:s.map(a=>m.join(e,a))}async type(t){return t._type===!1&&await t.stat(),t._type}async mode(t){return t._mode===!1&&await t.stat(),t._mode}async stat(t){if(t._stat===!1){const{fs:e,dir:i}=this;let r=await e.lstat(`${i}/${t._fullpath}`);if(!r)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);let s=r.isDirectory()?"tree":"blob";s==="blob"&&!r.isFile()&&!r.isSymbolicLink()&&(s="special"),t._type=s,r=Et(r),t._mode=r.mode,r.size===-1&&t._actualSize&&(r.size=t._actualSize),t._stat=r}return t._stat}async content(t){if(t._content===!1){const{fs:e,dir:i,gitdir:r}=this;if(await t.type()==="tree")t._content=void 0;else{const a=await(await this._getGitConfig(e,r)).get("core.autocrlf"),o=await e.read(`${i}/${t._fullpath}`,{autocrlf:a});t._actualSize=o.length,t._stat&&t._stat.size===-1&&(t._stat.size=t._actualSize),t._content=new Uint8Array(o)}}return t._content}async oid(t){if(t._oid===!1){const e=this,{fs:i,gitdir:r,cache:s}=this;let a;await st.acquire({fs:i,gitdir:r,cache:s},async function(o){const f=o.entriesMap.get(t._fullpath),l=await t.stat(),h=await(await e._getGitConfig(i,r)).get("core.filemode"),u=typeof process<"u"?process.platform!=="win32":!0;if(!f||Ie(l,f,h,u)){const d=await t.content();d===void 0?a=void 0:(a=await jt(Vt.wrap({type:"blob",object:d})),f&&a===f.oid&&(!h||l.mode===f.mode)&&Ie(l,f,h,u)&&o.insert({filepath:t._fullpath,stats:l,oid:a}))}else a=f.oid}),t._oid=a}return t._oid}async _getGitConfig(t,e){return this.config?this.config:(this.config=await rt.get({fs:t,gitdir:e}),this.config)}}function ee(){const n=Object.create(null);return Object.defineProperty(n,Te,{value:function({fs:t,dir:e,gitdir:i,cache:r}){return new ia({fs:t,dir:e,gitdir:i,cache:r})}}),Object.freeze(n),n}function na(n,t){const e=t-n;return Array.from({length:e},(i,r)=>n+r)}const Ji=typeof Array.prototype.flat>"u"?n=>n.reduce((t,e)=>t.concat(e),[]):n=>n.flat();class ra{constructor(){this.value=null}consider(t){t!=null&&(this.value===null?this.value=t:t<this.value&&(this.value=t))}reset(){this.value=null}}function*sa(n){const t=new ra;let e;const i=[],r=n.length;for(let s=0;s<r;s++)i[s]=n[s].next().value,i[s]!==void 0&&t.consider(i[s]);if(t.value!==null)for(;;){const s=[];e=t.value,t.reset();for(let a=0;a<r;a++)i[a]!==void 0&&i[a]===e?(s[a]=i[a],i[a]=n[a].next().value):s[a]=null,i[a]!==void 0&&t.consider(i[a]);if(yield s,t.value===null)return}}async function Ct({fs:n,cache:t,dir:e,gitdir:i,trees:r,map:s=async(f,l)=>l,reduce:a=async(f,l)=>{const c=Ji(l);return f!==void 0&&c.unshift(f),c},iterate:o=(f,l)=>Promise.all([...l].map(f))}){const f=r.map(d=>d[Te]({fs:n,dir:e,gitdir:i,cache:t})),l=new Array(f.length).fill("."),c=na(0,f.length),h=async d=>{c.map(_=>{const k=d[_];d[_]=k&&new f[_].ConstructEntry(k)});const b=(await Promise.all(c.map(_=>{const k=d[_];return k?f[_].readdir(k):[]}))).map(_=>(_===null?[]:_)[Symbol.iterator]());return{entries:d,children:sa(b)}},u=async d=>{const{entries:y,children:b}=await h(d),_=y.find(v=>v&&v._fullpath)._fullpath,k=await s(_,y);if(k!==null){let v=await o(u,b);return v=v.filter(O=>O!==void 0),a(k,v)}};return u(l)}async function si(n,t){const e=await n.readdir(t);e==null?await n.rm(t):e.length?await Promise.all(e.map(i=>{const r=m.join(t,i);return n.lstat(r).then(s=>{if(s)return s.isDirectory()?si(n,r):n.rm(r)})})).then(()=>n.rmdir(t)):await n.rmdir(t)}function aa(n){return oa(n)&&Ki(n.then)&&Ki(n.catch)}function oa(n){return n&&typeof n=="object"}function Ki(n){return typeof n=="function"}function tn(n){return aa((e=>{try{return e.readFile().catch(i=>i)}catch(i){return i}})(n))}const en=["readFile","writeFile","mkdir","rmdir","unlink","stat","lstat","readdir","readlink","symlink"];function nn(n,t){if(tn(t))for(const e of en)n[`_${e}`]=t[e].bind(t);else for(const e of en)n[`_${e}`]=x(t[e].bind(t));tn(t)?t.rm?n._rm=t.rm.bind(t):t.rmdir.length>1?n._rm=t.rmdir.bind(t):n._rm=si.bind(null,n):t.rm?n._rm=x(t.rm.bind(t)):t.rmdir.length>2?n._rm=x(t.rmdir.bind(t)):n._rm=si.bind(null,n)}class z{constructor(t){if(typeof t._original_unwrapped_fs<"u")return t;const e=Object.getOwnPropertyDescriptor(t,"promises");e&&e.enumerable?nn(this,t.promises):nn(this,t),this._original_unwrapped_fs=t}async exists(t,e={}){try{return await this._stat(t),!0}catch(i){if(i.code==="ENOENT"||i.code==="ENOTDIR"||(i.code||"").includes("ENS"))return!1;throw console.log('Unhandled error in "FileSystem.exists()" function',i),i}}async read(t,e={}){try{let i=await this._readFile(t,e);if(e.autocrlf==="true")try{i=new TextDecoder("utf8",{fatal:!0}).decode(i),i=i.replace(/\r\n/g,`
`),i=new TextEncoder().encode(i)}catch{}return typeof i!="string"&&(i=Buffer.from(i)),i}catch{return null}}async write(t,e,i={}){try{await this._writeFile(t,e,i);return}catch{await this.mkdir(Gt(t)),await this._writeFile(t,e,i)}}async mkdir(t,e=!1){try{await this._mkdir(t);return}catch(i){if(i===null||i.code==="EEXIST")return;if(e)throw i;if(i.code==="ENOENT"){const r=Gt(t);if(r==="."||r==="/"||r===t)throw i;await this.mkdir(r),await this.mkdir(t,!0)}}}async rm(t){try{await this._unlink(t)}catch(e){if(e.code!=="ENOENT")throw e}}async rmdir(t,e){try{e&&e.recursive?await this._rm(t,e):await this._rmdir(t)}catch(i){if(i.code!=="ENOENT")throw i}}async readdir(t){try{const e=await this._readdir(t);return e.sort(G),e}catch(e){return e.code==="ENOTDIR"?null:[]}}async readdirDeep(t){const e=await this._readdir(t);return(await Promise.all(e.map(async r=>{const s=t+"/"+r;return(await this._stat(s)).isDirectory()?this.readdirDeep(s):s}))).reduce((r,s)=>r.concat(s),[])}async lstat(t){try{return await this._lstat(t)}catch(e){if(e.code==="ENOENT"||(e.code||"").includes("ENS"))return null;throw e}}async readlink(t,e={encoding:"buffer"}){try{const i=await this._readlink(t,e);return Buffer.isBuffer(i)?i:Buffer.from(i)}catch(i){if(i.code==="ENOENT"||(i.code||"").includes("ENS"))return null;throw i}}async writelink(t,e){return this._symlink(e.toString("utf8"),t)}}function w(n,t){if(t===void 0)throw new pt(n)}async function Fe(n,t){return!n&&!t?!1:n&&!t||!n&&t?!0:!(await n.type()==="tree"&&await t.type()==="tree"||await n.type()===await t.type()&&await n.mode()===await t.mode()&&await n.oid()===await t.oid())}async function rn({fs:n,dir:t,gitdir:e=m.join(t,".git"),commit:i="HEAD",cache:r={}}){try{w("fs",n),w("dir",t),w("gitdir",e);const s=new z(n),a=[bt({ref:i}),ee(),Mt()];let o=[];await st.acquire({fs:s,gitdir:e,cache:r},async function(l){o=l.unmergedPaths});const f=await Ct({fs:s,cache:r,dir:t,gitdir:e,trees:a,map:async function(l,[c,h,u]){const d=!await Fe(h,u),y=o.includes(l),b=!await Fe(u,c);if(d||y)return c?{path:l,mode:await c.mode(),oid:await c.oid(),type:await c.type(),content:await c.content()}:void 0;if(b)return!1;throw new ke(l)}});await st.acquire({fs:s,gitdir:e,cache:r},async function(l){for(const c of f)if(c!==!1){if(!c){await s.rmdir(`${t}/${c.path}`,{recursive:!0}),l.delete({filepath:c.path});continue}if(c.type==="blob"){const h=new TextDecoder().decode(c.content);await s.write(`${t}/${c.path}`,h,{mode:c.mode}),l.insert({filepath:c.path,oid:c.oid,stage:0})}}})}catch(s){throw s.caller="git.abortMerge",s}}class ie{static async isIgnored({fs:t,dir:e,gitdir:i=m.join(e,".git"),filepath:r}){if(Pe(r)===".git")return!0;if(r===".")return!1;let s="";const a=m.join(i,"info","exclude");await t.exists(a)&&(s=await t.read(a,"utf8"));const o=[{gitignore:m.join(e,".gitignore"),filepath:r}],f=r.split("/").filter(Boolean);for(let c=1;c<f.length;c++){const h=f.slice(0,c).join("/"),u=f.slice(c).join("/");o.push({gitignore:m.join(e,h,".gitignore"),filepath:u})}let l=!1;for(const c of o){let h;try{h=await t.read(c.gitignore,"utf8")}catch(y){if(y.code==="NOENT")continue}const u=g().add(s);u.add(h);const d=Gt(c.filepath);if(d!=="."&&u.ignores(d))return!0;l?l=!u.test(c.filepath).unignored:l=u.test(c.filepath).ignored}return l}}async function ca({fs:n,gitdir:t,object:e,format:i,oid:r}){const s=`objects/${r.slice(0,2)}/${r.slice(2)}`,a=`${t}/${s}`;await n.exists(a)||await n.write(a,e)}let ai=null;async function sn(n){return ai===null&&(ai=fa()),ai?la(n):D.deflate(n)}async function la(n){const t=new CompressionStream("deflate"),e=new Blob([n]).stream().pipeThrough(t);return new Uint8Array(await new Response(e).arrayBuffer())}function fa(){try{return new CompressionStream("deflate").writable.close(),new Blob([]).stream().cancel(),!0}catch{return!1}}async function yt({fs:n,gitdir:t,type:e,object:i,format:r="content",oid:s=void 0,dryRun:a=!1}){return r!=="deflated"&&(r!=="wrapped"&&(i=Vt.wrap({type:e,object:i})),s=await jt(i),i=Buffer.from(await sn(i))),a||await ca({fs:n,gitdir:t,object:i,format:"deflated",oid:s}),s}function an(n){let t;for(;~(t=n.indexOf(92));)n[t]=47;return n}async function on({fs:n,dir:t,gitdir:e=m.join(t,".git"),filepath:i,cache:r={},force:s=!1,parallel:a=!0}){try{w("fs",n),w("dir",t),w("gitdir",e),w("filepath",i);const o=new z(n);await st.acquire({fs:o,gitdir:e,cache:r},async f=>{const c=await(await rt.get({fs:o,gitdir:e})).get("core.autocrlf");return oi({dir:t,gitdir:e,fs:o,filepath:i,index:f,force:s,parallel:a,autocrlf:c})})}catch(o){throw o.caller="git.add",o}}async function oi({dir:n,gitdir:t,fs:e,filepath:i,index:r,force:s,parallel:a,autocrlf:o}){i=Array.isArray(i)?i:[i];const f=i.map(async u=>{if(!s&&await ie.isIgnored({fs:e,dir:n,gitdir:t,filepath:u}))return;const d=await e.lstat(m.join(n,u));if(!d)throw new Q(u);if(d.isDirectory()){const y=await e.readdir(m.join(n,u));if(a){const b=y.map(_=>oi({dir:n,gitdir:t,fs:e,filepath:[m.join(u,_)],index:r,force:s,parallel:a,autocrlf:o}));await Promise.all(b)}else for(const b of y)await oi({dir:n,gitdir:t,fs:e,filepath:[m.join(u,b)],index:r,force:s,parallel:a,autocrlf:o})}else{const y=d.isSymbolicLink()?await e.readlink(m.join(n,u)).then(an):await e.read(m.join(n,u),{autocrlf:o});if(y===null)throw new Q(u);const b=await yt({fs:e,gitdir:t,type:"blob",object:y});r.insert({filepath:u,stats:d,oid:b})}}),l=await Promise.allSettled(f),c=l.filter(u=>u.status==="rejected").map(u=>u.reason);if(c.length>1)throw new ye(c);if(c.length===1)throw c[0];return l.filter(u=>u.status==="fulfilled"&&u.value).map(u=>u.value)}async function Se({fs:n,gitdir:t,path:e}){return(await rt.get({fs:n,gitdir:t})).get(e)}function cn(n,...t){for(const e of t)if(e)for(const i of Object.keys(e)){const r=e[i];r!==void 0&&(n[i]=r)}return n}async function At({fs:n,gitdir:t,author:e,commit:i}){const r=Math.floor(Date.now()/1e3),s={name:await Se({fs:n,gitdir:t,path:"user.name"}),email:await Se({fs:n,gitdir:t,path:"user.email"})||"",timestamp:r,timezoneOffset:new Date(r*1e3).getTimezoneOffset()},a=cn({},s,i?i.author:void 0,e);if(a.name!==void 0)return a}async function ne({fs:n,gitdir:t,author:e,committer:i,commit:r}){const s=Math.floor(Date.now()/1e3),a={name:await Se({fs:n,gitdir:t,path:"user.name"}),email:await Se({fs:n,gitdir:t,path:"user.email"})||"",timestamp:s,timezoneOffset:new Date(s*1e3).getTimezoneOffset()},o=cn({},a,r?r.committer:void 0,e,i);if(o.name!==void 0)return o}async function ln({fs:n,cache:t,gitdir:e,oid:i}){const{type:r,object:s}=await tt({fs:n,cache:t,gitdir:e,oid:i});if(r==="tag")return i=wt.from(s).parse().object,ln({fs:n,cache:t,gitdir:e,oid:i});if(r!=="commit")throw new dt(i,r,"commit");return{commit:et.from(s),oid:i}}async function re({fs:n,cache:t,gitdir:e,oid:i}){const{commit:r,oid:s}=await ln({fs:n,cache:t,gitdir:e,oid:i});return{oid:s,commit:r.parse(),payload:r.withoutSignature()}}async function Ue({fs:n,cache:t,onSign:e,gitdir:i,message:r,author:s,committer:a,signingKey:o,amend:f=!1,dryRun:l=!1,noUpdateBranch:c=!1,ref:h,parent:u,tree:d}){let y=!1;h||(h=await S.resolve({fs:n,gitdir:i,ref:"HEAD",depth:2}));let b,_;try{b=await S.resolve({fs:n,gitdir:i,ref:h}),_=await re({fs:n,gitdir:i,oid:b,cache:{}})}catch{y=!0}if(f&&y)throw new ve(h);const k=f?await At({fs:n,gitdir:i,author:s,commit:_.commit}):await At({fs:n,gitdir:i,author:s});if(!k)throw new ut("author");const v=f?await ne({fs:n,gitdir:i,author:k,committer:a,commit:_.commit}):await ne({fs:n,gitdir:i,author:k,committer:a});if(!v)throw new ut("committer");return st.acquire({fs:n,gitdir:i,cache:t,allowUnmerged:!1},async function(O){const q=Ni(O.entries).get(".");if(d||(d=await fn({fs:n,gitdir:i,inode:q,dryRun:l})),u?u=await Promise.all(u.map(E=>S.resolve({fs:n,gitdir:i,ref:E}))):f?u=_.commit.parent:u=b?[b]:[],!r)if(f)r=_.commit.message;else throw new pt("message");let N=et.from({tree:d,parent:u,author:k,committer:v,message:r});o&&(N=await et.sign(N,e,o));const $=await yt({fs:n,gitdir:i,type:"commit",object:N.toObject(),dryRun:l});return!c&&!l&&await S.writeRef({fs:n,gitdir:i,ref:h,value:$}),$})}async function fn({fs:n,gitdir:t,inode:e,dryRun:i}){const r=e.children;for(const f of r)f.type==="tree"&&(f.metadata.mode="040000",f.metadata.oid=await fn({fs:n,gitdir:t,inode:f,dryRun:i}));const s=r.map(f=>({mode:f.metadata.mode,path:f.basename,oid:f.metadata.oid,type:f.type})),a=mt.from(s);return await yt({fs:n,gitdir:t,type:"tree",object:a.toObject(),dryRun:i})}async function $e({fs:n,cache:t,gitdir:e,oid:i,filepath:r}){if(r.startsWith("/"))throw new Pt("leading-slash");if(r.endsWith("/"))throw new Pt("trailing-slash");const s=i,a=await te({fs:n,cache:t,gitdir:e,oid:i}),o=a.tree;if(r==="")i=a.oid;else{const f=r.split("/");i=await un({fs:n,cache:t,gitdir:e,tree:o,pathArray:f,oid:s,filepath:r})}return i}async function un({fs:n,cache:t,gitdir:e,tree:i,pathArray:r,oid:s,filepath:a}){const o=r.shift();for(const f of i)if(f.path===o){if(r.length===0)return f.oid;{const{type:l,object:c}=await tt({fs:n,cache:t,gitdir:e,oid:f.oid});if(l!=="tree")throw new dt(s,l,"tree",a);return i=mt.from(c),un({fs:n,cache:t,gitdir:e,tree:i,pathArray:r,oid:s,filepath:a})}}throw new Q(`file or directory found at "${s}:${a}"`)}async function se({fs:n,cache:t,gitdir:e,oid:i,filepath:r=void 0}){r!==void 0&&(i=await $e({fs:n,cache:t,gitdir:e,oid:i,filepath:r}));const{tree:s,oid:a}=await te({fs:n,cache:t,gitdir:e,oid:i});return{oid:a,tree:s.entries()}}async function xe({fs:n,gitdir:t,tree:e}){const i=mt.from(e).toObject();return await yt({fs:n,gitdir:t,type:"tree",object:i,format:"content"})}async function ua({fs:n,cache:t,onSign:e,gitdir:i,ref:r,oid:s,note:a,force:o,author:f,committer:l,signingKey:c}){let h;try{h=await S.resolve({gitdir:i,fs:n,ref:r})}catch(k){if(!(k instanceof Q))throw k}let d=(await se({fs:n,cache:t,gitdir:i,oid:h||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;if(o)d=d.filter(k=>k.path!==s);else for(const k of d)if(k.path===s)throw new vt("note",s);typeof a=="string"&&(a=Buffer.from(a,"utf8"));const y=await yt({fs:n,gitdir:i,type:"blob",object:a,format:"content"});d.push({mode:"100644",path:s,oid:y,type:"blob"});const b=await xe({fs:n,gitdir:i,tree:d});return await Ue({fs:n,cache:t,onSign:e,gitdir:i,ref:r,tree:b,parent:h&&[h],message:`Note added by 'isomorphic-git addNote'
`,author:f,committer:l,signingKey:c})}async function hn({fs:n,onSign:t,dir:e,gitdir:i=m.join(e,".git"),ref:r="refs/notes/commits",oid:s,note:a,force:o,author:f,committer:l,signingKey:c,cache:h={}}){try{w("fs",n),w("gitdir",i),w("oid",s),w("note",a),c&&w("onSign",t);const u=new z(n),d=await At({fs:u,gitdir:i,author:f});if(!d)throw new ut("author");const y=await ne({fs:u,gitdir:i,author:d,committer:l});if(!y)throw new ut("committer");return await ua({fs:new z(u),cache:h,onSign:t,gitdir:i,ref:r,oid:s,note:a,force:o,author:d,committer:y,signingKey:c})}catch(u){throw u.caller="git.addNote",u}}async function dn({fs:n,gitdir:t,remote:e,url:i,force:r}){if(e!==p.clean(e))throw new St(e,p.clean(e));const s=await rt.get({fs:n,gitdir:t});if(!r&&(await s.getSubsections("remote")).includes(e)&&i!==await s.get(`remote.${e}.url`))throw new vt("remote",e);await s.set(`remote.${e}.url`,i),await s.set(`remote.${e}.fetch`,`+refs/heads/*:refs/remotes/${e}/*`),await rt.save({fs:n,gitdir:t,config:s})}async function wn({fs:n,dir:t,gitdir:e=m.join(t,".git"),remote:i,url:r,force:s=!1}){try{return w("fs",n),w("gitdir",e),w("remote",i),w("url",r),await dn({fs:new z(n),gitdir:e,remote:i,url:r,force:s})}catch(a){throw a.caller="git.addRemote",a}}async function ha({fs:n,cache:t,onSign:e,gitdir:i,ref:r,tagger:s,message:a=r,gpgsig:o,object:f,signingKey:l,force:c=!1}){if(r=r.startsWith("refs/tags/")?r:`refs/tags/${r}`,!c&&await S.exists({fs:n,gitdir:i,ref:r}))throw new vt("tag",r);const h=await S.resolve({fs:n,gitdir:i,ref:f||"HEAD"}),{type:u}=await tt({fs:n,cache:t,gitdir:i,oid:h});let d=wt.from({object:h,type:u,tag:r.replace("refs/tags/",""),tagger:s,message:a,gpgsig:o});l&&(d=await wt.sign(d,e,l));const y=await yt({fs:n,gitdir:i,type:"tag",object:d.toObject()});await S.writeRef({fs:n,gitdir:i,ref:r,value:y})}async function mn({fs:n,onSign:t,dir:e,gitdir:i=m.join(e,".git"),ref:r,tagger:s,message:a=r,gpgsig:o,object:f,signingKey:l,force:c=!1,cache:h={}}){try{w("fs",n),w("gitdir",i),w("ref",r),l&&w("onSign",t);const u=new z(n),d=await At({fs:u,gitdir:i,author:s});if(!d)throw new ut("tagger");return await ha({fs:u,cache:h,onSign:t,gitdir:i,ref:r,tagger:d,message:a,gpgsig:o,object:f,signingKey:l,force:c})}catch(u){throw u.caller="git.annotatedTag",u}}async function da({fs:n,gitdir:t,ref:e,object:i,checkout:r=!1,force:s=!1}){if(e!==p.clean(e))throw new St(e,p.clean(e));const a=`refs/heads/${e}`;if(!s&&await S.exists({fs:n,gitdir:t,ref:a}))throw new vt("branch",e,!1);let o;try{o=await S.resolve({fs:n,gitdir:t,ref:i||"HEAD"})}catch{}o&&await S.writeRef({fs:n,gitdir:t,ref:a,value:o}),r&&await S.writeSymbolicRef({fs:n,gitdir:t,ref:"HEAD",value:a})}async function pn({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i,object:r,checkout:s=!1,force:a=!1}){try{return w("fs",n),w("gitdir",e),w("ref",i),await da({fs:new z(n),gitdir:e,ref:i,object:r,checkout:s,force:a})}catch(o){throw o.caller="git.branch",o}}const yn=(n,t)=>n==="."||t==null||t.length===0||t==="."?!0:t.length>=n.length?t.startsWith(n):n.startsWith(t);async function ci({fs:n,cache:t,onProgress:e,onPostCheckout:i,dir:r,gitdir:s,remote:a,ref:o,filepaths:f,noCheckout:l,noUpdateHead:c,dryRun:h,force:u,track:d=!0,nonBlocking:y=!1,batchSize:b=100}){let _;if(i)try{_=await S.resolve({fs:n,gitdir:s,ref:"HEAD"})}catch{_="0000000000000000000000000000000000000000"}let k;try{k=await S.resolve({fs:n,gitdir:s,ref:o})}catch(v){if(o==="HEAD")throw v;const O=`${a}/${o}`;if(k=await S.resolve({fs:n,gitdir:s,ref:O}),d){const F=await rt.get({fs:n,gitdir:s});await F.set(`branch.${o}.remote`,a),await F.set(`branch.${o}.merge`,`refs/heads/${o}`),await rt.save({fs:n,gitdir:s,config:F})}await S.writeRef({fs:n,gitdir:s,ref:`refs/heads/${o}`,value:k})}if(!l){let v;try{v=await wa({fs:n,cache:t,onProgress:e,dir:r,gitdir:s,ref:o,force:u,filepaths:f})}catch($){throw $ instanceof Q&&$.data.what===k?new he(o,k):$}const O=v.filter(([$])=>$==="conflict").map(([$,E])=>E);if(O.length>0)throw new ue(O);const F=v.filter(([$])=>$==="error").map(([$,E])=>E);if(F.length>0)throw new M(F.join(", "));if(h){i&&await i({previousHead:_,newHead:k,type:f!=null&&f.length>0?"file":"branch"});return}let q=0;const N=v.length;if(await st.acquire({fs:n,gitdir:s,cache:t},async function($){await Promise.all(v.filter(([E])=>E==="delete"||E==="delete-index").map(async function([E,C]){const W=`${r}/${C}`;E==="delete"&&await n.rm(W),$.delete({filepath:C}),e&&await e({phase:"Updating workdir",loaded:++q,total:N})}))}),await st.acquire({fs:n,gitdir:s,cache:t},async function($){for(const[E,C]of v)if(E==="rmdir"||E==="rmdir-index"){const W=`${r}/${C}`;try{E==="rmdir"&&await n.rmdir(W),$.delete({filepath:C}),e&&await e({phase:"Updating workdir",loaded:++q,total:N})}catch(X){if(X.code==="ENOTEMPTY")console.log(`Did not delete ${C} because directory is not empty`);else throw X}}}),await Promise.all(v.filter(([$])=>$==="mkdir"||$==="mkdir-index").map(async function([$,E]){const C=`${r}/${E}`;await n.mkdir(C),e&&await e({phase:"Updating workdir",loaded:++q,total:N})})),y){const $=v.filter(([C])=>C==="create"||C==="create-index"||C==="update"||C==="mkdir-index"),E=await gn("Update Working Dir",$.map(([C,W,X,at,Y])=>()=>pa({fs:n,cache:t,gitdir:s,dir:r},[C,W,X,at,Y])),e,b);await st.acquire({fs:n,gitdir:s,cache:t,allowUnmerged:!0},async function(C){await gn("Update Index",E.map(([W,X,at])=>()=>ma({index:C,fullpath:W,oid:X,stats:at})),e,b)})}else await st.acquire({fs:n,gitdir:s,cache:t,allowUnmerged:!0},async function($){await Promise.all(v.filter(([E])=>E==="create"||E==="create-index"||E==="update"||E==="mkdir-index").map(async function([E,C,W,X,at]){const Y=`${r}/${C}`;try{if(E!=="create-index"&&E!=="mkdir-index"){const{object:lt}=await tt({fs:n,cache:t,gitdir:s,oid:W});if(at&&await n.rm(Y),X===33188)await n.write(Y,lt);else if(X===33261)await n.write(Y,lt,{mode:511});else if(X===40960)await n.writelink(Y,lt);else throw new M(`Invalid mode 0o${X.toString(8)} detected in blob ${W}`)}const ot=await n.lstat(Y);X===33261&&(ot.mode=493),E==="mkdir-index"&&(ot.mode=57344),$.insert({filepath:C,stats:ot,oid:W}),e&&await e({phase:"Updating workdir",loaded:++q,total:N})}catch(ot){console.log(ot)}}))});i&&await i({previousHead:_,newHead:k,type:f!=null&&f.length>0?"file":"branch"})}if(!c){const v=await S.expand({fs:n,gitdir:s,ref:o});v.startsWith("refs/heads")?await S.writeSymbolicRef({fs:n,gitdir:s,ref:"HEAD",value:v}):await S.writeRef({fs:n,gitdir:s,ref:"HEAD",value:k})}}async function wa({fs:n,cache:t,onProgress:e,dir:i,gitdir:r,ref:s,force:a,filepaths:o}){let f=0;return Ct({fs:n,cache:t,dir:i,gitdir:r,trees:[bt({ref:s}),ee(),Mt()],map:async function(l,[c,h,u]){if(l===".")return;if(o&&!o.some(y=>yn(l,y)))return null;switch(e&&await e({phase:"Analyzing workdir",loaded:++f}),[!!u,!!c,!!h].map(Number).join("")){case"000":return;case"001":return a&&o&&o.includes(l)?["delete",l]:void 0;case"010":switch(await c.type()){case"tree":return["mkdir",l];case"blob":return["create",l,await c.oid(),await c.mode()];case"commit":return["mkdir-index",l,await c.oid(),await c.mode()];default:return["error",`new entry Unhandled type ${await c.type()}`]}case"011":switch(`${await c.type()}-${await h.type()}`){case"tree-tree":return;case"tree-blob":case"blob-tree":return["conflict",l];case"blob-blob":return await c.oid()!==await h.oid()?a?["update",l,await c.oid(),await c.mode(),await c.mode()!==await h.mode()]:["conflict",l]:await c.mode()!==await h.mode()?a?["update",l,await c.oid(),await c.mode(),!0]:["conflict",l]:["create-index",l,await c.oid(),await c.mode()];case"commit-tree":return;case"commit-blob":return["conflict",l];default:return["error",`new entry Unhandled type ${c.type}`]}case"100":return["delete-index",l];case"101":switch(await u.type()){case"tree":return["rmdir-index",l];case"blob":return await u.oid()!==await h.oid()?a?["delete",l]:["conflict",l]:["delete",l];case"commit":return["rmdir-index",l];default:return["error",`delete entry Unhandled type ${await u.type()}`]}case"110":case"111":switch(`${await u.type()}-${await c.type()}`){case"tree-tree":return;case"blob-blob":{if(await u.oid()===await c.oid()&&await u.mode()===await c.mode()&&!a)return;if(h){if(await h.oid()!==await u.oid()&&await h.oid()!==await c.oid())return a?["update",l,await c.oid(),await c.mode(),await c.mode()!==await h.mode()]:["conflict",l]}else if(a)return["update",l,await c.oid(),await c.mode(),await c.mode()!==await u.mode()];return await c.mode()!==await u.mode()?["update",l,await c.oid(),await c.mode(),!0]:await c.oid()!==await u.oid()?["update",l,await c.oid(),await c.mode(),!1]:void 0}case"tree-blob":return["update-dir-to-blob",l,await c.oid()];case"blob-tree":return["update-blob-to-tree",l];case"commit-commit":return["mkdir-index",l,await c.oid(),await c.mode()];default:return["error",`update entry Unhandled type ${await u.type()}-${await c.type()}`]}}},reduce:async function(l,c){return c=Ji(c),l?l&&l[0]==="rmdir"?(c.push(l),c):(c.unshift(l),c):c}})}async function ma({index:n,fullpath:t,stats:e,oid:i}){try{n.insert({filepath:t,stats:e,oid:i})}catch(r){console.warn(`Error inserting ${t} into index:`,r)}}async function pa({fs:n,cache:t,gitdir:e,dir:i},[r,s,a,o,f]){const l=`${i}/${s}`;if(r!=="create-index"&&r!=="mkdir-index"){const{object:h}=await tt({fs:n,cache:t,gitdir:e,oid:a});if(f&&await n.rm(l),o===33188)await n.write(l,h);else if(o===33261)await n.write(l,h,{mode:511});else if(o===40960)await n.writelink(l,h);else throw new M(`Invalid mode 0o${o.toString(8)} detected in blob ${a}`)}const c=await n.lstat(l);return o===33261&&(c.mode=493),r==="mkdir-index"&&(c.mode=57344),[s,a,c]}async function gn(n,t,e,i){const r=[];try{for(let s=0;s<t.length;s+=i){const a=t.slice(s,s+i).map(f=>f());(await Promise.allSettled(a)).forEach(f=>{f.status==="fulfilled"&&r.push(f.value)}),e&&await e({phase:"Updating workdir",loaded:s+a.length,total:t.length})}return r}catch(s){console.error(`Error during ${n}: ${s}`)}return r}async function li({fs:n,onProgress:t,onPostCheckout:e,dir:i,gitdir:r=m.join(i,".git"),remote:s="origin",ref:a,filepaths:o,noCheckout:f=!1,noUpdateHead:l=a===void 0,dryRun:c=!1,force:h=!1,track:u=!0,cache:d={},nonBlocking:y=!1,batchSize:b=100}){try{w("fs",n),w("dir",i),w("gitdir",r);const _=a||"HEAD";return await ci({fs:new z(n),cache:d,onProgress:t,onPostCheckout:e,dir:i,gitdir:r,remote:s,ref:_,filepaths:o,noCheckout:f,noUpdateHead:l,dryRun:c,force:h,track:u,nonBlocking:y,batchSize:b})}catch(_){throw _.caller="git.checkout",_}}const ya=new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");function Ut(n){const t=ya.exec(n);return t?t[1]==="remotes/"&&n.endsWith("/HEAD")?t[2].slice(0,-5):t[2]:n}async function Dt({fs:n,gitdir:t,fullname:e=!1,test:i=!1}){const r=await S.resolve({fs:n,gitdir:t,ref:"HEAD",depth:2});if(i)try{await S.resolve({fs:n,gitdir:t,ref:r})}catch{return}if(r.startsWith("refs/"))return e?r:Ut(r)}function ga(n){return n=n.replace(/^git@([^:]+):/,"https://$1/"),n=n.replace(/^ssh:\/\//,"https://"),n}function bn({username:n="",password:t=""}){return`Basic ${Buffer.from(`${n}:${t}`).toString("base64")}`}async function Ee(n,t){const e=Xi(n);for(;;){const{value:i,done:r}=await e.next();if(i&&await t(i),r)break}e.return&&e.return()}async function He(n){let t=0;const e=[];await Ee(n,s=>{e.push(s),t+=s.byteLength});const i=new Uint8Array(t);let r=0;for(const s of e)i.set(s,r),r+=s.byteLength;return i}function _n(n){let t=n.match(/^https?:\/\/([^/]+)@/);if(t==null)return{url:n,auth:{}};t=t[1];const[e,i]=t.split(":");return n=n.replace(`${t}@`,""),{url:n,auth:{username:e,password:i}}}function fi(n,t){const e=t.toString(16);return"0".repeat(n-e.length)+e}class nt{static flush(){return Buffer.from("0000","utf8")}static delim(){return Buffer.from("0001","utf8")}static encode(t){typeof t=="string"&&(t=Buffer.from(t));const e=t.length+4,i=fi(4,e);return Buffer.concat([Buffer.from(i,"utf8"),t])}static streamReader(t){const e=new Yi(t);return async function(){try{let r=await e.read(4);if(r==null)return!0;if(r=parseInt(r.toString("utf8"),16),r===0||r===1)return null;const s=await e.read(r-4);return s??!0}catch(r){return t.error=r,!0}}}}async function kn(n){const t={};let e;for(;e=await n(),e!==!0;){if(e===null)continue;e=e.toString("utf8").replace(/\n$/,"");const i=e.indexOf("=");if(i>-1){const r=e.slice(0,i),s=e.slice(i+1);t[r]=s}else t[e]=!0}return{protocolVersion:2,capabilities2:t}}async function vn(n,{service:t}){const e=new Set,i=new Map,r=new Map,s=nt.streamReader(n);let a=await s();for(;a===null;)a=await s();if(a===!0)throw new de;if(a.includes("version 2"))return kn(s);if(a.toString("utf8").replace(/\n$/,"")!==`# service=${t}`)throw new Ft(`# service=${t}\\n`,a.toString("utf8"));let o=await s();for(;o===null;)o=await s();if(o===!0)return{capabilities:e,refs:i,symrefs:r};if(o=o.toString("utf8"),o.includes("version 2"))return kn(s);const[f,l]=ui(o,"\0","\\x00");if(l.split(" ").map(c=>e.add(c)),f!=="0000000000000000000000000000000000000000 capabilities^{}"){const[c,h]=ui(f," "," ");for(i.set(h,c);;){const u=await s();if(u===!0)break;if(u!==null){const[d,y]=ui(u.toString("utf8")," "," ");i.set(y,d)}}}for(const c of e)if(c.startsWith("symref=")){const h=c.match(/symref=([^:]+):(.*)/);h.length===3&&r.set(h[1],h[2])}return{protocolVersion:1,capabilities:e,refs:i,symrefs:r}}function ui(n,t,e){const i=n.trim().split(t);if(i.length!==2)throw new Ft(`Two strings separated by '${e}'`,n.toString("utf8"));return i}const Sn=(n,t)=>n.endsWith("?")?`${n}${t}`:`${n}/${t.replace(/^https?:\/\//,"")}`,$n=(n,t)=>{(t.username||t.password)&&(n.Authorization=bn(t)),t.headers&&Object.assign(n,t.headers)},hi=async n=>{try{const t=Buffer.from(await He(n.body)),e=t.toString("utf8");return{preview:e.length<256?e:e.slice(0,256)+"...",response:e,data:t}}catch{return{}}};class ze{static async capabilities(){return["discover","connect"]}static async discover({http:t,onProgress:e,onAuth:i,onAuthSuccess:r,onAuthFailure:s,corsProxy:a,service:o,url:f,headers:l,protocolVersion:c}){let{url:h,auth:u}=_n(f);const d=a?Sn(a,h):h;(u.username||u.password)&&(l.Authorization=bn(u)),c===2&&(l["Git-Protocol"]="version=2");let y,b,_=!1;do if(y=await t.request({onProgress:e,method:"GET",url:`${d}/info/refs?service=${o}`,headers:l}),b=!1,y.statusCode===401||y.statusCode===203){const k=_?s:i;if(k){if(u=await k(h,{...u,headers:{...l}}),u&&u.cancel)throw new Kt;u&&($n(l,u),_=!0,b=!0)}}else y.statusCode===200&&_&&r&&await r(h,u);while(b);if(y.statusCode!==200){const{response:k}=await hi(y);throw new Yt(y.statusCode,y.statusMessage,k)}if(y.headers["content-type"]===`application/x-${o}-advertisement`){const k=await vn(y.body,{service:o});return k.auth=u,k}else{const{preview:k,response:v,data:O}=await hi(y);try{const F=await vn([O],{service:o});return F.auth=u,F}catch{throw new ge(k,v)}}}static async connect({http:t,onProgress:e,corsProxy:i,service:r,url:s,auth:a,body:o,headers:f}){const l=_n(s);l&&(s=l.url),i&&(s=Sn(i,s)),f["content-type"]=`application/x-${r}-request`,f.accept=`application/x-${r}-result`,$n(f,a);const c=await t.request({onProgress:e,method:"POST",url:`${s}/${r}`,body:o,headers:f});if(c.statusCode!==200){const{response:h}=hi(c);throw new Yt(c.statusCode,c.statusMessage,h)}return c}}class qe{static getRemoteHelperFor({url:t}){const e=new Map;e.set("http",ze),e.set("https",ze);const i=ba({url:t});if(!i)throw new _e(t);if(e.has(i.transport))return e.get(i.transport);throw new be(t,i.transport,i.transport==="ssh"?ga(t):void 0)}}function ba({url:n}){if(n.startsWith("git@"))return{transport:"ssh",address:n};const t=n.match(/(\w+)(:\/\/|::)(.*)/);if(t!==null){if(t[2]==="://")return{transport:t[1],address:t[0]};if(t[2]==="::")return{transport:t[1],address:t[3]}}}let Ht=null;class je{static async read({fs:t,gitdir:e}){Ht===null&&(Ht=new A);const i=m.join(e,"shallow"),r=new Set;return await Ht.acquire(i,async function(){const s=await t.read(i,{encoding:"utf8"});if(s===null||s.trim()==="")return r;s.trim().split(`
`).map(a=>r.add(a))}),r}static async write({fs:t,gitdir:e,oids:i}){Ht===null&&(Ht=new A);const r=m.join(e,"shallow");if(i.size>0){const s=[...i].join(`
`)+`
`;await Ht.acquire(r,async function(){await t.write(r,s,{encoding:"utf8"})})}else await Ht.acquire(r,async function(){await t.rm(r)})}}async function _a({fs:n,gitdir:t,oid:e}){const i=`objects/${e.slice(0,2)}/${e.slice(2)}`;return n.exists(`${t}/${i}`)}async function ka({fs:n,cache:t,gitdir:e,oid:i,getExternalRefDelta:r}){let s=await n.readdir(m.join(e,"objects/pack"));s=s.filter(a=>a.endsWith(".idx"));for(const a of s){const o=`${e}/objects/pack/${a}`,f=await ii({fs:n,cache:t,filename:o,getExternalRefDelta:r});if(f.error)throw new M(f.error);if(f.offsets.has(i))return!0}return!1}async function xn({fs:n,cache:t,gitdir:e,oid:i,format:r="content"}){const s=o=>tt({fs:n,cache:t,gitdir:e,oid:o});let a=await _a({fs:n,gitdir:e,oid:i});return a||(a=await ka({fs:n,cache:t,gitdir:e,oid:i,getExternalRefDelta:s})),a}function va(n){const r="5041434b"+"00000002"+"00000000";return n.slice(0,12).toString("hex")===r}function En(n,t){const e=n.map(i=>i.split("=",1)[0]);return t.filter(i=>{const r=i.split("=",1)[0];return e.includes(r)})}const Le={name:"isomorphic-git",version:"1.33.1",agent:"git/isomorphic-git@1.33.1"};class We{constructor(){this._queue=[]}write(t){if(this._ended)throw Error("You cannot write to a FIFO that has already been ended!");if(this._waiting){const e=this._waiting;this._waiting=null,e({value:t})}else this._queue.push(t)}end(){if(this._ended=!0,this._waiting){const t=this._waiting;this._waiting=null,t({done:!0})}}destroy(t){this.error=t,this.end()}async next(){if(this._queue.length>0)return{value:this._queue.shift()};if(this._ended)return{done:!0};if(this._waiting)throw Error("You cannot call read until the previous call to read has returned!");return new Promise(t=>{this._waiting=t})}}function Sa(n){const t=n.indexOf("\r"),e=n.indexOf(`
`);return t===-1&&e===-1?-1:t===-1?e+1:e===-1?t+1:e===t+1?e+1:Math.min(t,e)+1}function jn(n){const t=new We;let e="";return(async()=>(await Ee(n,i=>{for(i=i.toString("utf8"),e+=i;;){const r=Sa(e);if(r===-1)break;t.write(e.slice(0,r)),e=e.slice(r)}}),e.length>0&&t.write(e),t.end()))(),t}class Rn{static demux(t){const e=nt.streamReader(t),i=new We,r=new We,s=new We,a=async function(){const o=await e();if(o===null)return a();if(o===!0){i.end(),s.end(),t.error?r.destroy(t.error):r.end();return}switch(o[0]){case 1:{r.write(o.slice(1));break}case 2:{s.write(o.slice(1));break}case 3:{const f=o.slice(1);s.write(f),i.end(),s.end(),r.destroy(new Error(f.toString("utf8")));return}default:i.write(o)}a()};return a(),{packetlines:i,packfile:r,progress:s}}}async function $a(n){const{packetlines:t,packfile:e,progress:i}=Rn.demux(n),r=[],s=[],a=[];let o=!1,f=!1;return new Promise((l,c)=>{Ee(t,h=>{const u=h.toString("utf8").trim();if(u.startsWith("shallow")){const d=u.slice(-41).trim();d.length!==40&&c(new Bt(d)),r.push(d)}else if(u.startsWith("unshallow")){const d=u.slice(-41).trim();d.length!==40&&c(new Bt(d)),s.push(d)}else if(u.startsWith("ACK")){const[,d,y]=u.split(" ");a.push({oid:d,status:y}),y||(f=!0)}else u.startsWith("NAK")?(o=!0,f=!0):(f=!0,o=!0);f&&(n.error?c(n.error):l({shallows:r,unshallows:s,acks:a,nak:o,packfile:e,progress:i}))}).finally(()=>{f||(n.error?c(n.error):l({shallows:r,unshallows:s,acks:a,nak:o,packfile:e,progress:i}))})})}function xa({capabilities:n=[],wants:t=[],haves:e=[],shallows:i=[],depth:r=null,since:s=null,exclude:a=[]}){const o=[];t=[...new Set(t)];let f=` ${n.join(" ")}`;for(const l of t)o.push(nt.encode(`want ${l}${f}
`)),f="";for(const l of i)o.push(nt.encode(`shallow ${l}
`));r!==null&&o.push(nt.encode(`deepen ${r}
`)),s!==null&&o.push(nt.encode(`deepen-since ${Math.floor(s.valueOf()/1e3)}
`));for(const l of a)o.push(nt.encode(`deepen-not ${l}
`));o.push(nt.flush());for(const l of e)o.push(nt.encode(`have ${l}
`));return o.push(nt.encode(`done
`)),o}async function di({fs:n,cache:t,http:e,onProgress:i,onMessage:r,onAuth:s,onAuthSuccess:a,onAuthFailure:o,gitdir:f,ref:l,remoteRef:c,remote:h,url:u,corsProxy:d,depth:y=null,since:b=null,exclude:_=[],relative:k=!1,tags:v=!1,singleBranch:O=!1,headers:F={},prune:q=!1,pruneTags:N=!1}){const $=l||await Dt({fs:n,gitdir:f,test:!0}),E=await rt.get({fs:n,gitdir:f}),C=h||$&&await E.get(`branch.${$}.remote`)||"origin",W=u||await E.get(`remote.${C}.url`);if(typeof W>"u")throw new pt("remote OR url");const X=c||$&&await E.get(`branch.${$}.merge`)||l||"HEAD";d===void 0&&(d=await E.get("http.corsProxy"));const at=qe.getRemoteHelperFor({url:W}),Y=await at.discover({http:e,onAuth:s,onAuthSuccess:a,onAuthFailure:o,corsProxy:d,service:"git-upload-pack",url:W,headers:F,protocolVersion:1}),ot=Y.auth,lt=Y.refs;if(lt.size===0)return{defaultBranch:null,fetchHead:null,fetchHeadDescription:null};if(y!==null&&!Y.capabilities.has("shallow"))throw new Tt("shallow","depth");if(b!==null&&!Y.capabilities.has("deepen-since"))throw new Tt("deepen-since","since");if(_.length>0&&!Y.capabilities.has("deepen-not"))throw new Tt("deepen-not","exclude");if(k===!0&&!Y.capabilities.has("deepen-relative"))throw new Tt("deepen-relative","relative");const{oid:zt,fullref:qt}=S.resolveAgainstMap({ref:X,map:lt});for(const J of lt.keys())J===qt||J==="HEAD"||J.startsWith("refs/heads/")||v&&J.startsWith("refs/tags/")||lt.delete(J);const oe=En([...Y.capabilities],["multi_ack_detailed","no-done","side-band-64k","ofs-delta",`agent=${Le.agent}`]);k&&oe.push("deepen-relative");const bi=O?[zt]:lt.values(),_i=O?[$]:await S.listRefs({fs:n,gitdir:f,filepath:"refs"});let _t=[];for(let J of _i)try{J=await S.expand({fs:n,gitdir:f,ref:J});const ft=await S.resolve({fs:n,gitdir:f,ref:J});await xn({fs:n,cache:t,gitdir:f,oid:ft})&&_t.push(ft)}catch{}_t=[...new Set(_t)];const it=await je.read({fs:n,gitdir:f}),$t=Y.capabilities.has("shallow")?[...it]:[],ht=xa({capabilities:oe,wants:bi,haves:_t,shallows:$t,depth:y,since:b,exclude:_}),Re=Buffer.from(await He(ht)),Lt=await at.connect({http:e,onProgress:i,corsProxy:d,service:"git-upload-pack",url:W,auth:ot,body:[Re],headers:F}),ct=await $a(Lt.body);Lt.headers&&(ct.headers=Lt.headers);for(const J of ct.shallows)if(!it.has(J))try{const{object:ft}=await tt({fs:n,cache:t,gitdir:f,oid:J}),kt=new et(ft),xt=await Promise.all(kt.headers().parent.map(Be=>xn({fs:n,cache:t,gitdir:f,oid:Be})));xt.length===0||xt.every(Be=>Be)||it.add(J)}catch{it.add(J)}for(const J of ct.unshallows)it.delete(J);if(await je.write({fs:n,gitdir:f,oids:it}),O){const J=new Map([[qt,zt]]),ft=new Map;let kt=10,xt=qt;for(;kt--;){const vi=Y.symrefs.get(xt);if(vi===void 0)break;ft.set(xt,vi),xt=vi}const ki=lt.get(xt);ki&&J.set(xt,ki);const{pruned:Be}=await S.updateRemoteRefs({fs:n,gitdir:f,remote:C,refs:J,symrefs:ft,tags:v,prune:q});q&&(ct.pruned=Be)}else{const{pruned:J}=await S.updateRemoteRefs({fs:n,gitdir:f,remote:C,refs:lt,symrefs:Y.symrefs,tags:v,prune:q,pruneTags:N});q&&(ct.pruned=J)}if(ct.HEAD=Y.symrefs.get("HEAD"),ct.HEAD===void 0){const{oid:J}=S.resolveAgainstMap({ref:"HEAD",map:lt});for(const[ft,kt]of lt.entries())if(ft!=="HEAD"&&kt===J){ct.HEAD=ft;break}}const mo=qt.startsWith("refs/tags")?"tag":"branch";if(ct.FETCH_HEAD={oid:zt,description:`${mo} '${Ut(qt)}' of ${W}`},i||r){const J=jn(ct.progress);Ee(J,async ft=>{if(r&&await r(ft),i){const kt=ft.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);kt&&await i({phase:kt[1].trim(),loaded:parseInt(kt[2],10),total:parseInt(kt[3],10)})}})}const Ve=Buffer.from(await He(ct.packfile));if(Lt.body.error)throw Lt.body.error;const Qr=Ve.slice(-20).toString("hex"),Oe={defaultBranch:ct.HEAD,fetchHead:ct.FETCH_HEAD.oid,fetchHeadDescription:ct.FETCH_HEAD.description};if(ct.headers&&(Oe.headers=ct.headers),q&&(Oe.pruned=ct.pruned),Qr!==""&&!va(Ve)){Oe.packfile=`objects/pack/pack-${Qr}.pack`;const J=m.join(f,Oe.packfile);await n.write(J,Ve);const ft=xt=>tt({fs:n,cache:t,gitdir:f,oid:xt}),kt=await Xt.fromPack({pack:Ve,getExternalRefDelta:ft,onProgress:i});await n.write(J.replace(/\.pack$/,".idx"),await kt.toBuffer())}return Oe}async function On({fs:n,bare:t=!1,dir:e,gitdir:i=t?e:m.join(e,".git"),defaultBranch:r="master"}){if(await n.exists(i+"/config"))return;let s=["hooks","info","objects/info","objects/pack","refs/heads","refs/tags"];s=s.map(a=>i+"/"+a);for(const a of s)await n.mkdir(a);await n.write(i+"/config",`[core]
	repositoryformatversion = 0
	filemode = false
	bare = ${t}
`+(t?"":`	logallrefupdates = true
`)+`	symlinks = false
	ignorecase = true
`),await n.write(i+"/HEAD",`ref: refs/heads/${r}
`)}async function Ea({fs:n,cache:t,http:e,onProgress:i,onMessage:r,onAuth:s,onAuthSuccess:a,onAuthFailure:o,onPostCheckout:f,dir:l,gitdir:c,url:h,corsProxy:u,ref:d,remote:y,depth:b,since:_,exclude:k,relative:v,singleBranch:O,noCheckout:F,noTags:q,headers:N,nonBlocking:$,batchSize:E=100}){try{if(await On({fs:n,gitdir:c}),await dn({fs:n,gitdir:c,remote:y,url:h,force:!1}),u){const X=await rt.get({fs:n,gitdir:c});await X.set("http.corsProxy",u),await rt.save({fs:n,gitdir:c,config:X})}const{defaultBranch:C,fetchHead:W}=await di({fs:n,cache:t,http:e,onProgress:i,onMessage:r,onAuth:s,onAuthSuccess:a,onAuthFailure:o,gitdir:c,ref:d,remote:y,corsProxy:u,depth:b,since:_,exclude:k,relative:v,singleBranch:O,headers:N,tags:!q});if(W===null)return;d=d||C,d=d.replace("refs/heads/",""),await ci({fs:n,cache:t,onProgress:i,onPostCheckout:f,dir:l,gitdir:c,ref:d,remote:y,noCheckout:F,nonBlocking:$,batchSize:E})}catch(C){throw await n.rmdir(c,{recursive:!0,maxRetries:10}).catch(()=>{}),C}}async function Bn({fs:n,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,onPostCheckout:o,dir:f,gitdir:l=m.join(f,".git"),url:c,corsProxy:h=void 0,ref:u=void 0,remote:d="origin",depth:y=void 0,since:b=void 0,exclude:_=[],relative:k=!1,singleBranch:v=!1,noCheckout:O=!1,noTags:F=!1,headers:q={},cache:N={},nonBlocking:$=!1,batchSize:E=100}){try{return w("fs",n),w("http",t),w("gitdir",l),O||w("dir",f),w("url",c),await Ea({fs:new z(n),cache:N,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,onPostCheckout:o,dir:f,gitdir:l,url:c,corsProxy:h,ref:u,remote:d,depth:y,since:b,exclude:_,relative:k,singleBranch:v,noCheckout:O,noTags:F,headers:q,nonBlocking:$,batchSize:E})}catch(C){throw C.caller="git.clone",C}}async function In({fs:n,onSign:t,dir:e,gitdir:i=m.join(e,".git"),message:r,author:s,committer:a,signingKey:o,amend:f=!1,dryRun:l=!1,noUpdateBranch:c=!1,ref:h,parent:u,tree:d,cache:y={}}){try{w("fs",n),f||w("message",r),o&&w("onSign",t);const b=new z(n);return await Ue({fs:b,cache:y,onSign:t,gitdir:i,message:r,author:s,committer:a,signingKey:o,amend:f,dryRun:l,noUpdateBranch:c,ref:h,parent:u,tree:d})}catch(b){throw b.caller="git.commit",b}}async function Pn({fs:n,dir:t,gitdir:e=m.join(t,".git"),fullname:i=!1,test:r=!1}){try{return w("fs",n),w("gitdir",e),await Dt({fs:new z(n),gitdir:e,fullname:i,test:r})}catch(s){throw s.caller="git.currentBranch",s}}async function ja({fs:n,gitdir:t,ref:e}){if(e=e.startsWith("refs/heads/")?e:`refs/heads/${e}`,!await S.exists({fs:n,gitdir:t,ref:e}))throw new Q(e);const r=await S.expand({fs:n,gitdir:t,ref:e}),s=await Dt({fs:n,gitdir:t,fullname:!0});if(r===s){const f=await S.resolve({fs:n,gitdir:t,ref:r});await S.writeRef({fs:n,gitdir:t,ref:"HEAD",value:f})}await S.deleteRef({fs:n,gitdir:t,ref:r});const a=Ut(e),o=await rt.get({fs:n,gitdir:t});await o.deleteSection("branch",a),await rt.save({fs:n,gitdir:t,config:o})}async function Tn({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i}){try{return w("fs",n),w("ref",i),await ja({fs:new z(n),gitdir:e,ref:i})}catch(r){throw r.caller="git.deleteBranch",r}}async function Cn({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i}){try{w("fs",n),w("ref",i),await S.deleteRef({fs:new z(n),gitdir:e,ref:i})}catch(r){throw r.caller="git.deleteRef",r}}async function Ra({fs:n,gitdir:t,remote:e}){const i=await rt.get({fs:n,gitdir:t});await i.deleteSection("remote",e),await rt.save({fs:n,gitdir:t,config:i})}async function An({fs:n,dir:t,gitdir:e=m.join(t,".git"),remote:i}){try{return w("fs",n),w("remote",i),await Ra({fs:new z(n),gitdir:e,remote:i})}catch(r){throw r.caller="git.deleteRemote",r}}async function Oa({fs:n,gitdir:t,ref:e}){e=e.startsWith("refs/tags/")?e:`refs/tags/${e}`,await S.deleteRef({fs:n,gitdir:t,ref:e})}async function Dn({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i}){try{return w("fs",n),w("ref",i),await Oa({fs:new z(n),gitdir:e,ref:i})}catch(r){throw r.caller="git.deleteTag",r}}async function Ba({fs:n,gitdir:t,oid:e}){const i=e.slice(0,2);return(await n.readdir(`${t}/objects/${i}`)).map(s=>`${i}${s}`).filter(s=>s.startsWith(e))}async function Ia({fs:n,cache:t,gitdir:e,oid:i,getExternalRefDelta:r}){const s=[];let a=await n.readdir(m.join(e,"objects/pack"));a=a.filter(o=>o.endsWith(".idx"));for(const o of a){const f=`${e}/objects/pack/${o}`,l=await ii({fs:n,cache:t,filename:f,getExternalRefDelta:r});if(l.error)throw new M(l.error);for(const c of l.offsets.keys())c.startsWith(i)&&s.push(c)}return s}async function Pa({fs:n,cache:t,gitdir:e,oid:i}){const r=o=>tt({fs:n,cache:t,gitdir:e,oid:o}),s=await Ba({fs:n,gitdir:e,oid:i}),a=await Ia({fs:n,cache:t,gitdir:e,oid:i,getExternalRefDelta:r});for(const o of a)s.indexOf(o)===-1&&s.push(o);if(s.length===1)return s[0];throw s.length>1?new fe("oids",i,s):new Q(`an object matching "${i}"`)}async function Nn({fs:n,dir:t,gitdir:e=m.join(t,".git"),oid:i,cache:r={}}){try{return w("fs",n),w("gitdir",e),w("oid",i),await Pa({fs:new z(n),cache:r,gitdir:e,oid:i})}catch(s){throw s.caller="git.expandOid",s}}async function Mn({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i}){try{return w("fs",n),w("gitdir",e),w("ref",i),await S.expand({fs:new z(n),gitdir:e,ref:i})}catch(r){throw r.caller="git.expandRef",r}}async function wi({fs:n,cache:t,gitdir:e,oids:i}){const r={},s=i.length;let a=i.map((o,f)=>({index:f,oid:o}));for(;a.length;){const o=new Set;for(const{oid:l,index:c}of a)r[l]||(r[l]=new Set),r[l].add(c),r[l].size===s&&o.add(l);if(o.size>0)return[...o];const f=new Map;for(const{oid:l,index:c}of a)try{const{object:h}=await tt({fs:n,cache:t,gitdir:e,oid:l}),u=et.from(h),{parent:d}=u.parseHeaders();for(const y of d)(!r[y]||!r[y].has(c))&&f.set(y+":"+c,{oid:y,index:c})}catch{}a=Array.from(f.values())}return[]}const mi=/^.*(\r?\n|$)/gm;function Ta({branches:n,contents:t}){const e=n[1],i=n[2],r=t[0],s=t[1],a=t[2],o=s.match(mi),f=r.match(mi),l=a.match(mi),c=U(o,f,l),h=7;let u="",d=!0;for(const y of c)y.ok&&(u+=y.ok.join("")),y.conflict&&(d=!1,u+=`${"<".repeat(h)} ${e}
`,u+=y.conflict.a.join(""),u+=`${"=".repeat(h)}
`,u+=y.conflict.b.join(""),u+=`${">".repeat(h)} ${i}
`);return{cleanMerge:d,mergedText:u}}async function Ca({fs:n,cache:t,dir:e,gitdir:i=m.join(e,".git"),index:r,ourOid:s,baseOid:a,theirOid:o,ourName:f="ours",baseName:l="base",theirName:c="theirs",dryRun:h=!1,abortOnConflict:u=!0,mergeDriver:d}){const y=bt({ref:s}),b=bt({ref:a}),_=bt({ref:o}),k=[],v=[],O=[],F=[],q=await Ct({fs:n,cache:t,dir:e,gitdir:i,trees:[y,b,_],map:async function(N,[$,E,C]){const W=Pe(N),X=await Fe($,E),at=await Fe(C,E);switch(`${X}-${at}`){case"false-false":return{mode:await E.mode(),path:W,oid:await E.oid(),type:await E.type()};case"false-true":return!C&&await $.type()==="tree"?{mode:await $.mode(),path:W,oid:await $.oid(),type:await $.type()}:C?{mode:await C.mode(),path:W,oid:await C.oid(),type:await C.type()}:void 0;case"true-false":return!$&&await C.type()==="tree"?{mode:await C.mode(),path:W,oid:await C.oid(),type:await C.type()}:$?{mode:await $.mode(),path:W,oid:await $.oid(),type:await $.type()}:void 0;case"true-true":{if($&&C&&await $.type()==="tree"&&await C.type()==="tree")return{mode:await $.mode(),path:W,oid:await $.oid(),type:"tree"};if($&&C&&await $.type()==="blob"&&await C.type()==="blob")return Aa({fs:n,gitdir:i,path:W,ours:$,base:E,theirs:C,ourName:f,baseName:l,theirName:c,mergeDriver:d}).then(async Y=>{if(Y.cleanMerge)u||r.insert({filepath:N,oid:Y.mergeResult.oid,stage:0});else if(k.push(N),v.push(N),!u){let ot="";E&&await E.type()==="blob"&&(ot=await E.oid());const lt=await $.oid(),zt=await C.oid();r.delete({filepath:N}),ot&&r.insert({filepath:N,oid:ot,stage:1}),r.insert({filepath:N,oid:lt,stage:2}),r.insert({filepath:N,oid:zt,stage:3})}return Y.mergeResult});if(E&&!$&&C&&await E.type()==="blob"&&await C.type()==="blob"){if(k.push(N),O.push(N),!u){const Y=await E.oid(),ot=await C.oid();r.delete({filepath:N}),r.insert({filepath:N,oid:Y,stage:1}),r.insert({filepath:N,oid:ot,stage:3})}return{mode:await C.mode(),oid:await C.oid(),type:"blob",path:W}}if(E&&$&&!C&&await E.type()==="blob"&&await $.type()==="blob"){if(k.push(N),F.push(N),!u){const Y=await E.oid(),ot=await $.oid();r.delete({filepath:N}),r.insert({filepath:N,oid:Y,stage:1}),r.insert({filepath:N,oid:ot,stage:2})}return{mode:await $.mode(),oid:await $.oid(),type:"blob",path:W}}if(E&&!$&&!C&&(await E.type()==="blob"||await E.type()==="tree"))return;throw new Zt}}},reduce:k.length!==0&&(!e||u)?void 0:async(N,$)=>{const E=$.filter(Boolean);if(N&&!(N&&N.type==="tree"&&E.length===0&&N.path!==".")){if(E.length>0||N.path==="."&&E.length===0){const W=new mt(E).toObject(),X=await yt({fs:n,gitdir:i,type:"tree",object:W,dryRun:h});N.oid=X}return N}}});return k.length!==0?(e&&!u&&await Ct({fs:n,cache:t,dir:e,gitdir:i,trees:[bt({ref:q.oid})],map:async function(N,[$]){const E=`${e}/${N}`;if(await $.type()==="blob"){const C=await $.mode(),W=new TextDecoder().decode(await $.content());await n.write(E,W,{mode:C})}return!0}}),new Qt(k,v,O,F)):q.oid}async function Aa({fs:n,gitdir:t,path:e,ours:i,base:r,theirs:s,ourName:a,theirName:o,baseName:f,dryRun:l,mergeDriver:c=Ta}){const h="blob";let u="100755",d="",y="";r&&await r.type()==="blob"&&(u=await r.mode(),d=await r.oid(),y=Buffer.from(await r.content()).toString("utf8"));const b=u===await i.mode()?await s.mode():await i.mode();if(await i.oid()===await s.oid())return{cleanMerge:!0,mergeResult:{mode:b,path:e,oid:await i.oid(),type:h}};if(await i.oid()===d)return{cleanMerge:!0,mergeResult:{mode:b,path:e,oid:await s.oid(),type:h}};if(await s.oid()===d)return{cleanMerge:!0,mergeResult:{mode:b,path:e,oid:await i.oid(),type:h}};const _=Buffer.from(await i.content()).toString("utf8"),k=Buffer.from(await s.content()).toString("utf8"),{mergedText:v,cleanMerge:O}=await c({branches:[f,a,o],contents:[y,_,k],path:e}),F=await yt({fs:n,gitdir:t,type:"blob",object:Buffer.from(v,"utf8"),dryRun:l});return{cleanMerge:O,mergeResult:{mode:b,path:e,oid:F,type:h}}}async function Fn({fs:n,cache:t,dir:e,gitdir:i,ours:r,theirs:s,fastForward:a=!0,fastForwardOnly:o=!1,dryRun:f=!1,noUpdateBranch:l=!1,abortOnConflict:c=!0,message:h,author:u,committer:d,signingKey:y,onSign:b,mergeDriver:_,allowUnrelatedHistories:k=!1}){r===void 0&&(r=await Dt({fs:n,gitdir:i,fullname:!0})),r=await S.expand({fs:n,gitdir:i,ref:r}),s=await S.expand({fs:n,gitdir:i,ref:s});const v=await S.resolve({fs:n,gitdir:i,ref:r}),O=await S.resolve({fs:n,gitdir:i,ref:s}),F=await wi({fs:n,cache:t,gitdir:i,oids:[v,O]});if(F.length!==1)if(F.length===0&&k)F.push("4b825dc642cb6eb9a060e54bf8d69288fbee4904");else throw new Zt;const q=F[0];if(q===O)return{oid:v,alreadyMerged:!0};if(a&&q===v)return!f&&!l&&await S.writeRef({fs:n,gitdir:i,ref:r,value:O}),{oid:O,fastForward:!0};{if(o)throw new we;const N=await st.acquire({fs:n,gitdir:i,cache:t,allowUnmerged:!1},async E=>Ca({fs:n,cache:t,dir:e,gitdir:i,index:E,ourOid:v,theirOid:O,baseOid:q,ourName:Ut(r),baseName:"base",theirName:Ut(s),dryRun:f,abortOnConflict:c,mergeDriver:_}));if(N instanceof Qt)throw N;return h||(h=`Merge branch '${Ut(s)}' into ${Ut(r)}`),{oid:await Ue({fs:n,cache:t,gitdir:i,message:h,ref:r,tree:N,parent:[v,O],author:u,committer:d,signingKey:y,onSign:b,dryRun:f,noUpdateBranch:l}),tree:N,mergeCommit:!0}}}async function Un({fs:n,cache:t,http:e,onProgress:i,onMessage:r,onAuth:s,onAuthSuccess:a,onAuthFailure:o,dir:f,gitdir:l,ref:c,url:h,remote:u,remoteRef:d,prune:y,pruneTags:b,fastForward:_,fastForwardOnly:k,corsProxy:v,singleBranch:O,headers:F,author:q,committer:N,signingKey:$}){try{if(!c){const W=await Dt({fs:n,gitdir:l});if(!W)throw new pt("ref");c=W}const{fetchHead:E,fetchHeadDescription:C}=await di({fs:n,cache:t,http:e,onProgress:i,onMessage:r,onAuth:s,onAuthSuccess:a,onAuthFailure:o,gitdir:l,corsProxy:v,ref:c,url:h,remote:u,remoteRef:d,singleBranch:O,headers:F,prune:y,pruneTags:b});await Fn({fs:n,cache:t,gitdir:l,ours:c,theirs:E,fastForward:_,fastForwardOnly:k,message:`Merge ${C}`,author:q,committer:N,signingKey:$,dryRun:!1,noUpdateBranch:!1}),await ci({fs:n,cache:t,onProgress:i,dir:f,gitdir:l,ref:c,remote:u,noCheckout:!1})}catch(E){throw E.caller="git.pull",E}}async function Hn({fs:n,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:f=m.join(o,".git"),ref:l,url:c,remote:h,remoteRef:u,corsProxy:d,singleBranch:y,headers:b={},cache:_={}}){try{w("fs",n),w("http",t),w("gitdir",f);const k={name:"",email:"",timestamp:Date.now(),timezoneOffset:0};return await Un({fs:new z(n),cache:_,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:f,ref:l,url:c,remote:h,remoteRef:u,fastForwardOnly:!0,corsProxy:d,singleBranch:y,headers:b,author:k,committer:k})}catch(k){throw k.caller="git.fastForward",k}}async function zn({fs:n,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:f=m.join(o,".git"),ref:l,remote:c,remoteRef:h,url:u,corsProxy:d,depth:y=null,since:b=null,exclude:_=[],relative:k=!1,tags:v=!1,singleBranch:O=!1,headers:F={},prune:q=!1,pruneTags:N=!1,cache:$={}}){try{return w("fs",n),w("http",t),w("gitdir",f),await di({fs:new z(n),cache:$,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,gitdir:f,ref:l,remote:c,remoteRef:h,url:u,corsProxy:d,depth:y,since:b,exclude:_,relative:k,tags:v,singleBranch:O,headers:F,prune:q,pruneTags:N})}catch(E){throw E.caller="git.fetch",E}}async function qn({fs:n,dir:t,gitdir:e=m.join(t,".git"),oids:i,cache:r={}}){try{return w("fs",n),w("gitdir",e),w("oids",i),await wi({fs:new z(n),cache:r,gitdir:e,oids:i})}catch(s){throw s.caller="git.findMergeBase",s}}async function Ln({fs:n,filepath:t}){if(await n.exists(m.join(t,".git")))return t;{const e=Gt(t);if(e===t)throw new Q(`git root for ${t}`);return Ln({fs:n,filepath:e})}}async function Wn({fs:n,filepath:t}){try{return w("fs",n),w("filepath",t),await Ln({fs:new z(n),filepath:t})}catch(e){throw e.caller="git.findRoot",e}}async function Gn({fs:n,dir:t,gitdir:e=m.join(t,".git"),path:i}){try{return w("fs",n),w("gitdir",e),w("path",i),await Se({fs:new z(n),gitdir:e,path:i})}catch(r){throw r.caller="git.getConfig",r}}async function Da({fs:n,gitdir:t,path:e}){return(await rt.get({fs:n,gitdir:t})).getall(e)}async function Vn({fs:n,dir:t,gitdir:e=m.join(t,".git"),path:i}){try{return w("fs",n),w("gitdir",e),w("path",i),await Da({fs:new z(n),gitdir:e,path:i})}catch(r){throw r.caller="git.getConfigAll",r}}async function Xn({http:n,onAuth:t,onAuthSuccess:e,onAuthFailure:i,corsProxy:r,url:s,headers:a={},forPush:o=!1}){try{w("http",n),w("url",s);const l=await qe.getRemoteHelperFor({url:s}).discover({http:n,onAuth:t,onAuthSuccess:e,onAuthFailure:i,corsProxy:r,service:o?"git-receive-pack":"git-upload-pack",url:s,headers:a,protocolVersion:1}),c={capabilities:[...l.capabilities]};for(const[h,u]of l.refs){const d=h.split("/"),y=d.pop();let b=c;for(const _ of d)b[_]=b[_]||{},b=b[_];b[y]=u}for(const[h,u]of l.symrefs){const d=h.split("/"),y=d.pop();let b=c;for(const _ of d)b[_]=b[_]||{},b=b[_];b[y]=u}return c}catch(f){throw f.caller="git.getRemoteInfo",f}}function Yn(n,t,e,i){const r=[];for(const[s,a]of n.refs){if(t&&!s.startsWith(t))continue;if(s.endsWith("^{}")){if(i){const f=s.replace("^{}",""),l=r[r.length-1],c=l.ref===f?l:r.find(h=>h.ref===f);if(c===void 0)throw new Error("I did not expect this to happen");c.peeled=a}continue}const o={ref:s,oid:a};e&&n.symrefs.has(s)&&(o.target=n.symrefs.get(s)),r.push(o)}return r}async function Zn({http:n,onAuth:t,onAuthSuccess:e,onAuthFailure:i,corsProxy:r,url:s,headers:a={},forPush:o=!1,protocolVersion:f=2}){try{w("http",n),w("url",s);const c=await qe.getRemoteHelperFor({url:s}).discover({http:n,onAuth:t,onAuthSuccess:e,onAuthFailure:i,corsProxy:r,service:o?"git-receive-pack":"git-upload-pack",url:s,headers:a,protocolVersion:f});if(c.protocolVersion===2)return{protocolVersion:c.protocolVersion,capabilities:c.capabilities2};const h={};for(const u of c.capabilities){const[d,y]=u.split("=");y?h[d]=y:h[d]=!0}return{protocolVersion:1,capabilities:h,refs:Yn(c,void 0,!0,!0)}}catch(l){throw l.caller="git.getRemoteInfo2",l}}async function Na({type:n,object:t,format:e="content",oid:i=void 0}){return e!=="deflated"&&(e!=="wrapped"&&(t=Vt.wrap({type:n,object:t})),i=await jt(t)),{oid:i,object:t}}async function Qn({object:n}){try{w("object",n),typeof n=="string"?n=Buffer.from(n,"utf8"):n instanceof Uint8Array||(n=new Uint8Array(n));const t="blob",{oid:e,object:i}=await Na({type:t,format:"content",object:n});return{oid:e,type:t,object:i,format:"wrapped"}}catch(t){throw t.caller="git.hashBlob",t}}async function Ma({fs:n,cache:t,onProgress:e,dir:i,gitdir:r,filepath:s}){try{s=m.join(i,s);const a=await n.read(s),o=l=>tt({fs:n,cache:t,gitdir:r,oid:l}),f=await Xt.fromPack({pack:a,getExternalRefDelta:o,onProgress:e});return await n.write(s.replace(/\.pack$/,".idx"),await f.toBuffer()),{oids:[...f.hashes]}}catch(a){throw a.caller="git.indexPack",a}}async function Jn({fs:n,onProgress:t,dir:e,gitdir:i=m.join(e,".git"),filepath:r,cache:s={}}){try{return w("fs",n),w("dir",e),w("gitdir",e),w("filepath",r),await Ma({fs:new z(n),cache:s,onProgress:t,dir:e,gitdir:i,filepath:r})}catch(a){throw a.caller="git.indexPack",a}}async function Kn({fs:n,bare:t=!1,dir:e,gitdir:i=t?e:m.join(e,".git"),defaultBranch:r="master"}){try{return w("fs",n),w("gitdir",i),t||w("dir",e),await On({fs:new z(n),bare:t,dir:e,gitdir:i,defaultBranch:r})}catch(s){throw s.caller="git.init",s}}async function tr({fs:n,cache:t,gitdir:e,oid:i,ancestor:r,depth:s}){const a=await je.read({fs:n,gitdir:e});if(!i)throw new pt("oid");if(!r)throw new pt("ancestor");if(i===r)return!1;const o=[i],f=new Set;let l=0;for(;o.length;){if(l++===s)throw new pe(s);const c=o.shift(),{type:h,object:u}=await tt({fs:n,cache:t,gitdir:e,oid:c});if(h!=="commit")throw new dt(c,h,"commit");const d=et.from(u).parse();for(const y of d.parent)if(y===r)return!0;if(!a.has(c))for(const y of d.parent)f.has(y)||(o.push(y),f.add(y))}return!1}async function er({fs:n,dir:t,gitdir:e=m.join(t,".git"),oid:i,ancestor:r,depth:s=-1,cache:a={}}){try{return w("fs",n),w("gitdir",e),w("oid",i),w("ancestor",r),await tr({fs:new z(n),cache:a,gitdir:e,oid:i,ancestor:r,depth:s})}catch(o){throw o.caller="git.isDescendent",o}}async function ir({fs:n,dir:t,gitdir:e=m.join(t,".git"),filepath:i}){try{return w("fs",n),w("dir",t),w("gitdir",e),w("filepath",i),ie.isIgnored({fs:new z(n),dir:t,gitdir:e,filepath:i})}catch(r){throw r.caller="git.isIgnored",r}}async function nr({fs:n,dir:t,gitdir:e=m.join(t,".git"),remote:i}){try{return w("fs",n),w("gitdir",e),S.listBranches({fs:new z(n),gitdir:e,remote:i})}catch(r){throw r.caller="git.listBranches",r}}async function Fa({fs:n,gitdir:t,ref:e,cache:i}){if(e){const r=await S.resolve({gitdir:t,fs:n,ref:e}),s=[];return await rr({fs:n,cache:i,gitdir:t,oid:r,filenames:s,prefix:""}),s}else return st.acquire({fs:n,gitdir:t,cache:i},async function(r){return r.entries.map(s=>s.path)})}async function rr({fs:n,cache:t,gitdir:e,oid:i,filenames:r,prefix:s}){const{tree:a}=await se({fs:n,cache:t,gitdir:e,oid:i});for(const o of a)o.type==="tree"?await rr({fs:n,cache:t,gitdir:e,oid:o.oid,filenames:r,prefix:m.join(s,o.path)}):r.push(m.join(s,o.path))}async function sr({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i,cache:r={}}){try{return w("fs",n),w("gitdir",e),await Fa({fs:new z(n),cache:r,gitdir:e,ref:i})}catch(s){throw s.caller="git.listFiles",s}}async function Ua({fs:n,cache:t,gitdir:e,ref:i}){let r;try{r=await S.resolve({gitdir:e,fs:n,ref:i})}catch(o){if(o instanceof Q)return[]}return(await se({fs:n,cache:t,gitdir:e,oid:r})).tree.map(o=>({target:o.path,note:o.oid}))}async function ar({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i="refs/notes/commits",cache:r={}}){try{return w("fs",n),w("gitdir",e),w("ref",i),await Ua({fs:new z(n),cache:r,gitdir:e,ref:i})}catch(s){throw s.caller="git.listNotes",s}}async function or({fs:n,dir:t,gitdir:e=m.join(t,".git"),filepath:i}){try{return w("fs",n),w("gitdir",e),S.listRefs({fs:new z(n),gitdir:e,filepath:i})}catch(r){throw r.caller="git.listRefs",r}}async function Ha({fs:n,gitdir:t}){const e=await rt.get({fs:n,gitdir:t}),i=await e.getSubsections("remote");return Promise.all(i.map(async s=>{const a=await e.get(`remote.${s}.url`);return{remote:s,url:a}}))}async function cr({fs:n,dir:t,gitdir:e=m.join(t,".git")}){try{return w("fs",n),w("gitdir",e),await Ha({fs:new z(n),gitdir:e})}catch(i){throw i.caller="git.listRemotes",i}}async function za(n){const t=nt.streamReader(n),e=[];let i;for(;i=await t(),i!==!0;){if(i===null)continue;i=i.toString("utf8").replace(/\n$/,"");const[r,s,...a]=i.split(" "),o={ref:s,oid:r};for(const f of a){const[l,c]=f.split(":");l==="symref-target"?o.target=c:l==="peeled"&&(o.peeled=c)}e.push(o)}return e}async function qa({prefix:n,symrefs:t,peelTags:e}){const i=[];return i.push(nt.encode(`command=ls-refs
`)),i.push(nt.encode(`agent=${Le.agent}
`)),(e||t||n)&&i.push(nt.delim()),e&&i.push(nt.encode("peel")),t&&i.push(nt.encode("symrefs")),n&&i.push(nt.encode(`ref-prefix ${n}`)),i.push(nt.flush()),i}async function lr({http:n,onAuth:t,onAuthSuccess:e,onAuthFailure:i,corsProxy:r,url:s,headers:a={},forPush:o=!1,protocolVersion:f=2,prefix:l,symrefs:c,peelTags:h}){try{w("http",n),w("url",s);const u=await ze.discover({http:n,onAuth:t,onAuthSuccess:e,onAuthFailure:i,corsProxy:r,service:o?"git-receive-pack":"git-upload-pack",url:s,headers:a,protocolVersion:f});if(u.protocolVersion===1)return Yn(u,l,c,h);const d=await qa({prefix:l,symrefs:c,peelTags:h}),y=await ze.connect({http:n,auth:u.auth,headers:a,corsProxy:r,service:o?"git-receive-pack":"git-upload-pack",url:s,body:d});return za(y.body)}catch(u){throw u.caller="git.listServerRefs",u}}async function fr({fs:n,dir:t,gitdir:e=m.join(t,".git")}){try{return w("fs",n),w("gitdir",e),S.listTags({fs:new z(n),gitdir:e})}catch(i){throw i.caller="git.listTags",i}}function La(n,t){return n.committer.timestamp-t.committer.timestamp}const Wa="e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";async function ur({fs:n,cache:t,gitdir:e,oid:i,fileId:r}){if(r===Wa)return;const s=i;let a;const o=await te({fs:n,cache:t,gitdir:e,oid:i}),f=o.tree;return r===o.oid?a=o.path:(a=await hr({fs:n,cache:t,gitdir:e,tree:f,fileId:r,oid:s}),Array.isArray(a)&&(a.length===0?a=void 0:a.length===1&&(a=a[0]))),a}async function hr({fs:n,cache:t,gitdir:e,tree:i,fileId:r,oid:s,filepaths:a=[],parentPath:o=""}){const f=i.entries().map(function(l){let c;return l.oid===r?(c=m.join(o,l.path),a.push(c)):l.type==="tree"&&(c=tt({fs:n,cache:t,gitdir:e,oid:l.oid}).then(function({object:h}){return hr({fs:n,cache:t,gitdir:e,tree:mt.from(h),fileId:r,oid:s,filepaths:a,parentPath:m.join(o,l.path)})})),c});return await Promise.all(f),a}async function Ga({fs:n,cache:t,gitdir:e,filepath:i,ref:r,depth:s,since:a,force:o,follow:f}){const l=typeof a>"u"?void 0:Math.floor(a.valueOf()/1e3),c=[],h=await je.read({fs:n,gitdir:e}),u=await S.resolve({fs:n,gitdir:e,ref:r}),d=[await re({fs:n,cache:t,gitdir:e,oid:u})];let y,b,_;function k(v){_&&i&&c.push(v)}for(;d.length>0;){const v=d.pop();if(l!==void 0&&v.commit.committer.timestamp<=l)break;if(i){let O;try{O=await $e({fs:n,cache:t,gitdir:e,oid:v.commit.tree,filepath:i}),b&&y!==O&&c.push(b),y=O,b=v,_=!0}catch(F){if(F instanceof Q){let q=f&&y;if(q&&(q=await ur({fs:n,cache:t,gitdir:e,oid:v.commit.tree,fileId:y}),q))if(Array.isArray(q)){if(b){const N=await ur({fs:n,cache:t,gitdir:e,oid:b.commit.tree,fileId:y});if(Array.isArray(N))if(q=q.filter($=>N.indexOf($)===-1),q.length===1)q=q[0],i=q,b&&c.push(b);else{q=!1,b&&c.push(b);break}}}else i=q,b&&c.push(b);if(!q){if(_&&y&&(c.push(b),!o))break;if(!o&&!f)throw F}b=v,_=!1}else throw F}}else c.push(v);if(s!==void 0&&c.length===s){k(v);break}if(!h.has(v.oid))for(const O of v.commit.parent){const F=await re({fs:n,cache:t,gitdir:e,oid:O});d.map(q=>q.oid).includes(F.oid)||d.push(F)}d.length===0&&k(v),d.sort((O,F)=>La(O.commit,F.commit))}return c}async function dr({fs:n,dir:t,gitdir:e=m.join(t,".git"),filepath:i,ref:r="HEAD",depth:s,since:a,force:o,follow:f,cache:l={}}){try{return w("fs",n),w("gitdir",e),w("ref",r),await Ga({fs:new z(n),cache:l,gitdir:e,filepath:i,ref:r,depth:s,since:a,force:o,follow:f})}catch(c){throw c.caller="git.log",c}}async function wr({fs:n,onSign:t,dir:e,gitdir:i=m.join(e,".git"),ours:r,theirs:s,fastForward:a=!0,fastForwardOnly:o=!1,dryRun:f=!1,noUpdateBranch:l=!1,abortOnConflict:c=!0,message:h,author:u,committer:d,signingKey:y,cache:b={},mergeDriver:_,allowUnrelatedHistories:k=!1}){try{w("fs",n),y&&w("onSign",t);const v=new z(n),O=await At({fs:v,gitdir:i,author:u});if(!O&&(!o||!a))throw new ut("author");const F=await ne({fs:v,gitdir:i,author:O,committer:d});if(!F&&(!o||!a))throw new ut("committer");return await Fn({fs:v,cache:b,dir:e,gitdir:i,ours:r,theirs:s,fastForward:a,fastForwardOnly:o,dryRun:f,noUpdateBranch:l,abortOnConflict:c,message:h,author:O,committer:F,signingKey:y,onSign:t,mergeDriver:_,allowUnrelatedHistories:k})}catch(v){throw v.caller="git.merge",v}}const Va={commit:16,tree:32,blob:48,tag:64,ofs_delta:96,ref_delta:112};async function mr({fs:n,cache:t,dir:e,gitdir:i=m.join(e,".git"),oids:r}){const s=new B,a=[];function o(c,h){const u=Buffer.from(c,h);a.push(u),s.update(u)}async function f({stype:c,object:h}){const u=Va[c];let d=h.length,y=d>15?128:0;const b=d&15;d=d>>>4;let _=(y|u|b).toString(16);for(o(_,"hex");y;)y=d>127?128:0,_=y|d&127,o(fi(2,_),"hex"),d=d>>>7;o(Buffer.from(await sn(h)))}o("PACK"),o("00000002","hex"),o(fi(8,r.length),"hex");for(const c of r){const{type:h,object:u}=await tt({fs:n,cache:t,gitdir:i,oid:c});await f({object:u,stype:h})}const l=s.digest();return a.push(l),a}async function Xa({fs:n,cache:t,gitdir:e,oids:i,write:r}){const s=await mr({fs:n,cache:t,gitdir:e,oids:i}),a=Buffer.from(await He(s)),f=`pack-${a.slice(-20).toString("hex")}.pack`;return r?(await n.write(m.join(e,`objects/pack/${f}`),a),{filename:f}):{filename:f,packfile:new Uint8Array(a)}}async function pr({fs:n,dir:t,gitdir:e=m.join(t,".git"),oids:i,write:r=!1,cache:s={}}){try{return w("fs",n),w("gitdir",e),w("oids",i),await Xa({fs:new z(n),cache:s,gitdir:e,oids:i,write:r})}catch(a){throw a.caller="git.packObjects",a}}async function yr({fs:n,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:f=m.join(o,".git"),ref:l,url:c,remote:h,remoteRef:u,prune:d=!1,pruneTags:y=!1,fastForward:b=!0,fastForwardOnly:_=!1,corsProxy:k,singleBranch:v,headers:O={},author:F,committer:q,signingKey:N,cache:$={}}){try{w("fs",n),w("gitdir",f);const E=new z(n),C=await At({fs:E,gitdir:f,author:F});if(!C)throw new ut("author");const W=await ne({fs:E,gitdir:f,author:C,committer:q});if(!W)throw new ut("committer");return await Un({fs:E,cache:$,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:f,ref:l,url:c,remote:h,remoteRef:u,fastForward:b,fastForwardOnly:_,corsProxy:k,singleBranch:v,headers:O,author:C,committer:W,signingKey:N,prune:d,pruneTags:y})}catch(E){throw E.caller="git.pull",E}}async function Ya({fs:n,cache:t,dir:e,gitdir:i=m.join(e,".git"),start:r,finish:s}){const a=await je.read({fs:n,gitdir:i}),o=new Set,f=new Set;for(const h of r)o.add(await S.resolve({fs:n,gitdir:i,ref:h}));for(const h of s)try{const u=await S.resolve({fs:n,gitdir:i,ref:h});f.add(u)}catch{}const l=new Set;async function c(h){l.add(h);const{type:u,object:d}=await tt({fs:n,cache:t,gitdir:i,oid:h});if(u==="tag"){const b=wt.from(d).headers().object;return c(b)}if(u!=="commit")throw new dt(h,u,"commit");if(!a.has(h)){const b=et.from(d).headers().parent;for(h of b)!f.has(h)&&!l.has(h)&&await c(h)}}for(const h of o)await c(h);return l}async function pi({fs:n,cache:t,dir:e,gitdir:i=m.join(e,".git"),oids:r}){const s=new Set;async function a(o){if(s.has(o))return;s.add(o);const{type:f,object:l}=await tt({fs:n,cache:t,gitdir:i,oid:o});if(f==="tag"){const h=wt.from(l).headers().object;await a(h)}else if(f==="commit"){const h=et.from(l).headers().tree;await a(h)}else if(f==="tree"){const c=mt.from(l);for(const h of c)h.type==="blob"&&s.add(h.oid),h.type==="tree"&&await a(h.oid)}}for(const o of r)await a(o);return s}async function Za(n){const t={};let e="";const i=nt.streamReader(n);let r=await i();for(;r!==!0;)r!==null&&(e+=r.toString("utf8")+`
`),r=await i();const s=e.toString("utf8").split(`
`);if(r=s.shift(),!r.startsWith("unpack "))throw new Ft('unpack ok" or "unpack [error message]',r);t.ok=r==="unpack ok",t.ok||(t.error=r.slice(7)),t.refs={};for(const a of s){if(a.trim()==="")continue;const o=a.slice(0,2),f=a.slice(3);let l=f.indexOf(" ");l===-1&&(l=f.length);const c=f.slice(0,l),h=f.slice(l+1);t.refs[c]={ok:o==="ok",error:h}}return t}async function Qa({capabilities:n=[],triplets:t=[]}){const e=[];let i=`\0 ${n.join(" ")}`;for(const r of t)e.push(nt.encode(`${r.oldoid} ${r.oid} ${r.fullRef}${i}
`)),i="";return e.push(nt.flush()),e}async function Ja({fs:n,cache:t,http:e,onProgress:i,onMessage:r,onAuth:s,onAuthSuccess:a,onAuthFailure:o,onPrePush:f,gitdir:l,ref:c,remoteRef:h,remote:u,url:d,force:y=!1,delete:b=!1,corsProxy:_,headers:k={}}){const v=c||await Dt({fs:n,gitdir:l});if(typeof v>"u")throw new pt("ref");const O=await rt.get({fs:n,gitdir:l});u=u||await O.get(`branch.${v}.pushRemote`)||await O.get("remote.pushDefault")||await O.get(`branch.${v}.remote`)||"origin";const F=d||await O.get(`remote.${u}.pushurl`)||await O.get(`remote.${u}.url`);if(typeof F>"u")throw new pt("remote OR url");const q=h||await O.get(`branch.${v}.merge`);if(typeof F>"u")throw new pt("remoteRef");_===void 0&&(_=await O.get("http.corsProxy"));const N=await S.expand({fs:n,gitdir:l,ref:v}),$=b?"0000000000000000000000000000000000000000":await S.resolve({fs:n,gitdir:l,ref:N}),E=qe.getRemoteHelperFor({url:F}),C=await E.discover({http:e,onAuth:s,onAuthSuccess:a,onAuthFailure:o,corsProxy:_,service:"git-receive-pack",url:F,headers:k,protocolVersion:1}),W=C.auth;let X;if(!q)X=N;else try{X=await S.expandAgainstMap({ref:q,map:C.refs})}catch(it){if(it instanceof Q)X=q.startsWith("refs/")?q:`refs/heads/${q}`;else throw it}const at=C.refs.get(X)||"0000000000000000000000000000000000000000";if(f&&!await f({remote:u,url:F,localRef:{ref:b?"(delete)":N,oid:$},remoteRef:{ref:X,oid:at}}))throw new Kt;const Y=!C.capabilities.has("no-thin");let ot=new Set;if(!b){const it=[...C.refs.values()];let $t=new Set;if(at!=="0000000000000000000000000000000000000000"){const ht=await wi({fs:n,cache:t,gitdir:l,oids:[$,at]});for(const Re of ht)it.push(Re);Y&&($t=await pi({fs:n,cache:t,gitdir:l,oids:ht}))}if(!it.includes($)){const ht=await Ya({fs:n,cache:t,gitdir:l,start:[$],finish:it});ot=await pi({fs:n,cache:t,gitdir:l,oids:ht})}if(Y){try{const ht=await S.resolve({fs:n,gitdir:l,ref:`refs/remotes/${u}/HEAD`,depth:2}),{oid:Re}=await S.resolveAgainstMap({ref:ht.replace(`refs/remotes/${u}/`,""),fullref:ht,map:C.refs}),Lt=[Re];for(const ct of await pi({fs:n,cache:t,gitdir:l,oids:Lt}))$t.add(ct)}catch{}for(const ht of $t)ot.delete(ht)}if($===at&&(y=!0),!y){if(N.startsWith("refs/tags")&&at!=="0000000000000000000000000000000000000000")throw new Jt("tag-exists");if($!=="0000000000000000000000000000000000000000"&&at!=="0000000000000000000000000000000000000000"&&!await tr({fs:n,cache:t,gitdir:l,oid:$,ancestor:at,depth:-1}))throw new Jt("not-fast-forward")}}const lt=En([...C.capabilities],["report-status","side-band-64k",`agent=${Le.agent}`]),zt=await Qa({capabilities:lt,triplets:[{oldoid:at,oid:$,fullRef:X}]}),qt=b?[]:await mr({fs:n,cache:t,gitdir:l,oids:[...ot]}),oe=await E.connect({http:e,onProgress:i,corsProxy:_,service:"git-receive-pack",url:F,auth:W,headers:k,body:[...zt,...qt]}),{packfile:bi,progress:_i}=await Rn.demux(oe.body);if(r){const it=jn(_i);Ee(it,async $t=>{await r($t)})}const _t=await Za(bi);if(oe.headers&&(_t.headers=oe.headers),u&&_t.ok&&_t.refs[X].ok&&!N.startsWith("refs/tags")){const it=`refs/remotes/${u}/${X.replace("refs/heads","")}`;b?await S.deleteRef({fs:n,gitdir:l,ref:it}):await S.writeRef({fs:n,gitdir:l,ref:it,value:$})}if(_t.ok&&Object.values(_t.refs).every(it=>it.ok))return _t;{const it=Object.entries(_t.refs).filter(([$t,ht])=>!ht.ok).map(([$t,ht])=>`
  - ${$t}: ${ht.error}`).join("");throw new me(it,_t)}}async function gr({fs:n,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,onPrePush:o,dir:f,gitdir:l=m.join(f,".git"),ref:c,remoteRef:h,remote:u="origin",url:d,force:y=!1,delete:b=!1,corsProxy:_,headers:k={},cache:v={}}){try{return w("fs",n),w("http",t),w("gitdir",l),await Ja({fs:new z(n),cache:v,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,onPrePush:o,gitdir:l,ref:c,remoteRef:h,remote:u,url:d,force:y,delete:b,corsProxy:_,headers:k})}catch(O){throw O.caller="git.push",O}}async function br({fs:n,cache:t,gitdir:e,oid:i}){const{type:r,object:s}=await tt({fs:n,cache:t,gitdir:e,oid:i});if(r==="tag")return i=wt.from(s).parse().object,br({fs:n,cache:t,gitdir:e,oid:i});if(r!=="blob")throw new dt(i,r,"blob");return{oid:i,blob:new Uint8Array(s)}}async function _r({fs:n,cache:t,gitdir:e,oid:i,filepath:r=void 0}){return r!==void 0&&(i=await $e({fs:n,cache:t,gitdir:e,oid:i,filepath:r})),await br({fs:n,cache:t,gitdir:e,oid:i})}async function kr({fs:n,dir:t,gitdir:e=m.join(t,".git"),oid:i,filepath:r,cache:s={}}){try{return w("fs",n),w("gitdir",e),w("oid",i),await _r({fs:new z(n),cache:s,gitdir:e,oid:i,filepath:r})}catch(a){throw a.caller="git.readBlob",a}}async function yi({fs:n,dir:t,gitdir:e=m.join(t,".git"),oid:i,cache:r={}}){try{return w("fs",n),w("gitdir",e),w("oid",i),await re({fs:new z(n),cache:r,gitdir:e,oid:i})}catch(s){throw s.caller="git.readCommit",s}}async function Ka({fs:n,cache:t,gitdir:e,ref:i="refs/notes/commits",oid:r}){const s=await S.resolve({gitdir:e,fs:n,ref:i}),{blob:a}=await _r({fs:n,cache:t,gitdir:e,oid:s,filepath:r});return a}async function vr({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i="refs/notes/commits",oid:r,cache:s={}}){try{return w("fs",n),w("gitdir",e),w("ref",i),w("oid",r),await Ka({fs:new z(n),cache:s,gitdir:e,ref:i,oid:r})}catch(a){throw a.caller="git.readNote",a}}async function Sr({fs:n,dir:t,gitdir:e=m.join(t,".git"),oid:i,format:r="parsed",filepath:s=void 0,encoding:a=void 0,cache:o={}}){try{w("fs",n),w("gitdir",e),w("oid",i);const f=new z(n);s!==void 0&&(i=await $e({fs:f,cache:o,gitdir:e,oid:i,filepath:s}));const c=await tt({fs:f,cache:o,gitdir:e,oid:i,format:r==="parsed"?"content":r});if(c.oid=i,r==="parsed")switch(c.format="parsed",c.type){case"commit":c.object=et.from(c.object).parse();break;case"tree":c.object=mt.from(c.object).entries();break;case"blob":a?c.object=c.object.toString(a):(c.object=new Uint8Array(c.object),c.format="content");break;case"tag":c.object=wt.from(c.object).parse();break;default:throw new dt(c.oid,c.type,"blob|commit|tag|tree")}else(c.format==="deflated"||c.format==="wrapped")&&(c.type=c.format);return c}catch(f){throw f.caller="git.readObject",f}}async function to({fs:n,cache:t,gitdir:e,oid:i}){const{type:r,object:s}=await tt({fs:n,cache:t,gitdir:e,oid:i,format:"content"});if(r!=="tag")throw new dt(i,r,"tag");const a=wt.from(s);return{oid:i,tag:a.parse(),payload:a.payload()}}async function $r({fs:n,dir:t,gitdir:e=m.join(t,".git"),oid:i,cache:r={}}){try{return w("fs",n),w("gitdir",e),w("oid",i),await to({fs:new z(n),cache:r,gitdir:e,oid:i})}catch(s){throw s.caller="git.readTag",s}}async function xr({fs:n,dir:t,gitdir:e=m.join(t,".git"),oid:i,filepath:r=void 0,cache:s={}}){try{return w("fs",n),w("gitdir",e),w("oid",i),await se({fs:new z(n),cache:s,gitdir:e,oid:i,filepath:r})}catch(a){throw a.caller="git.readTree",a}}async function Er({fs:n,dir:t,gitdir:e=m.join(t,".git"),filepath:i,cache:r={}}){try{w("fs",n),w("gitdir",e),w("filepath",i),await st.acquire({fs:new z(n),gitdir:e,cache:r},async function(s){s.delete({filepath:i})})}catch(s){throw s.caller="git.remove",s}}async function eo({fs:n,cache:t,onSign:e,gitdir:i,ref:r="refs/notes/commits",oid:s,author:a,committer:o,signingKey:f}){let l;try{l=await S.resolve({gitdir:i,fs:n,ref:r})}catch(y){if(!(y instanceof Q))throw y}let h=(await se({fs:n,gitdir:i,oid:l||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;h=h.filter(y=>y.path!==s);const u=await xe({fs:n,gitdir:i,tree:h});return await Ue({fs:n,cache:t,onSign:e,gitdir:i,ref:r,tree:u,parent:l&&[l],message:`Note removed by 'isomorphic-git removeNote'
`,author:a,committer:o,signingKey:f})}async function jr({fs:n,onSign:t,dir:e,gitdir:i=m.join(e,".git"),ref:r="refs/notes/commits",oid:s,author:a,committer:o,signingKey:f,cache:l={}}){try{w("fs",n),w("gitdir",i),w("oid",s);const c=new z(n),h=await At({fs:c,gitdir:i,author:a});if(!h)throw new ut("author");const u=await ne({fs:c,gitdir:i,author:h,committer:o});if(!u)throw new ut("committer");return await eo({fs:c,cache:l,onSign:t,gitdir:i,ref:r,oid:s,author:h,committer:u,signingKey:f})}catch(c){throw c.caller="git.removeNote",c}}async function io({fs:n,gitdir:t,oldref:e,ref:i,checkout:r=!1}){if(i!==p.clean(i))throw new St(i,p.clean(i));if(e!==p.clean(e))throw new St(e,p.clean(e));const s=`refs/heads/${e}`,a=`refs/heads/${i}`;if(await S.exists({fs:n,gitdir:t,ref:a}))throw new vt("branch",i,!1);const f=await S.resolve({fs:n,gitdir:t,ref:s,depth:1});await S.writeRef({fs:n,gitdir:t,ref:a,value:f}),await S.deleteRef({fs:n,gitdir:t,ref:s});const c=await Dt({fs:n,gitdir:t,fullname:!0})===s;(r||c)&&await S.writeSymbolicRef({fs:n,gitdir:t,ref:"HEAD",value:a})}async function Rr({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i,oldref:r,checkout:s=!1}){try{return w("fs",n),w("gitdir",e),w("ref",i),w("oldref",r),await io({fs:new z(n),gitdir:e,ref:i,oldref:r,checkout:s})}catch(a){throw a.caller="git.renameBranch",a}}async function Or({gitdir:n,type:t,object:e}){return jt(Vt.wrap({type:t,object:e}))}async function Br({fs:n,dir:t,gitdir:e=m.join(t,".git"),filepath:i,ref:r,cache:s={}}){try{w("fs",n),w("gitdir",e),w("filepath",i);const a=new z(n);let o,f;try{o=await S.resolve({fs:a,gitdir:e,ref:r||"HEAD"})}catch(h){if(r)throw h}if(o)try{o=await $e({fs:a,cache:s,gitdir:e,oid:o,filepath:i})}catch{o=null}let l={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:0,uid:0,gid:0,size:0};const c=t&&await a.read(m.join(t,i));c&&(f=await Or({gitdir:e,type:"blob",object:c}),o===f&&(l=await a.lstat(m.join(t,i)))),await st.acquire({fs:a,gitdir:e,cache:s},async function(h){h.delete({filepath:i}),o&&h.insert({filepath:i,stats:l,oid:o})})}catch(a){throw a.caller="git.reset",a}}async function Ir({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i,depth:r}){try{return w("fs",n),w("gitdir",e),w("ref",i),await S.resolve({fs:new z(n),gitdir:e,ref:i,depth:r})}catch(s){throw s.caller="git.resolveRef",s}}async function Pr({fs:n,dir:t,gitdir:e=m.join(t,".git"),path:i,value:r,append:s=!1}){try{w("fs",n),w("gitdir",e),w("path",i);const a=new z(n),o=await rt.get({fs:a,gitdir:e});s?await o.append(i,r):await o.set(i,r),await rt.save({fs:a,gitdir:e,config:o})}catch(a){throw a.caller="git.setConfig",a}}async function Tr({fs:n,gitdir:t,commit:e}){const i=et.from(e).toObject();return await yt({fs:n,gitdir:t,type:"commit",object:i,format:"content"})}class Ge{static get timezoneOffsetForRefLogEntry(){const t=new Date().getTimezoneOffset(),e=Math.abs(Math.floor(t/60)),i=Math.abs(t%60).toString().padStart(2,"0");return`${t>0?"-":"+"}${e.toString().padStart(2,"0")}${i}`}static createStashReflogEntry(t,e,i){const r=t.name.replace(/\s/g,""),s="0000000000000000000000000000000000000000",a=Math.floor(Date.now()/1e3),o=Ge.timezoneOffsetForRefLogEntry;return`${s} ${e} ${r} ${t.email} ${a} ${o}	${i}
`}static getStashReflogEntry(t,e=!1){return t.split(`
`).filter(s=>s).reverse().map((s,a)=>e?`stash@{${a}}: ${s.split("	")[1]}`:s)}}const no={stage:Mt,workdir:ee};let gi;async function ae(n,t){return gi===void 0&&(gi=new A),gi.acquire(n,t)}async function ro(n,t,e,i,r=null){const s=m.join(e,i),a=await n.lstat(s);if(!a)throw new Q(s);if(a.isDirectory())throw new M(`${s}: file expected, but found directory`);const o=r?await Li({fs:n,gitdir:t,oid:r}):void 0;let f=o?r:void 0;return o||await ae({fs:n,gitdir:t,currentFilepath:s},async()=>{const l=a.isSymbolicLink()?await n.readlink(s).then(an):await n.read(s);if(l===null)throw new Q(s);f=await yt({fs:n,gitdir:t,type:"blob",object:l})}),f}async function so({fs:n,dir:t,gitdir:e,entries:i}){async function r(s){if(s.type==="tree"){if(!s.oid){const a=await Promise.all(s.children.map(r));s.oid=await xe({fs:n,gitdir:e,tree:a}),s.mode=16384}}else s.type==="blob"&&(s.oid=await ro(n,e,t,s.path,s.oid),s.mode=33188);return s.path=s.path.split("/").pop(),s}return Promise.all(i.map(r))}async function Cr({fs:n,dir:t,gitdir:e,treePair:i}){const r=i[1]==="stage",s=i.map(d=>typeof d=="string"?no[d]():d),a=[],c=await Ct({fs:n,cache:{},dir:t,gitdir:e,trees:s,map:async(d,[y,b])=>{if(!(d==="."||await ie.isIgnored({fs:n,dir:t,gitdir:e,filepath:d}))&&b)return(!y||await y.oid()!==await b.oid()&&await b.oid()!==void 0)&&a.push([y,b]),{mode:await b.mode(),path:d,oid:await b.oid(),type:await b.type()}},reduce:async(d,y)=>(y=y.filter(Boolean),d?(d.children=y,d):y.length>0?y:void 0),iterate:async(d,y)=>{const b=[];for(const _ of y){const[k,v]=_;r?v&&(await n.exists(`${t}/${v.toString()}`)?b.push(_):a.push([null,v])):k&&(v?b.push(_):a.push([k,null]))}return b.length?Promise.all(b.map(d)):[]}});if(a.length===0||c.length===0)return null;const u=(await so({fs:n,dir:t,gitdir:e,entries:c})).filter(Boolean).map(d=>({mode:d.mode,path:d.path,oid:d.oid,type:d.type}));return xe({fs:n,gitdir:e,tree:u})}async function ao({fs:n,dir:t,gitdir:e,stashCommit:i,parentCommit:r,wasStaged:s}){const a=[],o=[],f=await Ct({fs:n,cache:{},dir:t,gitdir:e,trees:[bt({ref:r}),bt({ref:i})],map:async(l,[c,h])=>{if(l==="."||await ie.isIgnored({fs:n,dir:t,gitdir:e,filepath:l}))return;const u=h?await h.type():await c.type();if(u!=="tree"&&u!=="blob")return;if(!h&&c){const y=u==="tree"?"rmdir":"rm";return u==="tree"&&a.push(l),u==="blob"&&s&&o.push({filepath:l,oid:await c.oid()}),{method:y,filepath:l}}const d=await h.oid();if(!c||await c.oid()!==d)return u==="tree"?{method:"mkdir",filepath:l}:(s&&o.push({filepath:l,oid:d,stats:await n.lstat(m.join(t,l))}),{method:"write",filepath:l,oid:d})}});await ae({fs:n,gitdir:e,dirRemoved:a,ops:f},async()=>{for(const l of f){const c=m.join(t,l.filepath);switch(l.method){case"rmdir":await n.rmdir(c);break;case"mkdir":await n.mkdir(c);break;case"rm":await n.rm(c);break;case"write":if(!a.some(h=>c.startsWith(h))){const{object:h}=await tt({fs:n,cache:{},gitdir:e,oid:l.oid});await n.exists(c)&&await n.rm(c),await n.write(c,h)}break}}}),await st.acquire({fs:n,gitdir:e,cache:{}},async l=>{o.forEach(({filepath:c,stats:h,oid:u})=>{l.insert({filepath:c,stats:h,oid:u})})})}class Ot{constructor({fs:t,dir:e,gitdir:i=m.join(e,".git")}){Object.assign(this,{fs:t,dir:e,gitdir:i,_author:null})}static get refStash(){return"refs/stash"}static get refLogsStash(){return"logs/refs/stash"}get refStashPath(){return m.join(this.gitdir,Ot.refStash)}get refLogsStashPath(){return m.join(this.gitdir,Ot.refLogsStash)}async getAuthor(){if(!this._author&&(this._author=await At({fs:this.fs,gitdir:this.gitdir,author:{}}),!this._author))throw new ut("author");return this._author}async getStashSHA(t,e){return await this.fs.exists(this.refStashPath)?(e||await this.readStashReflogs({parsed:!1}))[t].split(" ")[1]:null}async writeStashCommit({message:t,tree:e,parent:i}){return Tr({fs:this.fs,gitdir:this.gitdir,commit:{message:t,tree:e,parent:i,author:await this.getAuthor(),committer:await this.getAuthor()}})}async readStashCommit(t){const e=await this.readStashReflogs({parsed:!1});if(t!==0&&(t<0||t>e.length-1))throw new St(`stash@${t}`,"number that is in range of [0, num of stash pushed]");const i=await this.getStashSHA(t,e);return i?re({fs:this.fs,cache:{},gitdir:this.gitdir,oid:i}):{}}async writeStashRef(t){return S.writeRef({fs:this.fs,gitdir:this.gitdir,ref:Ot.refStash,value:t})}async writeStashReflogEntry({stashCommit:t,message:e}){const i=await this.getAuthor(),r=Ge.createStashReflogEntry(i,t,e),s=this.refLogsStashPath;await ae({filepath:s,entry:r},async()=>{const a=await this.fs.exists(s)?await this.fs.read(s,"utf8"):"";await this.fs.write(s,a+r,"utf8")})}async readStashReflogs({parsed:t=!1}){if(!await this.fs.exists(this.refLogsStashPath))return[];const i=(await this.fs.read(this.refLogsStashPath)).toString();return Ge.getStashReflogEntry(i,t)}}async function oo({fs:n,dir:t,gitdir:e,message:i=""}){const r=new Ot({fs:n,dir:t,gitdir:e});await r.getAuthor();const s=await Dt({fs:n,gitdir:e,fullname:!1}),a=await S.resolve({fs:n,gitdir:e,ref:"HEAD"}),f=(await yi({fs:n,dir:t,gitdir:e,oid:a})).commit.message,l=[a];let c=null,h=bt({ref:"HEAD"});const u=await Cr({fs:n,dir:t,gitdir:e,treePair:[bt({ref:"HEAD"}),"stage"]});if(u){const _=await r.writeStashCommit({message:`stash-Index: WIP on ${s} - ${new Date().toISOString()}`,tree:u,parent:l});l.push(_),c=u,h=Mt()}const d=await Cr({fs:n,dir:t,gitdir:e,treePair:[h,"workdir"]});if(d){const _=await r.writeStashCommit({message:`stash-WorkDir: WIP on ${s} - ${new Date().toISOString()}`,tree:d,parent:[l[l.length-1]]});l.push(_),c=d}if(!c||!u&&!d)throw new Q("changes, nothing to stash");const y=(i.trim()||`WIP on ${s}`)+`: ${a.substring(0,7)} ${f}`,b=await r.writeStashCommit({message:y,tree:c,parent:l});return await r.writeStashRef(b),await r.writeStashReflogEntry({stashCommit:b,message:y}),await li({fs:n,dir:t,gitdir:e,ref:s,track:!1,force:!0}),b}async function Ar({fs:n,dir:t,gitdir:e,refIdx:i=0}){const s=await new Ot({fs:n,dir:t,gitdir:e}).readStashCommit(i),{parent:a=null}=s.commit?s.commit:{};if(!(!a||!Array.isArray(a)))for(let o=0;o<a.length-1;o++){const l=(await re({fs:n,cache:{},gitdir:e,oid:a[o+1]})).commit.message.startsWith("stash-Index");await ao({fs:n,dir:t,gitdir:e,stashCommit:a[o+1],parentCommit:a[o],wasStaged:l})}}async function Dr({fs:n,dir:t,gitdir:e,refIdx:i=0}){const r=new Ot({fs:n,dir:t,gitdir:e});if(!(await r.readStashCommit(i)).commit)return;const a=r.refStashPath;await ae(a,async()=>{await n.exists(a)&&await n.rm(a)});const o=await r.readStashReflogs({parsed:!1});if(!o.length)return;o.splice(i,1);const f=r.refLogsStashPath;await ae({reflogEntries:o,stashReflogPath:f,stashMgr:r},async()=>{if(o.length){await n.write(f,o.join(`
`),"utf8");const l=o[o.length-1].split(" ")[1];await r.writeStashRef(l)}else await n.rm(f)})}async function co({fs:n,dir:t,gitdir:e}){return new Ot({fs:n,dir:t,gitdir:e}).readStashReflogs({parsed:!0})}async function lo({fs:n,dir:t,gitdir:e}){const i=new Ot({fs:n,dir:t,gitdir:e}),r=[i.refStashPath,i.refLogsStashPath];await ae(r,async()=>{await Promise.all(r.map(async s=>{if(await n.exists(s))return n.rm(s)}))})}async function fo({fs:n,dir:t,gitdir:e,refIdx:i=0}){await Ar({fs:n,dir:t,gitdir:e,refIdx:i}),await Dr({fs:n,dir:t,gitdir:e,refIdx:i})}async function Nr({fs:n,dir:t,gitdir:e=m.join(t,".git"),op:i="push",message:r="",refIdx:s=0}){w("fs",n),w("dir",t),w("gitdir",e),w("op",i);const a={push:oo,apply:Ar,drop:Dr,list:co,clear:lo,pop:fo},o=["apply","drop","pop"];try{const f=new z(n);["refs","logs","logs/refs"].map(h=>m.join(e,h)).forEach(async h=>{await f.exists(h)||await f.mkdir(h)});const c=a[i];if(c){if(o.includes(i)&&s<0)throw new St(`stash@${s}`,"number that is in range of [0, num of stash pushed]");return await c({fs:f,dir:t,gitdir:e,message:r,refIdx:s})}throw new Error(`To be implemented: ${i}`)}catch(f){throw f.caller="git.stash",f}}async function Mr({fs:n,dir:t,gitdir:e=m.join(t,".git"),filepath:i,cache:r={}}){try{w("fs",n),w("gitdir",e),w("filepath",i);const s=new z(n);if(await ie.isIgnored({fs:s,gitdir:e,dir:t,filepath:i}))return"ignored";const o=await uo({fs:s,cache:r,gitdir:e}),f=await Fr({fs:s,cache:r,gitdir:e,tree:o,path:i}),l=await st.acquire({fs:s,gitdir:e,cache:r},async function(b){for(const _ of b)if(_.path===i)return _;return null}),c=await s.lstat(m.join(t,i)),h=f!==null,u=l!==null,d=c!==null,y=async()=>{if(u&&!Ie(l,c))return l.oid;{const b=await s.read(m.join(t,i)),_=await Or({gitdir:e,type:"blob",object:b});return u&&l.oid===_&&c.size!==-1&&st.acquire({fs:s,gitdir:e,cache:r},async function(k){k.insert({filepath:i,stats:c,oid:_})}),_}};if(!h&&!d&&!u)return"absent";if(!h&&!d&&u)return"*absent";if(!h&&d&&!u)return"*added";if(!h&&d&&u)return await y()===l.oid?"added":"*added";if(h&&!d&&!u)return"deleted";if(h&&!d&&u)return f===l.oid,"*deleted";if(h&&d&&!u)return await y()===f?"*undeleted":"*undeletemodified";if(h&&d&&u){const b=await y();return b===f?b===l.oid?"unmodified":"*unmodified":b===l.oid?"modified":"*modified"}}catch(s){throw s.caller="git.status",s}}async function Fr({fs:n,cache:t,gitdir:e,tree:i,path:r}){typeof r=="string"&&(r=r.split("/"));const s=r.shift();for(const a of i)if(a.path===s){if(r.length===0)return a.oid;const{type:o,object:f}=await tt({fs:n,cache:t,gitdir:e,oid:a.oid});if(o==="tree"){const l=mt.from(f);return Fr({fs:n,cache:t,gitdir:e,tree:l,path:r})}if(o==="blob")throw new dt(a.oid,o,"blob",r.join("/"))}return null}async function uo({fs:n,cache:t,gitdir:e}){let i;try{i=await S.resolve({fs:n,gitdir:e,ref:"HEAD"})}catch(s){if(s instanceof Q)return[]}const{tree:r}=await se({fs:n,cache:t,gitdir:e,oid:i});return r}async function Ur({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i="HEAD",filepaths:r=["."],filter:s,cache:a={},ignored:o=!1}){try{w("fs",n),w("gitdir",e),w("ref",i);const f=new z(n);return await Ct({fs:f,cache:a,dir:t,gitdir:e,trees:[bt({ref:i}),ee(),Mt()],map:async function(l,[c,h,u]){if(!c&&!u&&h&&!o&&await ie.isIgnored({fs:f,dir:t,filepath:l})||!r.some(N=>yn(l,N)))return null;if(s&&!s(l))return;const[d,y,b]=await Promise.all([c&&c.type(),h&&h.type(),u&&u.type()]),_=[d,y,b].includes("blob");if((d==="tree"||d==="special")&&!_)return;if(d==="commit")return null;if((y==="tree"||y==="special")&&!_)return;if(b==="commit")return null;if((b==="tree"||b==="special")&&!_)return;const k=d==="blob"?await c.oid():void 0,v=b==="blob"?await u.oid():void 0;let O;d!=="blob"&&y==="blob"&&b!=="blob"?O="42":y==="blob"&&(O=await h.oid());const F=[void 0,k,O,v],q=F.map(N=>F.indexOf(N));return q.shift(),[l,...q]}})}catch(f){throw f.caller="git.statusMatrix",f}}async function Hr({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i,object:r,force:s=!1}){try{w("fs",n),w("gitdir",e),w("ref",i);const a=new z(n);if(i===void 0)throw new pt("ref");i=i.startsWith("refs/tags/")?i:`refs/tags/${i}`;const o=await S.resolve({fs:a,gitdir:e,ref:r||"HEAD"});if(!s&&await S.exists({fs:a,gitdir:e,ref:i}))throw new vt("tag",i);await S.writeRef({fs:a,gitdir:e,ref:i,value:o})}catch(a){throw a.caller="git.tag",a}}async function zr({fs:n,dir:t,gitdir:e=m.join(t,".git"),cache:i={},filepath:r,oid:s,mode:a,add:o,remove:f,force:l}){try{w("fs",n),w("gitdir",e),w("filepath",r);const c=new z(n);if(f)return await st.acquire({fs:c,gitdir:e,cache:i},async function(u){if(!l){const d=await c.lstat(m.join(t,r));if(d){if(d.isDirectory())throw new Pt("directory");return}}u.has({filepath:r})&&u.delete({filepath:r})});let h;if(!s){if(h=await c.lstat(m.join(t,r)),!h)throw new Q(`file at "${r}" on disk and "remove" not set`);if(h.isDirectory())throw new Pt("directory")}return await st.acquire({fs:c,gitdir:e,cache:i},async function(u){if(!o&&!u.has({filepath:r}))throw new Q(`file at "${r}" in index and "add" not set`);let d;if(s)d={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:a,uid:0,gid:0,size:0};else{d=h;const y=d.isSymbolicLink()?await c.readlink(m.join(t,r)):await c.read(m.join(t,r));s=await yt({fs:c,gitdir:e,type:"blob",format:"content",object:y})}return u.insert({filepath:r,oid:s,stats:d}),s})}catch(c){throw c.caller="git.updateIndex",c}}function qr(){try{return Le.version}catch(n){throw n.caller="git.version",n}}async function Lr({fs:n,dir:t,gitdir:e=m.join(t,".git"),trees:i,map:r,reduce:s,iterate:a,cache:o={}}){try{return w("fs",n),w("gitdir",e),w("trees",i),await Ct({fs:new z(n),cache:o,dir:t,gitdir:e,trees:i,map:r,reduce:s,iterate:a})}catch(f){throw f.caller="git.walk",f}}async function Wr({fs:n,dir:t,gitdir:e=m.join(t,".git"),blob:i}){try{return w("fs",n),w("gitdir",e),w("blob",i),await yt({fs:new z(n),gitdir:e,type:"blob",object:i,format:"content"})}catch(r){throw r.caller="git.writeBlob",r}}async function Gr({fs:n,dir:t,gitdir:e=m.join(t,".git"),commit:i}){try{return w("fs",n),w("gitdir",e),w("commit",i),await Tr({fs:new z(n),gitdir:e,commit:i})}catch(r){throw r.caller="git.writeCommit",r}}async function Vr({fs:n,dir:t,gitdir:e=m.join(t,".git"),type:i,object:r,format:s="parsed",oid:a,encoding:o=void 0}){try{const f=new z(n);if(s==="parsed"){switch(i){case"commit":r=et.from(r).toObject();break;case"tree":r=mt.from(r).toObject();break;case"blob":r=Buffer.from(r,o);break;case"tag":r=wt.from(r).toObject();break;default:throw new dt(a||"",i,"blob|commit|tag|tree")}s="content"}return a=await yt({fs:f,gitdir:e,type:i,object:r,oid:a,format:s}),a}catch(f){throw f.caller="git.writeObject",f}}async function Xr({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i,value:r,force:s=!1,symbolic:a=!1}){try{w("fs",n),w("gitdir",e),w("ref",i),w("value",r);const o=new z(n);if(i!==p.clean(i))throw new St(i,p.clean(i));if(!s&&await S.exists({fs:o,gitdir:e,ref:i}))throw new vt("ref",i);a?await S.writeSymbolicRef({fs:o,gitdir:e,ref:i,value:r}):(r=await S.resolve({fs:o,gitdir:e,ref:r}),await S.writeRef({fs:o,gitdir:e,ref:i,value:r}))}catch(o){throw o.caller="git.writeRef",o}}async function ho({fs:n,gitdir:t,tag:e}){const i=wt.from(e).toObject();return await yt({fs:n,gitdir:t,type:"tag",object:i,format:"content"})}async function Yr({fs:n,dir:t,gitdir:e=m.join(t,".git"),tag:i}){try{return w("fs",n),w("gitdir",e),w("tag",i),await ho({fs:new z(n),gitdir:e,tag:i})}catch(r){throw r.caller="git.writeTag",r}}async function Zr({fs:n,dir:t,gitdir:e=m.join(t,".git"),tree:i}){try{return w("fs",n),w("gitdir",e),w("tree",i),await xe({fs:new z(n),gitdir:e,tree:i})}catch(r){throw r.caller="git.writeTree",r}}var wo={Errors:Qi,STAGE:Mt,TREE:bt,WORKDIR:ee,add:on,abortMerge:rn,addNote:hn,addRemote:wn,annotatedTag:mn,branch:pn,checkout:li,clone:Bn,commit:In,getConfig:Gn,getConfigAll:Vn,setConfig:Pr,currentBranch:Pn,deleteBranch:Tn,deleteRef:Cn,deleteRemote:An,deleteTag:Dn,expandOid:Nn,expandRef:Mn,fastForward:Hn,fetch:zn,findMergeBase:qn,findRoot:Wn,getRemoteInfo:Xn,getRemoteInfo2:Zn,hashBlob:Qn,indexPack:Jn,init:Kn,isDescendent:er,isIgnored:ir,listBranches:nr,listFiles:sr,listNotes:ar,listRefs:or,listRemotes:cr,listServerRefs:lr,listTags:fr,log:dr,merge:wr,packObjects:pr,pull:yr,push:gr,readBlob:kr,readCommit:yi,readNote:vr,readObject:Sr,readTag:$r,readTree:xr,remove:Er,removeNote:jr,renameBranch:Rr,resetIndex:Br,updateIndex:zr,resolveRef:Ir,status:Mr,statusMatrix:Ur,tag:Hr,version:qr,walk:Lr,writeBlob:Wr,writeCommit:Gr,writeObject:Vr,writeRef:Xr,writeTag:Yr,writeTree:Zr,stash:Nr};return T.Errors=Qi,T.STAGE=Mt,T.TREE=bt,T.WORKDIR=ee,T.abortMerge=rn,T.add=on,T.addNote=hn,T.addRemote=wn,T.annotatedTag=mn,T.branch=pn,T.checkout=li,T.clone=Bn,T.commit=In,T.currentBranch=Pn,T.default=wo,T.deleteBranch=Tn,T.deleteRef=Cn,T.deleteRemote=An,T.deleteTag=Dn,T.expandOid=Nn,T.expandRef=Mn,T.fastForward=Hn,T.fetch=zn,T.findMergeBase=qn,T.findRoot=Wn,T.getConfig=Gn,T.getConfigAll=Vn,T.getRemoteInfo=Xn,T.getRemoteInfo2=Zn,T.hashBlob=Qn,T.indexPack=Jn,T.init=Kn,T.isDescendent=er,T.isIgnored=ir,T.listBranches=nr,T.listFiles=sr,T.listNotes=ar,T.listRefs=or,T.listRemotes=cr,T.listServerRefs=lr,T.listTags=fr,T.log=dr,T.merge=wr,T.packObjects=pr,T.pull=yr,T.push=gr,T.readBlob=kr,T.readCommit=yi,T.readNote=vr,T.readObject=Sr,T.readTag=$r,T.readTree=xr,T.remove=Er,T.removeNote=jr,T.renameBranch=Rr,T.resetIndex=Br,T.resolveRef=Ir,T.setConfig=Pr,T.stash=Nr,T.status=Mr,T.statusMatrix=Ur,T.tag=Hr,T.updateIndex=zr,T.version=qr,T.walk=Lr,T.writeBlob=Wr,T.writeCommit=Gr,T.writeObject=Vr,T.writeRef=Xr,T.writeTag=Yr,T.writeTree=Zr,T}var Xo=Vo();const fc=fs(Xo);export{ac as F,fc as g};
