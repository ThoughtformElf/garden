import{g as go,a as hs}from"./chunk-eruda-DZQ4cb5h.js";import{z as bo,A as _o,C as ko,D as vo,F as So,H as $o,J as xo,K as Eo,L as jo,B as U,y as Kr,O as Ro,Q as Oo,R as Io}from"./chunk-vendor-C79EppbU.js";var $i,ts;function Di(){if(ts)return $i;ts=1;function T(g){if(g.length===0)return".";let p=m(g);return p=p.reduce(x,[]),I(...p)}function B(...g){let p="";for(let H of g)H.startsWith("/")?p=H:p=T(I(p,H));return p}function I(...g){if(g.length===0)return"";let p=g.join("/");return p=p.replace(/\/{2,}/g,"/"),p}function m(g){if(g.length===0)return[];if(g==="/")return["/"];let p=g.split("/");return p[p.length-1]===""&&p.pop(),g[0]==="/"?p[0]="/":p[0]!=="."&&p.unshift("."),p}function P(g){const p=g.lastIndexOf("/");if(p===-1)throw new Error(`Cannot get dirname of "${g}"`);return p===0?"/":g.slice(0,p)}function D(g){if(g==="/")throw new Error(`Cannot get basename of "${g}"`);const p=g.lastIndexOf("/");return p===-1?g:g.slice(p+1)}function x(g,p){if(g.length===0)return g.push(p),g;if(p===".")return g;if(p===".."){if(g.length===1){if(g[0]==="/")throw new Error("Unable to normalize path - traverses above root directory");if(g[0]===".")return g.push(p),g}return g[g.length-1]===".."?(g.push(".."),g):(g.pop(),g)}return g.push(p),g}return $i={join:I,normalize:T,split:m,basename:D,dirname:P,resolve:B},$i}var xi,es;function ds(){if(es)return xi;es=1;function T(g){return class extends Error{constructor(...p){super(...p),this.code=g,this.message?this.message=g+": "+this.message:this.message=g}}}const B=T("EEXIST"),I=T("ENOENT"),m=T("ENOTDIR"),P=T("ENOTEMPTY"),D=T("ETIMEDOUT"),x=T("EISDIR");return xi={EEXIST:B,ENOENT:I,ENOTDIR:m,ENOTEMPTY:P,ETIMEDOUT:D,EISDIR:x},xi}var Ei,is;function Po(){if(is)return Ei;is=1;const T=Di(),{EEXIST:B,ENOENT:I,ENOTDIR:m,ENOTEMPTY:P,EISDIR:D}=ds(),x=0;return Ei=class{constructor(){}_makeRoot(p=new Map){return p.set(x,{mode:511,type:"dir",size:0,ino:0,mtimeMs:Date.now()}),p}activate(p=null){p===null?this._root=new Map([["/",this._makeRoot()]]):typeof p=="string"?this._root=new Map([["/",this._makeRoot(this.parse(p))]]):this._root=p}get activated(){return!!this._root}deactivate(){this._root=void 0}size(){return this._countInodes(this._root.get("/"))-1}_countInodes(p){let H=1;for(let[j,W]of p)j!==x&&(H+=this._countInodes(W));return H}autoinc(){return this._maxInode(this._root.get("/"))+1}_maxInode(p){let H=p.get(x).ino;for(let[j,W]of p)j!==x&&(H=Math.max(H,this._maxInode(W)));return H}print(p=this._root.get("/")){let H="";const j=(W,M)=>{for(let[R,z]of W){if(R===0)continue;let V=z.get(x),X=V.mode.toString(8);H+=`${"	".repeat(M)}${R}	${X}`,V.type==="file"?H+=`	${V.size}	${V.mtimeMs}
`:(H+=`
`,j(z,M+1))}};return j(p,0),H}parse(p){let H=0;function j(z){const V=++H,X=z.length===1?"dir":"file";let[tt,Q,bt]=z;return tt=parseInt(tt,8),Q=Q?parseInt(Q):0,bt=bt?parseInt(bt):Date.now(),new Map([[x,{mode:tt,type:X,size:Q,mtimeMs:bt,ino:V}]])}let W=p.trim().split(`
`),M=this._makeRoot(),R=[{indent:-1,node:M},{indent:0,node:null}];for(let z of W){let X=z.match(/^\t*/)[0].length;z=z.slice(X);let[tt,...Q]=z.split("	"),bt=j(Q);if(X<=R[R.length-1].indent)for(;X<=R[R.length-1].indent;)R.pop();R.push({indent:X,node:bt}),R[R.length-2].node.set(tt,bt)}return M}_lookup(p,H=!0){let j=this._root,W="/",M=T.split(p);for(let R=0;R<M.length;++R){let z=M[R];if(j=j.get(z),!j)throw new I(p);if(H||R<M.length-1){const V=j.get(x);if(V.type==="symlink"){let X=T.resolve(W,V.target);j=this._lookup(X)}W?W=T.join(W,z):W=z}}return j}mkdir(p,{mode:H}){if(p==="/")throw new B;let j=this._lookup(T.dirname(p)),W=T.basename(p);if(j.has(W))throw new B;let M=new Map,R={mode:H,type:"dir",size:0,mtimeMs:Date.now(),ino:this.autoinc()};M.set(x,R),j.set(W,M)}rmdir(p){let H=this._lookup(p);if(H.get(x).type!=="dir")throw new m;if(H.size>1)throw new P;let j=this._lookup(T.dirname(p)),W=T.basename(p);j.delete(W)}readdir(p){let H=this._lookup(p);if(H.get(x).type!=="dir")throw new m;return[...H.keys()].filter(j=>typeof j=="string")}writeStat(p,H,{mode:j}){let W,M;try{M=this.stat(p)}catch{}if(M!==void 0){if(M.type==="dir")throw new D;j==null&&(j=M.mode),W=M.ino}j==null&&(j=438),W==null&&(W=this.autoinc());let R=this._lookup(T.dirname(p)),z=T.basename(p),V={mode:j,type:"file",size:H,mtimeMs:Date.now(),ino:W},X=new Map;return X.set(x,V),R.set(z,X),V}unlink(p){let H=this._lookup(T.dirname(p)),j=T.basename(p);H.delete(j)}rename(p,H){let j=T.basename(H),W=this._lookup(p);this._lookup(T.dirname(H)).set(j,W),this.unlink(p)}stat(p){return this._lookup(p).get(x)}lstat(p){return this._lookup(p,!1).get(x)}readlink(p){return this._lookup(p,!1).get(x).target}symlink(p,H){let j,W;try{let X=this.stat(H);W===null&&(W=X.mode),j=X.ino}catch{}W==null&&(W=40960),j==null&&(j=this.autoinc());let M=this._lookup(T.dirname(H)),R=T.basename(H),z={mode:W,type:"symlink",target:p,size:0,mtimeMs:Date.now(),ino:j},V=new Map;return V.set(x,z),M.set(R,V),z}_du(p){let H=0;for(const[j,W]of p.entries())j===x?H+=W.size:H+=this._du(W);return H}du(p){let H=this._lookup(p);return this._du(H)}},Ei}class ws{constructor(B="keyval-store",I="keyval"){this.storeName=I,this._dbName=B,this._storeName=I,this._init()}_init(){this._dbp||(this._dbp=new Promise((B,I)=>{const m=indexedDB.open(this._dbName);m.onerror=()=>I(m.error),m.onsuccess=()=>B(m.result),m.onupgradeneeded=()=>{m.result.createObjectStore(this._storeName)}}))}_withIDBStore(B,I){return this._init(),this._dbp.then(m=>new Promise((P,D)=>{const x=m.transaction(this.storeName,B);x.oncomplete=()=>P(),x.onabort=x.onerror=()=>D(x.error),I(x.objectStore(this.storeName))}))}_close(){return this._init(),this._dbp.then(B=>{B.close(),this._dbp=void 0})}}let ji;function Gt(){return ji||(ji=new ws),ji}function To(T,B=Gt()){let I;return B._withIDBStore("readwrite",m=>{I=m.get(T)}).then(()=>I.result)}function Co(T,B,I=Gt()){return I._withIDBStore("readwrite",m=>{m.put(B,T)})}function Ao(T,B,I=Gt()){return I._withIDBStore("readwrite",m=>{const P=m.get(T);P.onsuccess=()=>{m.put(B(P.result),T)}})}function Bo(T,B=Gt()){return B._withIDBStore("readwrite",I=>{I.delete(T)})}function Do(T=Gt()){return T._withIDBStore("readwrite",B=>{B.clear()})}function No(T=Gt()){const B=[];return T._withIDBStore("readwrite",I=>{(I.openKeyCursor||I.openCursor).call(I).onsuccess=function(){this.result&&(B.push(this.result.key),this.result.continue())}}).then(()=>B)}function Mo(T=Gt()){return T._close()}const Fo=Object.freeze(Object.defineProperty({__proto__:null,Store:ws,clear:Do,close:Mo,del:Bo,get:To,keys:No,set:Co,update:Ao},Symbol.toStringTag,{value:"Module"})),ms=go(Fo);var Ri,ns;function Uo(){if(ns)return Ri;ns=1;const T=ms;return Ri=class{constructor(I,m){this._database=I,this._storename=m,this._store=new T.Store(this._database,this._storename)}saveSuperblock(I){return T.set("!root",I,this._store)}loadSuperblock(){return T.get("!root",this._store)}readFile(I){return T.get(I,this._store)}writeFile(I,m){return T.set(I,m,this._store)}unlink(I){return T.del(I,this._store)}wipe(){return T.clear(this._store)}close(){return T.close(this._store)}},Ri}var Oi,rs;function Ho(){return rs||(rs=1,Oi=class{constructor(B){this._url=B}loadSuperblock(){return fetch(this._url+"/.superblock.txt").then(B=>B.ok?B.text():null)}async readFile(B){const I=await fetch(this._url+B);if(I.status===200)return I.arrayBuffer();throw new Error("ENOENT")}async sizeFile(B){const I=await fetch(this._url+B,{method:"HEAD"});if(I.status===200)return I.headers.get("content-length");throw new Error("ENOENT")}}),Oi}var Ii,ss;function zo(){if(ss)return Ii;ss=1;const T=ms,B=I=>new Promise(m=>setTimeout(m,I));return Ii=class{constructor(m,P){this._id=Math.random(),this._database=m,this._storename=P,this._store=new T.Store(this._database,this._storename),this._lock=null}async has({margin:m=2e3}={}){if(this._lock&&this._lock.holder===this._id){const P=Date.now();return this._lock.expires>P+m?!0:await this.renew()}else return!1}async renew({ttl:m=5e3}={}){let P;return await T.update("lock",D=>{const g=Date.now()+m;return P=D&&D.holder===this._id,this._lock=P?{holder:this._id,expires:g}:D,this._lock},this._store),P}async acquire({ttl:m=5e3}={}){let P,D,x;if(await T.update("lock",g=>{const p=Date.now(),H=p+m;return D=g&&g.expires<p,P=g===void 0||D,x=g&&g.holder===this._id,this._lock=P?{holder:this._id,expires:H}:g,this._lock},this._store),x)throw new Error("Mutex double-locked");return P}async wait({interval:m=100,limit:P=6e3,ttl:D}={}){for(;P--;){if(await this.acquire({ttl:D}))return!0;await B(m)}throw new Error("Mutex timeout")}async release({force:m=!1}={}){let P,D,x;if(await T.update("lock",g=>(P=m||g&&g.holder===this._id,D=g===void 0,x=g&&g.holder!==this._id,this._lock=P?void 0:g,this._lock),this._store),await T.close(this._store),!P&&!m){if(D)throw new Error("Mutex double-freed");if(x)throw new Error("Mutex lost ownership")}return P}},Ii}var Pi,as;function qo(){return as||(as=1,Pi=class{constructor(B){this._id=Math.random(),this._database=B,this._has=!1,this._release=null}async has(){return this._has}async acquire(){return new Promise(B=>{navigator.locks.request(this._database+"_lock",{ifAvailable:!0},I=>(this._has=!!I,B(!!I),new Promise(m=>{this._release=m})))})}async wait({timeout:B=6e5}={}){return new Promise((I,m)=>{const P=new AbortController;setTimeout(()=>{P.abort(),m(new Error("Mutex timeout"))},B),navigator.locks.request(this._database+"_lock",{signal:P.signal},D=>(this._has=!!D,I(!!D),new Promise(x=>{this._release=x})))})}async release({force:B=!1}={}){this._has=!1,this._release?this._release():B&&navigator.locks.request(this._database+"_lock",{steal:!0},I=>!0)}}),Pi}var Ti,os;function Lo(){if(os)return Ti;os=1;const{encode:T,decode:B}=bo(),I=_o(),m=Po(),{ENOENT:P,ENOTEMPTY:D,ETIMEDOUT:x}=ds(),g=Uo(),p=Ho(),H=zo(),j=qo(),W=Di();return Ti=class{constructor(){this.saveSuperblock=I(()=>{this.flush()},500)}async init(R,{wipe:z,url:V,urlauto:X,fileDbName:tt=R,db:Q=null,fileStoreName:bt=R+"_files",lockDbName:jt=R+"_lock",lockStoreName:Ye=R+"_lock"}={}){this._name=R,this._idb=Q||new g(tt,bt),this._mutex=navigator.locks?new j(R):new H(jt,Ye),this._cache=new m(R),this._opts={wipe:z,url:V},this._needsWipe=!!z,V&&(this._http=new p(V),this._urlauto=!!X)}async activate(){if(this._cache.activated)return;this._needsWipe&&(this._needsWipe=!1,await this._idb.wipe(),await this._mutex.release({force:!0})),await this._mutex.has()||await this._mutex.wait();const R=await this._idb.loadSuperblock();if(R)this._cache.activate(R);else if(this._http){const z=await this._http.loadSuperblock();this._cache.activate(z),await this._saveSuperblock()}else this._cache.activate();if(!await this._mutex.has())throw new x}async deactivate(){await this._mutex.has()&&await this._saveSuperblock(),this._cache.deactivate();try{await this._mutex.release()}catch(R){console.log(R)}await this._idb.close()}async _saveSuperblock(){this._cache.activated&&(this._lastSavedAt=Date.now(),await this._idb.saveSuperblock(this._cache._root))}_writeStat(R,z,V){let X=W.split(W.dirname(R)),tt=X.shift();for(let Q of X){tt=W.join(tt,Q);try{this._cache.mkdir(tt,{mode:511})}catch{}}return this._cache.writeStat(R,z,V)}async readFile(R,z){const V=typeof z=="string"?z:z&&z.encoding;if(V&&V!=="utf8")throw new Error('Only "utf8" encoding is supported in readFile');let X=null,tt=null;try{tt=this._cache.stat(R),X=await this._idb.readFile(tt.ino)}catch(Q){if(!this._urlauto)throw Q}if(!X&&this._http){let Q=this._cache.lstat(R);for(;Q.type==="symlink";)R=W.resolve(W.dirname(R),Q.target),Q=this._cache.lstat(R);X=await this._http.readFile(R)}if(X&&((!tt||tt.size!=X.byteLength)&&(tt=await this._writeStat(R,X.byteLength,{mode:tt?tt.mode:438}),this.saveSuperblock()),V==="utf8"?X=B(X):X.toString=()=>B(X)),!tt)throw new P(R);return X}async writeFile(R,z,V){const{mode:X,encoding:tt="utf8"}=V;if(typeof z=="string"){if(tt!=="utf8")throw new Error('Only "utf8" encoding is supported in writeFile');z=T(z)}const Q=await this._cache.writeStat(R,z.byteLength,{mode:X});await this._idb.writeFile(Q.ino,z)}async unlink(R,z){const V=this._cache.lstat(R);this._cache.unlink(R),V.type!=="symlink"&&await this._idb.unlink(V.ino)}readdir(R,z){return this._cache.readdir(R)}mkdir(R,z){const{mode:V=511}=z;this._cache.mkdir(R,{mode:V})}rmdir(R,z){if(R==="/")throw new D;this._cache.rmdir(R)}rename(R,z){this._cache.rename(R,z)}stat(R,z){return this._cache.stat(R)}lstat(R,z){return this._cache.lstat(R)}readlink(R,z){return this._cache.readlink(R)}symlink(R,z){this._cache.symlink(R,z)}async backFile(R,z){let V=await this._http.sizeFile(R);await this._writeStat(R,V,z)}du(R){return this._cache.du(R)}flush(){return this._saveSuperblock()}},Ti}var Ci,cs;function Wo(){return cs||(cs=1,Ci=class{constructor(B){this.type=B.type,this.mode=B.mode,this.size=B.size,this.ino=B.ino,this.mtimeMs=B.mtimeMs,this.ctimeMs=B.ctimeMs||B.mtimeMs,this.uid=1,this.gid=1,this.dev=1}isFile(){return this.type==="file"}isDirectory(){return this.type==="dir"}isSymbolicLink(){return this.type==="symlink"}}),Ci}var Ai,ls;function Go(){if(ls)return Ai;ls=1;const T=Lo(),B=Wo(),I=Di();function m(x,g,...p){return x=I.normalize(x),(typeof g>"u"||typeof g=="function")&&(g={}),typeof g=="string"&&(g={encoding:g}),[x,g,...p]}function P(x,g,p,...H){return x=I.normalize(x),(typeof p>"u"||typeof p=="function")&&(p={}),typeof p=="string"&&(p={encoding:p}),[x,g,p,...H]}function D(x,g,...p){return[I.normalize(x),I.normalize(g),...p]}return Ai=class{constructor(g,p={}){this.init=this.init.bind(this),this.readFile=this._wrap(this.readFile,m,!1),this.writeFile=this._wrap(this.writeFile,P,!0),this.unlink=this._wrap(this.unlink,m,!0),this.readdir=this._wrap(this.readdir,m,!1),this.mkdir=this._wrap(this.mkdir,m,!0),this.rmdir=this._wrap(this.rmdir,m,!0),this.rename=this._wrap(this.rename,D,!0),this.stat=this._wrap(this.stat,m,!1),this.lstat=this._wrap(this.lstat,m,!1),this.readlink=this._wrap(this.readlink,m,!1),this.symlink=this._wrap(this.symlink,D,!0),this.backFile=this._wrap(this.backFile,m,!0),this.du=this._wrap(this.du,m,!1),this._deactivationPromise=null,this._deactivationTimeout=null,this._activationPromise=null,this._operations=new Set,g&&this.init(g,p)}async init(...g){return this._initPromiseResolve&&await this._initPromise,this._initPromise=this._init(...g),this._initPromise}async _init(g,p={}){await this._gracefulShutdown(),this._activationPromise&&await this._deactivate(),this._backend&&this._backend.destroy&&await this._backend.destroy(),this._backend=p.backend||new T,this._backend.init&&await this._backend.init(g,p),this._initPromiseResolve&&(this._initPromiseResolve(),this._initPromiseResolve=null),p.defer||this.stat("/")}async _gracefulShutdown(){this._operations.size>0&&(this._isShuttingDown=!0,await new Promise(g=>this._gracefulShutdownResolve=g),this._isShuttingDown=!1,this._gracefulShutdownResolve=null)}_wrap(g,p,H){return async(...j)=>{j=p(...j);let W={name:g.name,args:j};this._operations.add(W);try{return await this._activate(),await g.apply(this,j)}finally{this._operations.delete(W),H&&this._backend.saveSuperblock(),this._operations.size===0&&(this._deactivationTimeout||clearTimeout(this._deactivationTimeout),this._deactivationTimeout=setTimeout(this._deactivate.bind(this),500))}}}async _activate(){this._initPromise||console.warn(new Error(`Attempted to use LightningFS ${this._name} before it was initialized.`)),await this._initPromise,this._deactivationTimeout&&(clearTimeout(this._deactivationTimeout),this._deactivationTimeout=null),this._deactivationPromise&&await this._deactivationPromise,this._deactivationPromise=null,this._activationPromise||(this._activationPromise=this._backend.activate?this._backend.activate():Promise.resolve()),await this._activationPromise}async _deactivate(){return this._activationPromise&&await this._activationPromise,this._deactivationPromise||(this._deactivationPromise=this._backend.deactivate?this._backend.deactivate():Promise.resolve()),this._activationPromise=null,this._gracefulShutdownResolve&&this._gracefulShutdownResolve(),this._deactivationPromise}async readFile(g,p){return this._backend.readFile(g,p)}async writeFile(g,p,H){return await this._backend.writeFile(g,p,H),null}async unlink(g,p){return await this._backend.unlink(g,p),null}async readdir(g,p){return this._backend.readdir(g,p)}async mkdir(g,p){return await this._backend.mkdir(g,p),null}async rmdir(g,p){return await this._backend.rmdir(g,p),null}async rename(g,p){return await this._backend.rename(g,p),null}async stat(g,p){const H=await this._backend.stat(g,p);return new B(H)}async lstat(g,p){const H=await this._backend.lstat(g,p);return new B(H)}async readlink(g,p){return this._backend.readlink(g,p)}async symlink(g,p){return await this._backend.symlink(g,p),null}async backFile(g,p){return await this._backend.backFile(g,p),null}async du(g){return this._backend.du(g)}async flush(){return this._backend.flush()}},Ai}var Bi,us;function Vo(){if(us)return Bi;us=1;const T=ko(),B=Go();function I(m,P){return typeof m=="function"&&(P=m),P=T(P),[(...x)=>P(null,...x),P]}return Bi=class{constructor(...P){this.promises=new B(...P),this.init=this.init.bind(this),this.readFile=this.readFile.bind(this),this.writeFile=this.writeFile.bind(this),this.unlink=this.unlink.bind(this),this.readdir=this.readdir.bind(this),this.mkdir=this.mkdir.bind(this),this.rmdir=this.rmdir.bind(this),this.rename=this.rename.bind(this),this.stat=this.stat.bind(this),this.lstat=this.lstat.bind(this),this.readlink=this.readlink.bind(this),this.symlink=this.symlink.bind(this),this.backFile=this.backFile.bind(this),this.du=this.du.bind(this),this.flush=this.flush.bind(this)}init(P,D){return this.promises.init(P,D)}readFile(P,D,x){const[g,p]=I(D,x);this.promises.readFile(P,D).then(g).catch(p)}writeFile(P,D,x,g){const[p,H]=I(x,g);this.promises.writeFile(P,D,x).then(p).catch(H)}unlink(P,D,x){const[g,p]=I(D,x);this.promises.unlink(P,D).then(g).catch(p)}readdir(P,D,x){const[g,p]=I(D,x);this.promises.readdir(P,D).then(g).catch(p)}mkdir(P,D,x){const[g,p]=I(D,x);this.promises.mkdir(P,D).then(g).catch(p)}rmdir(P,D,x){const[g,p]=I(D,x);this.promises.rmdir(P,D).then(g).catch(p)}rename(P,D,x){const[g,p]=I(x);this.promises.rename(P,D).then(g).catch(p)}stat(P,D,x){const[g,p]=I(D,x);this.promises.stat(P).then(g).catch(p)}lstat(P,D,x){const[g,p]=I(D,x);this.promises.lstat(P).then(g).catch(p)}readlink(P,D,x){const[g,p]=I(D,x);this.promises.readlink(P).then(g).catch(p)}symlink(P,D,x){const[g,p]=I(x);this.promises.symlink(P,D).then(g).catch(p)}backFile(P,D,x){const[g,p]=I(D,x);this.promises.backFile(P,D).then(g).catch(p)}du(P,D){const[x,g]=I(D);this.promises.du(P).then(x).catch(g)}flush(P){const[D,x]=I(P);this.promises.flush().then(D).catch(x)}},Bi}var Xo=Vo();const cc=hs(Xo);var C={},fs;function Yo(){if(fs)return C;fs=1,Object.defineProperty(C,"__esModule",{value:!0});function T(n){return n&&typeof n=="object"&&"default"in n?n.default:n}var B=T(vo()),I=T(So()),m=$o(),P=T(xo()),D=T(Eo()),x=T(Oo()),g=T(jo()),p=T(Ro()),H=T(Io());class j extends Error{constructor(t){super(t),this.caller=""}toJSON(){return{code:this.code,data:this.data,caller:this.caller,message:this.message,stack:this.stack}}fromJSON(t){const e=new j(t.message);return e.code=t.code,e.data=t.data,e.caller=t.caller,e.stack=t.stack,e}get isIsomorphicGitError(){return!0}}class W extends j{constructor(t){super(`Modifying the index is not possible because you have unmerged files: ${t.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`),this.code=this.name=W.code,this.data={filepaths:t}}}W.code="UnmergedPathsError";class M extends j{constructor(t){super(`An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${t}`),this.code=this.name=M.code,this.data={message:t}}}M.code="InternalError";class R extends j{constructor(t){super(`The filepath "${t}" contains unsafe character sequences`),this.code=this.name=R.code,this.data={filepath:t}}}R.code="UnsafeFilepathError";class z{constructor(t){this.buffer=t,this._start=0}eof(){return this._start>=this.buffer.length}tell(){return this._start}seek(t){this._start=t}slice(t){const e=this.buffer.slice(this._start,this._start+t);return this._start+=t,e}toString(t,e){const i=this.buffer.toString(t,this._start,this._start+e);return this._start+=e,i}write(t,e,i){const r=this.buffer.write(t,this._start,e,i);return this._start+=e,r}copy(t,e,i){const r=t.copy(this.buffer,this._start,e,i);return this._start+=r,r}readUInt8(){const t=this.buffer.readUInt8(this._start);return this._start+=1,t}writeUInt8(t){const e=this.buffer.writeUInt8(t,this._start);return this._start+=1,e}readUInt16BE(){const t=this.buffer.readUInt16BE(this._start);return this._start+=2,t}writeUInt16BE(t){const e=this.buffer.writeUInt16BE(t,this._start);return this._start+=2,e}readUInt32BE(){const t=this.buffer.readUInt32BE(this._start);return this._start+=4,t}writeUInt32BE(t){const e=this.buffer.writeUInt32BE(t,this._start);return this._start+=4,e}}function V(n,t){return-(n<t)||+(n>t)}function X(n,t){return V(n.path,t.path)}function tt(n){let t=n>0?n>>12:0;t!==4&&t!==8&&t!==10&&t!==14&&(t=8);let e=n&511;return e&73?e=493:e=420,t!==8&&(e=0),(t<<12)+e}const Q=2**32;function bt(n,t,e,i){if(n!==void 0&&t!==void 0)return[n,t];e===void 0&&(e=i.valueOf());const r=Math.floor(e/1e3),s=(e-r*1e3)*1e6;return[r,s]}function jt(n){const[t,e]=bt(n.ctimeSeconds,n.ctimeNanoseconds,n.ctimeMs,n.ctime),[i,r]=bt(n.mtimeSeconds,n.mtimeNanoseconds,n.mtimeMs,n.mtime);return{ctimeSeconds:t%Q,ctimeNanoseconds:e%Q,mtimeSeconds:i%Q,mtimeNanoseconds:r%Q,dev:n.dev%Q,ino:n.ino%Q,mode:tt(n.mode%Q),uid:n.uid%Q,gid:n.gid%Q,size:n.size>-1?n.size%Q:0}}function Ye(n){let t="";for(const e of new Uint8Array(n))e<16&&(t+="0"),t+=e.toString(16);return t}let Ze=null;async function Rt(n){return Ze===null&&(Ze=await ys()),Ze?Ni(n):ps(n)}function ps(n){return new I().update(n).digest("hex")}async function Ni(n){const t=await crypto.subtle.digest("SHA-1",n);return Ye(t)}async function ys(){try{return await Ni(new Uint8Array([]))==="da39a3ee5e6b4b0d3255bfef95601890afd80709"}catch{}return!1}function gs(n){return{assumeValid:!!(n&32768),extended:!!(n&16384),stage:(n&12288)>>12,nameLength:n&4095}}function bs(n){const t=n.flags;return t.extended=!1,t.nameLength=Math.min(U.from(n.path).length,4095),(t.assumeValid?32768:0)+(t.extended?16384:0)+((t.stage&3)<<12)+(t.nameLength&4095)}class Mt{constructor(t,e){this._dirty=!1,this._unmergedPaths=e||new Set,this._entries=t||new Map}_addEntry(t){if(t.flags.stage===0)t.stages=[t],this._entries.set(t.path,t),this._unmergedPaths.delete(t.path);else{let e=this._entries.get(t.path);e||(this._entries.set(t.path,t),e=t),e.stages[t.flags.stage]=t,this._unmergedPaths.add(t.path)}}static async from(t){if(U.isBuffer(t))return Mt.fromBuffer(t);if(t===null)return new Mt(null);throw new M("invalid type passed to GitIndex.from")}static async fromBuffer(t){if(t.length===0)throw new M("Index file is empty (.git/index)");const e=new Mt,i=new z(t),r=i.toString("utf8",4);if(r!=="DIRC")throw new M(`Invalid dircache magic file number: ${r}`);const s=await Rt(t.slice(0,-20)),a=t.slice(-20).toString("hex");if(a!==s)throw new M(`Invalid checksum in GitIndex buffer: expected ${a} but saw ${s}`);const o=i.readUInt32BE();if(o!==2)throw new M(`Unsupported dircache version: ${o}`);const u=i.readUInt32BE();let l=0;for(;!i.eof()&&l<u;){const c={};c.ctimeSeconds=i.readUInt32BE(),c.ctimeNanoseconds=i.readUInt32BE(),c.mtimeSeconds=i.readUInt32BE(),c.mtimeNanoseconds=i.readUInt32BE(),c.dev=i.readUInt32BE(),c.ino=i.readUInt32BE(),c.mode=i.readUInt32BE(),c.uid=i.readUInt32BE(),c.gid=i.readUInt32BE(),c.size=i.readUInt32BE(),c.oid=i.slice(20).toString("hex");const h=i.readUInt16BE();c.flags=gs(h);const f=t.indexOf(0,i.tell()+1)-i.tell();if(f<1)throw new M(`Got a path length of: ${f}`);if(c.path=i.toString("utf8",f),c.path.includes("..\\")||c.path.includes("../"))throw new R(c.path);let d=8-(i.tell()-12)%8;for(d===0&&(d=8);d--;){const y=i.readUInt8();if(y!==0)throw new M(`Expected 1-8 null characters but got '${y}' after ${c.path}`);if(i.eof())throw new M("Unexpected end of file")}c.stages=[],e._addEntry(c),l++}return e}get unmergedPaths(){return[...this._unmergedPaths]}get entries(){return[...this._entries.values()].sort(X)}get entriesMap(){return this._entries}get entriesFlat(){return[...this.entries].flatMap(t=>t.stages.length>1?t.stages.filter(e=>e):t)}*[Symbol.iterator](){for(const t of this.entries)yield t}insert({filepath:t,stats:e,oid:i,stage:r=0}){e||(e={ctimeSeconds:0,ctimeNanoseconds:0,mtimeSeconds:0,mtimeNanoseconds:0,dev:0,ino:0,mode:0,uid:0,gid:0,size:0}),e=jt(e);const s=U.from(t),a={ctimeSeconds:e.ctimeSeconds,ctimeNanoseconds:e.ctimeNanoseconds,mtimeSeconds:e.mtimeSeconds,mtimeNanoseconds:e.mtimeNanoseconds,dev:e.dev,ino:e.ino,mode:e.mode||33188,uid:e.uid,gid:e.gid,size:e.size,path:t,oid:i,flags:{assumeValid:!1,extended:!1,stage:r,nameLength:s.length<4095?s.length:4095},stages:[]};this._addEntry(a),this._dirty=!0}delete({filepath:t}){if(this._entries.has(t))this._entries.delete(t);else for(const e of this._entries.keys())e.startsWith(t+"/")&&this._entries.delete(e);this._unmergedPaths.has(t)&&this._unmergedPaths.delete(t),this._dirty=!0}clear(){this._entries.clear(),this._dirty=!0}has({filepath:t}){return this._entries.has(t)}render(){return this.entries.map(t=>`${t.mode.toString(8)} ${t.oid}    ${t.path}`).join(`
`)}static async _entryToBuffer(t){const e=U.from(t.path),i=Math.ceil((62+e.length+1)/8)*8,r=U.alloc(i),s=new z(r),a=jt(t);return s.writeUInt32BE(a.ctimeSeconds),s.writeUInt32BE(a.ctimeNanoseconds),s.writeUInt32BE(a.mtimeSeconds),s.writeUInt32BE(a.mtimeNanoseconds),s.writeUInt32BE(a.dev),s.writeUInt32BE(a.ino),s.writeUInt32BE(a.mode),s.writeUInt32BE(a.uid),s.writeUInt32BE(a.gid),s.writeUInt32BE(a.size),s.write(t.oid,20,"hex"),s.writeUInt16BE(bs(t)),s.write(t.path,e.length,"utf8"),r}async toObject(){const t=U.alloc(12),e=new z(t);e.write("DIRC",4,"utf8"),e.writeUInt32BE(2),e.writeUInt32BE(this.entriesFlat.length);let i=[];for(const o of this.entries)if(i.push(Mt._entryToBuffer(o)),o.stages.length>1)for(const u of o.stages)u&&u!==o&&i.push(Mt._entryToBuffer(u));i=await Promise.all(i);const r=U.concat(i),s=U.concat([t,r]),a=await Rt(s);return U.concat([s,U.from(a,"hex")])}}function Te(n,t,e=!0,i=!0){const r=jt(n),s=jt(t);return e&&r.mode!==s.mode||r.mtimeSeconds!==s.mtimeSeconds||r.ctimeSeconds!==s.ctimeSeconds||r.uid!==s.uid||r.gid!==s.gid||i&&r.ino!==s.ino||r.size!==s.size}let Qe=null;const Je=Symbol("IndexCache");function _s(){return{map:new Map,stats:new Map}}async function ks(n,t,e){const[i,r]=await Promise.all([n.lstat(t),n.read(t)]),s=await Mt.from(r);e.map.set(t,s),e.stats.set(t,i)}async function vs(n,t,e){const i=e.stats.get(t);if(i===void 0)return!0;if(i===null)return!1;const r=await n.lstat(t);return r===null?!1:Te(i,r)}class at{static async acquire({fs:t,gitdir:e,cache:i,allowUnmerged:r=!0},s){i[Je]||(i[Je]=_s());const a=`${e}/index`;Qe===null&&(Qe=new B({maxPending:1/0}));let o,u=[];return await Qe.acquire(a,async()=>{const l=i[Je];await vs(t,a,l)&&await ks(t,a,l);const c=l.map.get(a);if(u=c.unmergedPaths,u.length&&!r)throw new W(u);if(o=await s(c),c._dirty){const h=await c.toObject();await t.write(a,h),l.stats.set(a,await t.lstat(a)),c._dirty=!1}}),o}}function Ce(n){const t=Math.max(n.lastIndexOf("/"),n.lastIndexOf("\\"));return t>-1&&(n=n.slice(t+1)),n}function Vt(n){const t=Math.max(n.lastIndexOf("/"),n.lastIndexOf("\\"));return t===-1?".":t===0?"/":n.slice(0,t)}function Mi(n){const t=new Map,e=function(r){if(!t.has(r)){const s={type:"tree",fullpath:r,basename:Ce(r),metadata:{},children:[]};t.set(r,s),s.parent=e(Vt(r)),s.parent&&s.parent!==s&&s.parent.children.push(s)}return t.get(r)},i=function(r,s){if(!t.has(r)){const a={type:"blob",fullpath:r,basename:Ce(r),metadata:s,parent:e(Vt(r)),children:[]};a.parent&&a.parent.children.push(a),t.set(r,a)}return t.get(r)};e(".");for(const r of n)i(r.path,r);return t}function Ss(n){switch(n){case 16384:return"tree";case 33188:return"blob";case 33261:return"blob";case 40960:return"blob";case 57344:return"commit"}throw new M(`Unexpected GitTree entry mode: ${n.toString(8)}`)}class $s{constructor({fs:t,gitdir:e,cache:i}){this.treePromise=at.acquire({fs:t,gitdir:e,cache:i},async function(s){return Mi(s.entries)});const r=this;this.ConstructEntry=class{constructor(a){this._fullpath=a,this._type=!1,this._mode=!1,this._stat=!1,this._oid=!1}async type(){return r.type(this)}async mode(){return r.mode(this)}async stat(){return r.stat(this)}async content(){return r.content(this)}async oid(){return r.oid(this)}}}async readdir(t){const e=t._fullpath,r=(await this.treePromise).get(e);if(!r||r.type==="blob")return null;if(r.type!=="tree")throw new Error(`ENOTDIR: not a directory, scandir '${e}'`);const s=r.children.map(a=>a.fullpath);return s.sort(V),s}async type(t){return t._type===!1&&await t.stat(),t._type}async mode(t){return t._mode===!1&&await t.stat(),t._mode}async stat(t){if(t._stat===!1){const i=(await this.treePromise).get(t._fullpath);if(!i)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);const r=i.type==="tree"?{}:jt(i.metadata);t._type=i.type==="tree"?"tree":Ss(r.mode),t._mode=r.mode,i.type==="tree"?t._stat=void 0:t._stat=r}return t._stat}async content(t){}async oid(t){if(t._oid===!1){const i=(await this.treePromise).get(t._fullpath);t._oid=i.metadata.oid}return t._oid}}const Ae=Symbol("GitWalkSymbol");function Ft(){const n=Object.create(null);return Object.defineProperty(n,Ae,{value:function({fs:t,gitdir:e,cache:i}){return new $s({fs:t,gitdir:e,cache:i})}}),Object.freeze(n),n}class J extends j{constructor(t){super(`Could not find ${t}.`),this.code=this.name=J.code,this.data={what:t}}}J.code="NotFoundError";class wt extends j{constructor(t,e,i,r){super(`Object ${t} ${r?`at ${r}`:""}was anticipated to be a ${i} but it is a ${e}.`),this.code=this.name=wt.code,this.data={oid:t,actual:e,expected:i,filepath:r}}}wt.code="ObjectTypeError";class Pt extends j{constructor(t){super(`Expected a 40-char hex object id but saw "${t}".`),this.code=this.name=Pt.code,this.data={value:t}}}Pt.code="InvalidOidError";class le extends j{constructor(t){super(`Could not find a fetch refspec for remote "${t}". Make sure the config file has an entry like the following:
[remote "${t}"]
	fetch = +refs/heads/*:refs/remotes/origin/*
`),this.code=this.name=le.code,this.data={remote:t}}}le.code="NoRefspecError";class Be{constructor(t){if(this.refs=new Map,this.parsedConfig=[],t){let e=null;this.parsedConfig=t.trim().split(`
`).map(i=>{if(/^\s*#/.test(i))return{line:i,comment:!0};const r=i.indexOf(" ");if(i.startsWith("^")){const s=i.slice(1);return this.refs.set(e+"^{}",s),{line:i,ref:e,peeled:s}}else{const s=i.slice(0,r);return e=i.slice(r+1),this.refs.set(e,s),{line:i,ref:e,oid:s}}})}return this}static from(t){return new Be(t)}delete(t){this.parsedConfig=this.parsedConfig.filter(e=>e.ref!==t),this.refs.delete(t)}toString(){return this.parsedConfig.map(({line:t})=>t).join(`
`)+`
`}}class De{constructor({remotePath:t,localPath:e,force:i,matchPrefix:r}){Object.assign(this,{remotePath:t,localPath:e,force:i,matchPrefix:r})}static from(t){const[e,i,r,s,a]=t.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1),o=e==="+",u=r==="*";if(u!==(a==="*"))throw new M("Invalid refspec");return new De({remotePath:i,localPath:s,force:o,matchPrefix:u})}translate(t){if(this.matchPrefix){if(t.startsWith(this.remotePath))return this.localPath+t.replace(this.remotePath,"")}else if(t===this.remotePath)return this.localPath;return null}reverseTranslate(t){if(this.matchPrefix){if(t.startsWith(this.localPath))return this.remotePath+t.replace(this.localPath,"")}else if(t===this.localPath)return this.remotePath;return null}}class Ke{constructor(t=[]){this.rules=t}static from(t){const e=[];for(const i of t)e.push(De.from(i));return new Ke(e)}add(t){const e=De.from(t);this.rules.push(e)}translate(t){const e=[];for(const i of this.rules)for(const r of t){const s=i.translate(r);s&&e.push([r,s])}return e}translateOne(t){let e=null;for(const i of this.rules){const r=i.translate(t);r&&(e=r)}return e}localNamespaces(){return this.rules.filter(t=>t.matchPrefix).map(t=>t.localPath.replace(/\/$/,""))}}function xs(n,t){const e=n.replace(/\^\{\}$/,""),i=t.replace(/\^\{\}$/,""),r=-(e<i)||+(e>i);return r===0?n.endsWith("^{}")?1:-1:r}const Es=n=>{if(typeof n=="number")return n;n=n.toLowerCase();let t=parseInt(n);return n.endsWith("k")&&(t*=1024),n.endsWith("m")&&(t*=1024*1024),n.endsWith("g")&&(t*=1024*1024*1024),t},ue=n=>{if(typeof n=="boolean")return n;if(n=n.trim().toLowerCase(),n==="true"||n==="yes"||n==="on")return!0;if(n==="false"||n==="no"||n==="off")return!1;throw Error(`Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${n}`)},Fi={core:{filemode:ue,bare:ue,logallrefupdates:ue,symlinks:ue,ignorecase:ue,bigFileThreshold:Es}},js=/^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/,Rs=/^[A-Za-z0-9-.]+$/,Os=/^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/,Is=/^[A-Za-z][A-Za-z-]*$/,Ps=/^(.*?)( *[#;].*)$/,Ts=n=>{const t=js.exec(n);if(t!=null){const[e,i]=t.slice(1);return[e,i]}return null},Cs=n=>{const t=Os.exec(n);if(t!=null){const[e,i="true"]=t.slice(1),r=As(i),s=Bs(r);return[e,s]}return null},As=n=>{const t=Ps.exec(n);if(t==null)return n;const[e,i]=t.slice(1);return Ui(e)&&Ui(i)?`${e}${i}`:e},Ui=n=>(n.match(/(?:^|[^\\])"/g)||[]).length%2!==0,Bs=n=>n.split("").reduce((t,e,i,r)=>{const s=e==='"'&&r[i-1]!=="\\",a=e==="\\"&&r[i+1]==='"';return s||a?t:t+e},""),Hi=n=>n!=null?n.toLowerCase():null,ti=(n,t,e)=>[Hi(n),t,Hi(e)].filter(i=>i!=null).join("."),zi=n=>{const t=n.split("."),e=t.shift(),i=t.pop(),r=t.length?t.join("."):void 0;return{section:e,subsection:r,name:i,path:ti(e,r,i),sectionPath:ti(e,r,null),isSection:!!e}},Ds=(n,t)=>n.reduce((e,i,r)=>t(i)?r:e,-1);class ei{constructor(t){let e=null,i=null;this.parsedConfig=t?t.split(`
`).map(r=>{let s=null,a=null;const o=r.trim(),u=Ts(o),l=u!=null;if(l)[e,i]=u;else{const h=Cs(o);h!=null&&([s,a]=h)}const c=ti(e,i,s);return{line:r,isSection:l,section:e,subsection:i,name:s,value:a,path:c}}):[]}static from(t){return new ei(t)}async get(t,e=!1){const i=zi(t).path,r=this.parsedConfig.filter(s=>s.path===i).map(({section:s,name:a,value:o})=>{const u=Fi[s]&&Fi[s][a];return u?u(o):o});return e?r:r.pop()}async getall(t){return this.get(t,!0)}async getSubsections(t){return this.parsedConfig.filter(e=>e.isSection&&e.section===t).map(e=>e.subsection)}async deleteSection(t,e){this.parsedConfig=this.parsedConfig.filter(i=>!(i.section===t&&i.subsection===e))}async append(t,e){return this.set(t,e,!0)}async set(t,e,i=!1){const{section:r,subsection:s,name:a,path:o,sectionPath:u,isSection:l}=zi(t),c=Ds(this.parsedConfig,h=>h.path===o);if(e==null)c!==-1&&this.parsedConfig.splice(c,1);else if(c!==-1){const h=this.parsedConfig[c],f=Object.assign({},h,{name:a,value:e,modified:!0});i?this.parsedConfig.splice(c+1,0,f):this.parsedConfig[c]=f}else{const h=this.parsedConfig.findIndex(d=>d.path===u),f={section:r,subsection:s,name:a,value:e,modified:!0,path:o};if(Rs.test(r)&&Is.test(a))if(h>=0)this.parsedConfig.splice(h+1,0,f);else{const d={isSection:l,section:r,subsection:s,modified:!0,path:u};this.parsedConfig.push(d,f)}}}toString(){return this.parsedConfig.map(({line:t,section:e,subsection:i,name:r,value:s,modified:a=!1})=>a?r!=null&&s!=null?typeof s=="string"&&/[#;]/.test(s)?`	${r} = "${s}"`:`	${r} = ${s}`:i!=null?`[${e} "${i}"]`:`[${e}]`:t).join(`
`)}}class st{static async get({fs:t,gitdir:e}){const i=await t.read(`${e}/config`,{encoding:"utf8"});return ei.from(i)}static async save({fs:t,gitdir:e,config:i}){await t.write(`${e}/config`,i.toString(),{encoding:"utf8"})}}const Ne=n=>[`${n}`,`refs/${n}`,`refs/tags/${n}`,`refs/heads/${n}`,`refs/remotes/${n}`,`refs/remotes/${n}/HEAD`],Ns=["config","description","index","shallow","commondir"];let ii;async function Tt(n,t){return ii===void 0&&(ii=new B),ii.acquire(n,t)}class S{static async updateRemoteRefs({fs:t,gitdir:e,remote:i,refs:r,symrefs:s,tags:a,refspecs:o=void 0,prune:u=!1,pruneTags:l=!1}){for(const _ of r.values())if(!_.match(/[0-9a-f]{40}/))throw new Pt(_);const c=await st.get({fs:t,gitdir:e});if(!o){if(o=await c.getall(`remote.${i}.fetch`),o.length===0)throw new le(i);o.unshift(`+HEAD:refs/remotes/${i}/HEAD`)}const h=Ke.from(o),f=new Map;if(l){const _=await S.listRefs({fs:t,gitdir:e,filepath:"refs/tags"});await S.deleteRefs({fs:t,gitdir:e,refs:_.map(k=>`refs/tags/${k}`)})}if(a){for(const _ of r.keys())if(_.startsWith("refs/tags")&&!_.endsWith("^{}")&&!await S.exists({fs:t,gitdir:e,ref:_})){const k=r.get(_);f.set(_,k)}}const d=h.translate([...r.keys()]);for(const[_,k]of d){const v=r.get(_);f.set(k,v)}const y=h.translate([...s.keys()]);for(const[_,k]of y){const v=s.get(_),O=h.translateOne(v);O&&f.set(k,`ref: ${O}`)}const b=[];if(u){for(const _ of h.localNamespaces()){const k=(await S.listRefs({fs:t,gitdir:e,filepath:_})).map(v=>`${_}/${v}`);for(const v of k)f.has(v)||b.push(v)}b.length>0&&await S.deleteRefs({fs:t,gitdir:e,refs:b})}for(const[_,k]of f)await Tt(_,async()=>t.write(m.join(e,_),`${k.trim()}
`,"utf8"));return{pruned:b}}static async writeRef({fs:t,gitdir:e,ref:i,value:r}){if(!r.match(/[0-9a-f]{40}/))throw new Pt(r);await Tt(i,async()=>t.write(m.join(e,i),`${r.trim()}
`,"utf8"))}static async writeSymbolicRef({fs:t,gitdir:e,ref:i,value:r}){await Tt(i,async()=>t.write(m.join(e,i),`ref: ${r.trim()}
`,"utf8"))}static async deleteRef({fs:t,gitdir:e,ref:i}){return S.deleteRefs({fs:t,gitdir:e,refs:[i]})}static async deleteRefs({fs:t,gitdir:e,refs:i}){await Promise.all(i.map(o=>t.rm(m.join(e,o))));let r=await Tt("packed-refs",async()=>t.read(`${e}/packed-refs`,{encoding:"utf8"}));const s=Be.from(r),a=s.refs.size;for(const o of i)s.refs.has(o)&&s.delete(o);s.refs.size<a&&(r=s.toString(),await Tt("packed-refs",async()=>t.write(`${e}/packed-refs`,r,{encoding:"utf8"})))}static async resolve({fs:t,gitdir:e,ref:i,depth:r=void 0}){if(r!==void 0&&(r--,r===-1))return i;if(i.startsWith("ref: "))return i=i.slice(5),S.resolve({fs:t,gitdir:e,ref:i,depth:r});if(i.length===40&&/[0-9a-f]{40}/.test(i))return i;const s=await S.packedRefs({fs:t,gitdir:e}),a=Ne(i).filter(o=>!Ns.includes(o));for(const o of a){const u=await Tt(o,async()=>await t.read(`${e}/${o}`,{encoding:"utf8"})||s.get(o));if(u)return S.resolve({fs:t,gitdir:e,ref:u.trim(),depth:r})}throw new J(i)}static async exists({fs:t,gitdir:e,ref:i}){try{return await S.expand({fs:t,gitdir:e,ref:i}),!0}catch{return!1}}static async expand({fs:t,gitdir:e,ref:i}){if(i.length===40&&/[0-9a-f]{40}/.test(i))return i;const r=await S.packedRefs({fs:t,gitdir:e}),s=Ne(i);for(const a of s)if(await Tt(a,async()=>t.exists(`${e}/${a}`))||r.has(a))return a;throw new J(i)}static async expandAgainstMap({ref:t,map:e}){const i=Ne(t);for(const r of i)if(await e.has(r))return r;throw new J(t)}static resolveAgainstMap({ref:t,fullref:e=t,depth:i=void 0,map:r}){if(i!==void 0&&(i--,i===-1))return{fullref:e,oid:t};if(t.startsWith("ref: "))return t=t.slice(5),S.resolveAgainstMap({ref:t,fullref:e,depth:i,map:r});if(t.length===40&&/[0-9a-f]{40}/.test(t))return{fullref:e,oid:t};const s=Ne(t);for(const a of s){const o=r.get(a);if(o)return S.resolveAgainstMap({ref:o.trim(),fullref:a,depth:i,map:r})}throw new J(t)}static async packedRefs({fs:t,gitdir:e}){const i=await Tt("packed-refs",async()=>t.read(`${e}/packed-refs`,{encoding:"utf8"}));return Be.from(i).refs}static async listRefs({fs:t,gitdir:e,filepath:i}){const r=S.packedRefs({fs:t,gitdir:e});let s=null;try{s=await t.readdirDeep(`${e}/${i}`),s=s.map(a=>a.replace(`${e}/${i}/`,""))}catch{s=[]}for(let a of(await r).keys())a.startsWith(i)&&(a=a.replace(i+"/",""),s.includes(a)||s.push(a));return s.sort(xs),s}static async listBranches({fs:t,gitdir:e,remote:i}){return i?S.listRefs({fs:t,gitdir:e,filepath:`refs/remotes/${i}`}):S.listRefs({fs:t,gitdir:e,filepath:"refs/heads"})}static async listTags({fs:t,gitdir:e}){return(await S.listRefs({fs:t,gitdir:e,filepath:"refs/tags"})).filter(r=>!r.endsWith("^{}"))}}function Ms(n,t){return V(qi(n),qi(t))}function qi(n){return n.mode==="040000"?n.path+"/":n.path}function Li(n){switch(n){case"040000":return"tree";case"100644":return"blob";case"100755":return"blob";case"120000":return"blob";case"160000":return"commit"}throw new M(`Unexpected GitTree entry mode: ${n}`)}function Fs(n){const t=[];let e=0;for(;e<n.length;){const i=n.indexOf(32,e);if(i===-1)throw new M(`GitTree: Error parsing buffer at byte location ${e}: Could not find the next space character.`);const r=n.indexOf(0,e);if(r===-1)throw new M(`GitTree: Error parsing buffer at byte location ${e}: Could not find the next null character.`);let s=n.slice(e,i).toString("utf8");s==="40000"&&(s="040000");const a=Li(s),o=n.slice(i+1,r).toString("utf8");if(o.includes("\\")||o.includes("/"))throw new R(o);const u=n.slice(r+1,r+21).toString("hex");e=r+21,t.push({mode:s,path:o,oid:u,type:a})}return t}function Us(n){if(typeof n=="number"&&(n=n.toString(8)),n.match(/^0?4.*/))return"040000";if(n.match(/^1006.*/))return"100644";if(n.match(/^1007.*/))return"100755";if(n.match(/^120.*/))return"120000";if(n.match(/^160.*/))return"160000";throw new M(`Could not understand file mode: ${n}`)}function Hs(n){return!n.oid&&n.sha&&(n.oid=n.sha),n.mode=Us(n.mode),n.type||(n.type=Li(n.mode)),n}class pt{constructor(t){if(U.isBuffer(t))this._entries=Fs(t);else if(Array.isArray(t))this._entries=t.map(Hs);else throw new M("invalid type passed to GitTree constructor");this._entries.sort(X)}static from(t){return new pt(t)}render(){return this._entries.map(t=>`${t.mode} ${t.type} ${t.oid}    ${t.path}`).join(`
`)}toObject(){const t=[...this._entries];return t.sort(Ms),U.concat(t.map(e=>{const i=U.from(e.mode.replace(/^0/,"")),r=U.from(" "),s=U.from(e.path,"utf8"),a=U.from([0]),o=U.from(e.oid,"hex");return U.concat([i,r,s,a,o])}))}entries(){return this._entries}*[Symbol.iterator](){for(const t of this._entries)yield t}}class Xt{static wrap({type:t,object:e}){const i=`${t} ${e.length}\0`,r=i.length,s=r+e.length,a=new Uint8Array(s);for(let o=0;o<r;o++)a[o]=i.charCodeAt(o);return a.set(e,r),a}static unwrap(t){const e=t.indexOf(32),i=t.indexOf(0),r=t.slice(0,e).toString("utf8"),s=t.slice(e+1,i).toString("utf8"),a=t.length-(i+1);if(parseInt(s)!==a)throw new M(`Length mismatch: expected ${s} bytes but got ${a} instead.`);return{type:r,object:U.from(t.slice(i+1))}}}async function Wi({fs:n,gitdir:t,oid:e}){const i=`objects/${e.slice(0,2)}/${e.slice(2)}`,r=await n.read(`${t}/${i}`);return r?{object:r,format:"deflated",source:i}:null}function zs(n,t){const e=new z(n),i=Gi(e);if(i!==t.byteLength)throw new M(`applyDelta expected source buffer to be ${i} bytes but the provided buffer was ${t.length} bytes`);const r=Gi(e);let s;const a=Xi(e,t);if(a.byteLength===r)s=a;else{s=U.alloc(r);const o=new z(s);for(o.copy(a);!e.eof();)o.copy(Xi(e,t));const u=o.tell();if(r!==u)throw new M(`applyDelta expected target buffer to be ${r} bytes but the resulting buffer was ${u} bytes`)}return s}function Gi(n){let t=0,e=0,i=null;do i=n.readUInt8(),t|=(i&127)<<e,e+=7;while(i&128);return t}function Vi(n,t,e){let i=0,r=0;for(;e--;)t&1&&(i|=n.readUInt8()<<r),t>>=1,r+=8;return i}function Xi(n,t){const e=n.readUInt8(),i=128,r=15,s=112;if(e&i){const a=Vi(n,e&r,4);let o=Vi(n,(e&s)>>4,3);return o===0&&(o=65536),t.slice(a,a+o)}else return n.slice(e)}function qs(n){let t=[n];return{next(){return Promise.resolve({done:t.length===0,value:t.pop()})},return(){return t=[],{}},[Symbol.asyncIterator](){return this}}}function Yi(n){return n[Symbol.asyncIterator]?n[Symbol.asyncIterator]():n[Symbol.iterator]?n[Symbol.iterator]():n.next?n:qs(n)}class Zi{constructor(t){if(typeof U>"u")throw new Error("Missing Buffer dependency");this.stream=Yi(t),this.buffer=null,this.cursor=0,this.undoCursor=0,this.started=!1,this._ended=!1,this._discardedBytes=0}eof(){return this._ended&&this.cursor===this.buffer.length}tell(){return this._discardedBytes+this.cursor}async byte(){if(!this.eof()&&(this.started||await this._init(),!(this.cursor===this.buffer.length&&(await this._loadnext(),this._ended))))return this._moveCursor(1),this.buffer[this.undoCursor]}async chunk(){if(!this.eof()&&(this.started||await this._init(),!(this.cursor===this.buffer.length&&(await this._loadnext(),this._ended))))return this._moveCursor(this.buffer.length),this.buffer.slice(this.undoCursor,this.cursor)}async read(t){if(!this.eof())return this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t),this.buffer.slice(this.undoCursor,this.cursor)}async skip(t){this.eof()||(this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t))}async undo(){this.cursor=this.undoCursor}async _next(){this.started=!0;let{done:t,value:e}=await this.stream.next();return t&&(this._ended=!0,!e)?U.alloc(0):(e&&(e=U.from(e)),e)}_trim(){this.buffer=this.buffer.slice(this.undoCursor),this.cursor-=this.undoCursor,this._discardedBytes+=this.undoCursor,this.undoCursor=0}_moveCursor(t){this.undoCursor=this.cursor,this.cursor+=t,this.cursor>this.buffer.length&&(this.cursor=this.buffer.length)}async _accumulate(t){if(this._ended)return;const e=[this.buffer];for(;this.cursor+t>Ls(e);){const i=await this._next();if(this._ended)break;e.push(i)}this.buffer=U.concat(e)}async _loadnext(){this._discardedBytes+=this.buffer.length,this.undoCursor=0,this.cursor=0,this.buffer=await this._next()}async _init(){this.buffer=await this._next()}}function Ls(n){return n.reduce((t,e)=>t+e.length,0)}async function Ws(n,t){const e=new Zi(n);let i=await e.read(4);if(i=i.toString("utf8"),i!=="PACK")throw new M(`Invalid PACK header '${i}'`);let r=await e.read(4);if(r=r.readUInt32BE(0),r!==2)throw new M(`Invalid packfile version: ${r}`);let s=await e.read(4);if(s=s.readUInt32BE(0),!(s<1))for(;!e.eof()&&s--;){const a=e.tell(),{type:o,length:u,ofs:l,reference:c}=await Gs(e),h=new D.Inflate;for(;!h.result;){const f=await e.chunk();if(!f)break;if(h.push(f,!1),h.err)throw new M(`Pako error: ${h.msg}`);if(h.result){if(h.result.length!==u)throw new M("Inflated object size is different from that stated in packfile.");await e.undo(),await e.read(f.length-h.strm.avail_in);const d=e.tell();await t({data:h.result,type:o,num:s,offset:a,end:d,reference:c,ofs:l})}}}}async function Gs(n){let t=await n.byte();const e=t>>4&7;let i=t&15;if(t&128){let a=4;do t=await n.byte(),i|=(t&127)<<a,a+=7;while(t&128)}let r,s;if(e===6){let a=0;r=0;const o=[];do t=await n.byte(),r|=(t&127)<<a,a+=7,o.push(t);while(t&128);s=U.from(o)}return e===7&&(s=await n.read(20)),{type:e,length:i,ofs:r,reference:s}}async function Qi(n){return D.inflate(n)}function Vs(n){const t=[];let e=0,i=0;do{e=n.readUInt8();const r=e&127;t.push(r),i=e&128}while(i);return t.reduce((r,s)=>r+1<<7|s,-1)}function Xs(n,t){let e=t,i=4,r=null;do r=n.readUInt8(),e|=(r&127)<<i,i+=7;while(r&128);return e}class Yt{constructor(t){Object.assign(this,t),this.offsetCache={}}static async fromIdx({idx:t,getExternalRefDelta:e}){const i=new z(t);if(i.slice(4).toString("hex")!=="ff744f63")return;const s=i.readUInt32BE();if(s!==2)throw new M(`Unable to read version ${s} packfile IDX. (Only version 2 supported)`);if(t.byteLength>2048*1024*1024)throw new M("To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.");i.seek(i.tell()+1020);const a=i.readUInt32BE(),o=[];for(let c=0;c<a;c++){const h=i.slice(20).toString("hex");o[c]=h}i.seek(i.tell()+4*a);const u=new Map;for(let c=0;c<a;c++)u.set(o[c],i.readUInt32BE());const l=i.slice(20).toString("hex");return new Yt({hashes:o,crcs:{},offsets:u,packfileSha:l,getExternalRefDelta:e})}static async fromPack({pack:t,getExternalRefDelta:e,onProgress:i}){const r={1:"commit",2:"tree",3:"blob",4:"tag",6:"ofs-delta",7:"ref-delta"},s={},a=t.slice(-20).toString("hex"),o=[],u={},l=new Map;let c=null,h=null;await Ws([t],async({data:_,type:k,reference:v,offset:O,num:F})=>{c===null&&(c=F);const L=Math.floor((c-F)*100/c);L!==h&&i&&await i({phase:"Receiving objects",loaded:c-F,total:c}),h=L,k=r[k],["commit","tree","blob","tag"].includes(k)?s[O]={type:k,offset:O}:k==="ofs-delta"?s[O]={type:k,offset:O}:k==="ref-delta"&&(s[O]={type:k,offset:O})});const f=Object.keys(s).map(Number);for(const[_,k]of f.entries()){const v=_+1===f.length?t.byteLength-20:f[_+1],O=s[k],F=P.buf(t.slice(k,v))>>>0;O.end=v,O.crc=F}const d=new Yt({pack:Promise.resolve(t),packfileSha:a,crcs:u,hashes:o,offsets:l,getExternalRefDelta:e});h=null;let y=0;const b=[0,0,0,0,0,0,0,0,0,0,0,0];for(let _ in s){_=Number(_);const k=Math.floor(y*100/c);k!==h&&i&&await i({phase:"Resolving deltas",loaded:y,total:c}),y++,h=k;const v=s[_];if(!v.oid)try{d.readDepth=0,d.externalReadDepth=0;const{type:O,object:F}=await d.readSlice({start:_});b[d.readDepth]+=1;const L=await Rt(Xt.wrap({type:O,object:F}));v.oid=L,o.push(L),l.set(L,_),u[L]=v.crc}catch{continue}}return o.sort(),d}async toBuffer(){const t=[],e=(l,c)=>{t.push(U.from(l,c))};e("ff744f63","hex"),e("00000002","hex");const i=new z(U.alloc(256*4));for(let l=0;l<256;l++){let c=0;for(const h of this.hashes)parseInt(h.slice(0,2),16)<=l&&c++;i.writeUInt32BE(c)}t.push(i.buffer);for(const l of this.hashes)e(l,"hex");const r=new z(U.alloc(this.hashes.length*4));for(const l of this.hashes)r.writeUInt32BE(this.crcs[l]);t.push(r.buffer);const s=new z(U.alloc(this.hashes.length*4));for(const l of this.hashes)s.writeUInt32BE(this.offsets.get(l));t.push(s.buffer),e(this.packfileSha,"hex");const a=U.concat(t),o=await Rt(a),u=U.alloc(20);return u.write(o,"hex"),U.concat([a,u])}async load({pack:t}){this.pack=t}async unload(){this.pack=null}async read({oid:t}){if(!this.offsets.get(t)){if(this.getExternalRefDelta)return this.externalReadDepth++,this.getExternalRefDelta(t);throw new M(`Could not read object ${t} from packfile`)}const e=this.offsets.get(t);return this.readSlice({start:e})}async readSlice({start:t}){if(this.offsetCache[t])return Object.assign({},this.offsetCache[t]);this.readDepth++;const e={16:"commit",32:"tree",48:"blob",64:"tag",96:"ofs_delta",112:"ref_delta"};if(!this.pack)throw new M("Tried to read from a GitPackIndex with no packfile loaded into memory");const i=(await this.pack).slice(t),r=new z(i),s=r.readUInt8(),a=s&112;let o=e[a];if(o===void 0)throw new M("Unrecognized type: 0b"+a.toString(2));const u=s&15;let l=u;s&128&&(l=Xs(r,u));let h=null,f=null;if(o==="ofs_delta"){const y=Vs(r),b=t-y;({object:h,type:o}=await this.readSlice({start:b}))}if(o==="ref_delta"){const y=r.slice(20).toString("hex");({object:h,type:o}=await this.read({oid:y}))}const d=i.slice(r.tell());if(f=U.from(await Qi(d)),f.byteLength!==l)throw new M(`Packfile told us object would have length ${l} but it had length ${f.byteLength}`);return h&&(f=U.from(zs(f,h))),this.readDepth>3&&(this.offsetCache[t]={type:o,object:f}),{type:o,format:"content",object:f}}}const Me=Symbol("PackfileCache");async function Ys({fs:n,filename:t,getExternalRefDelta:e,emitter:i,emitterPrefix:r}){const s=await n.read(t);return Yt.fromIdx({idx:s,getExternalRefDelta:e})}function ni({fs:n,cache:t,filename:e,getExternalRefDelta:i,emitter:r,emitterPrefix:s}){t[Me]||(t[Me]=new Map);let a=t[Me].get(e);return a||(a=Ys({fs:n,filename:e,getExternalRefDelta:i,emitter:r,emitterPrefix:s}),t[Me].set(e,a)),a}async function Zs({fs:n,cache:t,gitdir:e,oid:i,format:r="content",getExternalRefDelta:s}){let a=await n.readdir(m.join(e,"objects/pack"));a=a.filter(o=>o.endsWith(".idx"));for(const o of a){const u=`${e}/objects/pack/${o}`,l=await ni({fs:n,cache:t,filename:u,getExternalRefDelta:s});if(l.error)throw new M(l.error);if(l.offsets.has(i)){if(!l.pack){const h=u.replace(/idx$/,"pack");l.pack=n.read(h)}const c=await l.read({oid:i,getExternalRefDelta:s});return c.format="content",c.source=`objects/pack/${o.replace(/idx$/,"pack")}`,c}}return null}async function et({fs:n,cache:t,gitdir:e,oid:i,format:r="content"}){const s=c=>et({fs:n,cache:t,gitdir:e,oid:c});let a;if(i==="4b825dc642cb6eb9a060e54bf8d69288fbee4904"&&(a={format:"wrapped",object:U.from("tree 0\0")}),a||(a=await Wi({fs:n,gitdir:e,oid:i})),!a){if(a=await Zs({fs:n,cache:t,gitdir:e,oid:i,getExternalRefDelta:s}),!a)throw new J(i);return a}if(r==="deflated"||(a.format==="deflated"&&(a.object=U.from(await Qi(a.object)),a.format="wrapped"),r==="wrapped"))return a;const o=await Rt(a.object);if(o!==i)throw new M(`SHA check failed! Expected ${i}, computed ${o}`);const{object:u,type:l}=Xt.unwrap(a.object);if(a.type=l,a.object=u,a.format="content",r==="content")return a;throw new M(`invalid requested format "${r}"`)}class St extends j{constructor(t,e,i=!0){super(`Failed to create ${t} at ${e} because it already exists.${i?` (Hint: use 'force: true' parameter to overwrite existing ${t}.)`:""}`),this.code=this.name=St.code,this.data={noun:t,where:e,canForce:i}}}St.code="AlreadyExistsError";class fe extends j{constructor(t,e,i){super(`Found multiple ${t} matching "${e}" (${i.join(", ")}). Use a longer abbreviation length to disambiguate them.`),this.code=this.name=fe.code,this.data={nouns:t,short:e,matches:i}}}fe.code="AmbiguousError";class he extends j{constructor(t){super(`Your local changes to the following files would be overwritten by checkout: ${t.join(", ")}`),this.code=this.name=he.code,this.data={filepaths:t}}}he.code="CheckoutConflictError";class de extends j{constructor(t,e){super(`Failed to checkout "${t}" because commit ${e} is not available locally. Do a git fetch to make the branch available locally.`),this.code=this.name=de.code,this.data={ref:t,oid:e}}}de.code="CommitNotFetchedError";class we extends j{constructor(){super("Empty response from git server."),this.code=this.name=we.code,this.data={}}}we.code="EmptyServerResponseError";class me extends j{constructor(){super("A simple fast-forward merge was not possible."),this.code=this.name=me.code,this.data={}}}me.code="FastForwardError";class pe extends j{constructor(t,e){super(`One or more branches were not updated: ${t}`),this.code=this.name=pe.code,this.data={prettyDetails:t,result:e}}}pe.code="GitPushError";class Zt extends j{constructor(t,e,i){super(`HTTP Error: ${t} ${e}`),this.code=this.name=Zt.code,this.data={statusCode:t,statusMessage:e,response:i}}}Zt.code="HttpError";class Ct extends j{constructor(t){let e="invalid filepath";t==="leading-slash"||t==="trailing-slash"?e='"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.':t==="directory"&&(e='"filepath" should not be a directory.'),super(e),this.code=this.name=Ct.code,this.data={reason:t}}}Ct.code="InvalidFilepathError";class $t extends j{constructor(t,e){super(`"${t}" would be an invalid git reference. (Hint: a valid alternative would be "${e}".)`),this.code=this.name=$t.code,this.data={ref:t,suggestion:e}}}$t.code="InvalidRefNameError";class ye extends j{constructor(t){super(`Maximum search depth of ${t} exceeded.`),this.code=this.name=ye.code,this.data={depth:t}}}ye.code="MaxDepthError";class Qt extends j{constructor(){super("Merges with conflicts are not supported yet."),this.code=this.name=Qt.code,this.data={}}}Qt.code="MergeNotSupportedError";class Jt extends j{constructor(t,e,i,r){super(`Automatic merge failed with one or more merge conflicts in the following files: ${t.toString()}. Fix conflicts then commit the result.`),this.code=this.name=Jt.code,this.data={filepaths:t,bothModified:e,deleteByUs:i,deleteByTheirs:r}}}Jt.code="MergeConflictError";class ht extends j{constructor(t){super(`No name was provided for ${t} in the argument or in the .git/config file.`),this.code=this.name=ht.code,this.data={role:t}}}ht.code="MissingNameError";class yt extends j{constructor(t){super(`The function requires a "${t}" parameter but none was provided.`),this.code=this.name=yt.code,this.data={parameter:t}}}yt.code="MissingParameterError";class ge extends j{constructor(t){super('There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more'),this.code=this.name=ge.code,this.data={errors:t},this.errors=t}}ge.code="MultipleGitError";class Ut extends j{constructor(t,e){super(`Expected "${t}" but received "${e}".`),this.code=this.name=Ut.code,this.data={expected:t,actual:e}}}Ut.code="ParseError";class Kt extends j{constructor(t){let e="";t==="not-fast-forward"?e=" because it was not a simple fast-forward":t==="tag-exists"&&(e=" because tag already exists"),super(`Push rejected${e}. Use "force: true" to override.`),this.code=this.name=Kt.code,this.data={reason:t}}}Kt.code="PushRejectedError";class At extends j{constructor(t,e){super(`Remote does not support the "${t}" so the "${e}" parameter cannot be used.`),this.code=this.name=At.code,this.data={capability:t,parameter:e}}}At.code="RemoteCapabilityError";class be extends j{constructor(t,e){super(`Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${t}`),this.code=this.name=be.code,this.data={preview:t,response:e}}}be.code="SmartHttpError";class _e extends j{constructor(t,e,i){super(`Git remote "${t}" uses an unrecognized transport protocol: "${e}"`),this.code=this.name=_e.code,this.data={url:t,transport:e,suggestion:i}}}_e.code="UnknownTransportError";class ke extends j{constructor(t){super(`Cannot parse remote URL: "${t}"`),this.code=this.name=ke.code,this.data={url:t}}}ke.code="UrlParseError";class te extends j{constructor(){super("The operation was canceled."),this.code=this.name=te.code,this.data={}}}te.code="UserCanceledError";class ve extends j{constructor(t){super(`Could not merge index: Entry for '${t}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged changes.`),this.code=this.name=ve.code,this.data={filepath:t}}}ve.code="IndexResetError";class Se extends j{constructor(t){super(`"${t}" does not point to any commit. You're maybe working on a repository with no commits yet. `),this.code=this.name=Se.code,this.data={ref:t}}}Se.code="NoCommitError";var Ji=Object.freeze({__proto__:null,AlreadyExistsError:St,AmbiguousError:fe,CheckoutConflictError:he,CommitNotFetchedError:de,EmptyServerResponseError:we,FastForwardError:me,GitPushError:pe,HttpError:Zt,InternalError:M,InvalidFilepathError:Ct,InvalidOidError:Pt,InvalidRefNameError:$t,MaxDepthError:ye,MergeNotSupportedError:Qt,MergeConflictError:Jt,MissingNameError:ht,MissingParameterError:yt,MultipleGitError:ge,NoRefspecError:le,NotFoundError:J,ObjectTypeError:wt,ParseError:Ut,PushRejectedError:Kt,RemoteCapabilityError:At,SmartHttpError:be,UnknownTransportError:_e,UnsafeFilepathError:R,UrlParseError:ke,UserCanceledError:te,UnmergedPathsError:W,IndexResetError:ve,NoCommitError:Se});function ri({name:n,email:t,timestamp:e,timezoneOffset:i}){return i=Qs(i),`${n} <${t}> ${e} ${i}`}function Qs(n){const t=Js(Ks(n));n=Math.abs(n);const e=Math.floor(n/60);n-=e*60;let i=String(e),r=String(n);return i.length<2&&(i="0"+i),r.length<2&&(r="0"+r),(t===-1?"-":"+")+i+r}function Js(n){return Math.sign(n)||(Object.is(n,-0)?-1:1)}function Ks(n){return n===0?n:-n}function Ot(n){return n=n.replace(/\r/g,""),n=n.replace(/^\n+/,""),n=n.replace(/\n+$/,"")+`
`,n}function Fe(n){const[,t,e,i,r]=n.match(/^(.*) <(.*)> (.*) (.*)$/);return{name:t,email:e,timestamp:Number(i),timezoneOffset:ta(r)}}function ta(n){let[,t,e,i]=n.match(/(\+|-)(\d\d)(\d\d)/);return i=(t==="+"?1:-1)*(Number(e)*60+Number(i)),ea(i)}function ea(n){return n===0?n:-n}class mt{constructor(t){if(typeof t=="string")this._tag=t;else if(U.isBuffer(t))this._tag=t.toString("utf8");else if(typeof t=="object")this._tag=mt.render(t);else throw new M("invalid type passed to GitAnnotatedTag constructor")}static from(t){return new mt(t)}static render(t){return`object ${t.object}
type ${t.type}
tag ${t.tag}
tagger ${ri(t.tagger)}

${t.message}
${t.gpgsig?t.gpgsig:""}`}justHeaders(){return this._tag.slice(0,this._tag.indexOf(`

`))}message(){const t=this.withoutSignature();return t.slice(t.indexOf(`

`)+2)}parse(){return Object.assign(this.headers(),{message:this.message(),gpgsig:this.gpgsig()})}render(){return this._tag}headers(){const t=this.justHeaders().split(`
`),e=[];for(const r of t)r[0]===" "?e[e.length-1]+=`
`+r.slice(1):e.push(r);const i={};for(const r of e){const s=r.slice(0,r.indexOf(" ")),a=r.slice(r.indexOf(" ")+1);Array.isArray(i[s])?i[s].push(a):i[s]=a}return i.tagger&&(i.tagger=Fe(i.tagger)),i.committer&&(i.committer=Fe(i.committer)),i}withoutSignature(){const t=Ot(this._tag);return t.indexOf(`
-----BEGIN PGP SIGNATURE-----`)===-1?t:t.slice(0,t.lastIndexOf(`
-----BEGIN PGP SIGNATURE-----`))}gpgsig(){if(this._tag.indexOf(`
-----BEGIN PGP SIGNATURE-----`)===-1)return;const t=this._tag.slice(this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),this._tag.indexOf("-----END PGP SIGNATURE-----")+27);return Ot(t)}payload(){return this.withoutSignature()+`
`}toObject(){return U.from(this._tag,"utf8")}static async sign(t,e,i){const r=t.payload();let{signature:s}=await e({payload:r,secretKey:i});s=Ot(s);const a=r+s;return mt.from(a)}}function si(n){return n.trim().split(`
`).map(t=>" "+t).join(`
`)+`
`}function ia(n){return n.split(`
`).map(t=>t.replace(/^ /,"")).join(`
`)}class it{constructor(t){if(typeof t=="string")this._commit=t;else if(U.isBuffer(t))this._commit=t.toString("utf8");else if(typeof t=="object")this._commit=it.render(t);else throw new M("invalid type passed to GitCommit constructor")}static fromPayloadSignature({payload:t,signature:e}){const i=it.justHeaders(t),r=it.justMessage(t),s=Ot(i+`
gpgsig`+si(e)+`
`+r);return new it(s)}static from(t){return new it(t)}toObject(){return U.from(this._commit,"utf8")}headers(){return this.parseHeaders()}message(){return it.justMessage(this._commit)}parse(){return Object.assign({message:this.message()},this.headers())}static justMessage(t){return Ot(t.slice(t.indexOf(`

`)+2))}static justHeaders(t){return t.slice(0,t.indexOf(`

`))}parseHeaders(){const t=it.justHeaders(this._commit).split(`
`),e=[];for(const r of t)r[0]===" "?e[e.length-1]+=`
`+r.slice(1):e.push(r);const i={parent:[]};for(const r of e){const s=r.slice(0,r.indexOf(" ")),a=r.slice(r.indexOf(" ")+1);Array.isArray(i[s])?i[s].push(a):i[s]=a}return i.author&&(i.author=Fe(i.author)),i.committer&&(i.committer=Fe(i.committer)),i}static renderHeaders(t){let e="";if(t.tree?e+=`tree ${t.tree}
`:e+=`tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`,t.parent){if(t.parent.length===void 0)throw new M("commit 'parent' property should be an array");for(const s of t.parent)e+=`parent ${s}
`}const i=t.author;e+=`author ${ri(i)}
`;const r=t.committer||t.author;return e+=`committer ${ri(r)}
`,t.gpgsig&&(e+="gpgsig"+si(t.gpgsig)),e}static render(t){return it.renderHeaders(t)+`
`+Ot(t.message)}render(){return this._commit}withoutSignature(){const t=Ot(this._commit);if(t.indexOf(`
gpgsig`)===-1)return t;const e=t.slice(0,t.indexOf(`
gpgsig`)),i=t.slice(t.indexOf(`-----END PGP SIGNATURE-----
`)+28);return Ot(e+`
`+i)}isolateSignature(){const t=this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),this._commit.indexOf("-----END PGP SIGNATURE-----")+27);return ia(t)}static async sign(t,e,i){const r=t.withoutSignature(),s=it.justMessage(t._commit);let{signature:a}=await e({payload:r,secretKey:i});a=Ot(a);const u=it.justHeaders(t._commit)+`
gpgsig`+si(a)+`
`+s;return it.from(u)}}async function ee({fs:n,cache:t,gitdir:e,oid:i}){if(i==="4b825dc642cb6eb9a060e54bf8d69288fbee4904")return{tree:pt.from([]),oid:i};const{type:r,object:s}=await et({fs:n,cache:t,gitdir:e,oid:i});if(r==="tag")return i=mt.from(s).parse().object,ee({fs:n,cache:t,gitdir:e,oid:i});if(r==="commit")return i=it.from(s).parse().tree,ee({fs:n,cache:t,gitdir:e,oid:i});if(r!=="tree")throw new wt(i,r,"tree");return{tree:pt.from(s),oid:i}}class na{constructor({fs:t,gitdir:e,ref:i,cache:r}){this.fs=t,this.cache=r,this.gitdir=e,this.mapPromise=(async()=>{const a=new Map;let o;try{o=await S.resolve({fs:t,gitdir:e,ref:i})}catch(l){l instanceof J&&(o="4b825dc642cb6eb9a060e54bf8d69288fbee4904")}const u=await ee({fs:t,cache:this.cache,gitdir:e,oid:o});return u.type="tree",u.mode="40000",a.set(".",u),a})();const s=this;this.ConstructEntry=class{constructor(o){this._fullpath=o,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return s.type(this)}async mode(){return s.mode(this)}async stat(){return s.stat(this)}async content(){return s.content(this)}async oid(){return s.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:i,cache:r,gitdir:s}=this,a=await this.mapPromise,o=a.get(e);if(!o)throw new Error(`No obj for ${e}`);const u=o.oid;if(!u)throw new Error(`No oid for obj ${JSON.stringify(o)}`);if(o.type!=="tree")return null;const{type:l,object:c}=await et({fs:i,cache:r,gitdir:s,oid:u});if(l!==o.type)throw new wt(u,l,o.type);const h=pt.from(c);for(const f of h)a.set(m.join(e,f.path),f);return h.entries().map(f=>m.join(e,f.path))}async type(t){if(t._type===!1){const e=await this.mapPromise,{type:i}=e.get(t._fullpath);t._type=i}return t._type}async mode(t){if(t._mode===!1){const e=await this.mapPromise,{mode:i}=e.get(t._fullpath);t._mode=tt(parseInt(i,8))}return t._mode}async stat(t){}async content(t){if(t._content===!1){const e=await this.mapPromise,{fs:i,cache:r,gitdir:s}=this,o=e.get(t._fullpath).oid,{type:u,object:l}=await et({fs:i,cache:r,gitdir:s,oid:o});u!=="blob"?t._content=void 0:t._content=new Uint8Array(l)}return t._content}async oid(t){if(t._oid===!1){const i=(await this.mapPromise).get(t._fullpath);t._oid=i.oid}return t._oid}}function _t({ref:n="HEAD"}={}){const t=Object.create(null);return Object.defineProperty(t,Ae,{value:function({fs:e,gitdir:i,cache:r}){return new na({fs:e,gitdir:i,ref:n,cache:r})}}),Object.freeze(t),t}class ra{constructor({fs:t,dir:e,gitdir:i,cache:r}){this.fs=t,this.cache=r,this.dir=e,this.gitdir=i,this.config=null;const s=this;this.ConstructEntry=class{constructor(o){this._fullpath=o,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return s.type(this)}async mode(){return s.mode(this)}async stat(){return s.stat(this)}async content(){return s.content(this)}async oid(){return s.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:i,dir:r}=this,s=await i.readdir(m.join(r,e));return s===null?null:s.map(a=>m.join(e,a))}async type(t){return t._type===!1&&await t.stat(),t._type}async mode(t){return t._mode===!1&&await t.stat(),t._mode}async stat(t){if(t._stat===!1){const{fs:e,dir:i}=this;let r=await e.lstat(`${i}/${t._fullpath}`);if(!r)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);let s=r.isDirectory()?"tree":"blob";s==="blob"&&!r.isFile()&&!r.isSymbolicLink()&&(s="special"),t._type=s,r=jt(r),t._mode=r.mode,r.size===-1&&t._actualSize&&(r.size=t._actualSize),t._stat=r}return t._stat}async content(t){if(t._content===!1){const{fs:e,dir:i,gitdir:r}=this;if(await t.type()==="tree")t._content=void 0;else{const a=await(await this._getGitConfig(e,r)).get("core.autocrlf"),o=await e.read(`${i}/${t._fullpath}`,{autocrlf:a});t._actualSize=o.length,t._stat&&t._stat.size===-1&&(t._stat.size=t._actualSize),t._content=new Uint8Array(o)}}return t._content}async oid(t){if(t._oid===!1){const e=this,{fs:i,gitdir:r,cache:s}=this;let a;await at.acquire({fs:i,gitdir:r,cache:s},async function(o){const u=o.entriesMap.get(t._fullpath),l=await t.stat(),h=await(await e._getGitConfig(i,r)).get("core.filemode"),f=typeof Kr<"u"?Kr.platform!=="win32":!0;if(!u||Te(l,u,h,f)){const d=await t.content();d===void 0?a=void 0:(a=await Rt(Xt.wrap({type:"blob",object:d})),u&&a===u.oid&&(!h||l.mode===u.mode)&&Te(l,u,h,f)&&o.insert({filepath:t._fullpath,stats:l,oid:a}))}else a=u.oid}),t._oid=a}return t._oid}async _getGitConfig(t,e){return this.config?this.config:(this.config=await st.get({fs:t,gitdir:e}),this.config)}}function ie(){const n=Object.create(null);return Object.defineProperty(n,Ae,{value:function({fs:t,dir:e,gitdir:i,cache:r}){return new ra({fs:t,dir:e,gitdir:i,cache:r})}}),Object.freeze(n),n}function sa(n,t){const e=t-n;return Array.from({length:e},(i,r)=>n+r)}const Ki=typeof Array.prototype.flat>"u"?n=>n.reduce((t,e)=>t.concat(e),[]):n=>n.flat();class aa{constructor(){this.value=null}consider(t){t!=null&&(this.value===null?this.value=t:t<this.value&&(this.value=t))}reset(){this.value=null}}function*oa(n){const t=new aa;let e;const i=[],r=n.length;for(let s=0;s<r;s++)i[s]=n[s].next().value,i[s]!==void 0&&t.consider(i[s]);if(t.value!==null)for(;;){const s=[];e=t.value,t.reset();for(let a=0;a<r;a++)i[a]!==void 0&&i[a]===e?(s[a]=i[a],i[a]=n[a].next().value):s[a]=null,i[a]!==void 0&&t.consider(i[a]);if(yield s,t.value===null)return}}async function Bt({fs:n,cache:t,dir:e,gitdir:i,trees:r,map:s=async(u,l)=>l,reduce:a=async(u,l)=>{const c=Ki(l);return u!==void 0&&c.unshift(u),c},iterate:o=(u,l)=>Promise.all([...l].map(u))}){const u=r.map(d=>d[Ae]({fs:n,dir:e,gitdir:i,cache:t})),l=new Array(u.length).fill("."),c=sa(0,u.length),h=async d=>{c.map(_=>{const k=d[_];d[_]=k&&new u[_].ConstructEntry(k)});const b=(await Promise.all(c.map(_=>{const k=d[_];return k?u[_].readdir(k):[]}))).map(_=>(_===null?[]:_)[Symbol.iterator]());return{entries:d,children:oa(b)}},f=async d=>{const{entries:y,children:b}=await h(d),_=y.find(v=>v&&v._fullpath)._fullpath,k=await s(_,y);if(k!==null){let v=await o(f,b);return v=v.filter(O=>O!==void 0),a(k,v)}};return f(l)}async function ai(n,t){const e=await n.readdir(t);e==null?await n.rm(t):e.length?await Promise.all(e.map(i=>{const r=m.join(t,i);return n.lstat(r).then(s=>{if(s)return s.isDirectory()?ai(n,r):n.rm(r)})})).then(()=>n.rmdir(t)):await n.rmdir(t)}function ca(n){return la(n)&&tn(n.then)&&tn(n.catch)}function la(n){return n&&typeof n=="object"}function tn(n){return typeof n=="function"}function en(n){return ca((e=>{try{return e.readFile().catch(i=>i)}catch(i){return i}})(n))}const nn=["readFile","writeFile","mkdir","rmdir","unlink","stat","lstat","readdir","readlink","symlink"];function rn(n,t){if(en(t))for(const e of nn)n[`_${e}`]=t[e].bind(t);else for(const e of nn)n[`_${e}`]=x(t[e].bind(t));en(t)?t.rm?n._rm=t.rm.bind(t):t.rmdir.length>1?n._rm=t.rmdir.bind(t):n._rm=ai.bind(null,n):t.rm?n._rm=x(t.rm.bind(t)):t.rmdir.length>2?n._rm=x(t.rmdir.bind(t)):n._rm=ai.bind(null,n)}class q{constructor(t){if(typeof t._original_unwrapped_fs<"u")return t;const e=Object.getOwnPropertyDescriptor(t,"promises");e&&e.enumerable?rn(this,t.promises):rn(this,t),this._original_unwrapped_fs=t}async exists(t,e={}){try{return await this._stat(t),!0}catch(i){if(i.code==="ENOENT"||i.code==="ENOTDIR"||(i.code||"").includes("ENS"))return!1;throw console.log('Unhandled error in "FileSystem.exists()" function',i),i}}async read(t,e={}){try{let i=await this._readFile(t,e);if(e.autocrlf==="true")try{i=new TextDecoder("utf8",{fatal:!0}).decode(i),i=i.replace(/\r\n/g,`
`),i=new TextEncoder().encode(i)}catch{}return typeof i!="string"&&(i=U.from(i)),i}catch{return null}}async write(t,e,i={}){try{await this._writeFile(t,e,i);return}catch{await this.mkdir(Vt(t)),await this._writeFile(t,e,i)}}async mkdir(t,e=!1){try{await this._mkdir(t);return}catch(i){if(i===null||i.code==="EEXIST")return;if(e)throw i;if(i.code==="ENOENT"){const r=Vt(t);if(r==="."||r==="/"||r===t)throw i;await this.mkdir(r),await this.mkdir(t,!0)}}}async rm(t){try{await this._unlink(t)}catch(e){if(e.code!=="ENOENT")throw e}}async rmdir(t,e){try{e&&e.recursive?await this._rm(t,e):await this._rmdir(t)}catch(i){if(i.code!=="ENOENT")throw i}}async readdir(t){try{const e=await this._readdir(t);return e.sort(V),e}catch(e){return e.code==="ENOTDIR"?null:[]}}async readdirDeep(t){const e=await this._readdir(t);return(await Promise.all(e.map(async r=>{const s=t+"/"+r;return(await this._stat(s)).isDirectory()?this.readdirDeep(s):s}))).reduce((r,s)=>r.concat(s),[])}async lstat(t){try{return await this._lstat(t)}catch(e){if(e.code==="ENOENT"||(e.code||"").includes("ENS"))return null;throw e}}async readlink(t,e={encoding:"buffer"}){try{const i=await this._readlink(t,e);return U.isBuffer(i)?i:U.from(i)}catch(i){if(i.code==="ENOENT"||(i.code||"").includes("ENS"))return null;throw i}}async writelink(t,e){return this._symlink(e.toString("utf8"),t)}}function w(n,t){if(t===void 0)throw new yt(n)}async function Ue(n,t){return!n&&!t?!1:n&&!t||!n&&t?!0:!(await n.type()==="tree"&&await t.type()==="tree"||await n.type()===await t.type()&&await n.mode()===await t.mode()&&await n.oid()===await t.oid())}async function sn({fs:n,dir:t,gitdir:e=m.join(t,".git"),commit:i="HEAD",cache:r={}}){try{w("fs",n),w("dir",t),w("gitdir",e);const s=new q(n),a=[_t({ref:i}),ie(),Ft()];let o=[];await at.acquire({fs:s,gitdir:e,cache:r},async function(l){o=l.unmergedPaths});const u=await Bt({fs:s,cache:r,dir:t,gitdir:e,trees:a,map:async function(l,[c,h,f]){const d=!await Ue(h,f),y=o.includes(l),b=!await Ue(f,c);if(d||y)return c?{path:l,mode:await c.mode(),oid:await c.oid(),type:await c.type(),content:await c.content()}:void 0;if(b)return!1;throw new ve(l)}});await at.acquire({fs:s,gitdir:e,cache:r},async function(l){for(const c of u)if(c!==!1){if(!c){await s.rmdir(`${t}/${c.path}`,{recursive:!0}),l.delete({filepath:c.path});continue}if(c.type==="blob"){const h=new TextDecoder().decode(c.content);await s.write(`${t}/${c.path}`,h,{mode:c.mode}),l.insert({filepath:c.path,oid:c.oid,stage:0})}}})}catch(s){throw s.caller="git.abortMerge",s}}class ne{static async isIgnored({fs:t,dir:e,gitdir:i=m.join(e,".git"),filepath:r}){if(Ce(r)===".git")return!0;if(r===".")return!1;let s="";const a=m.join(i,"info","exclude");await t.exists(a)&&(s=await t.read(a,"utf8"));const o=[{gitignore:m.join(e,".gitignore"),filepath:r}],u=r.split("/").filter(Boolean);for(let c=1;c<u.length;c++){const h=u.slice(0,c).join("/"),f=u.slice(c).join("/");o.push({gitignore:m.join(e,h,".gitignore"),filepath:f})}let l=!1;for(const c of o){let h;try{h=await t.read(c.gitignore,"utf8")}catch(y){if(y.code==="NOENT")continue}const f=g().add(s);f.add(h);const d=Vt(c.filepath);if(d!=="."&&f.ignores(d))return!0;l?l=!f.test(c.filepath).unignored:l=f.test(c.filepath).ignored}return l}}async function ua({fs:n,gitdir:t,object:e,format:i,oid:r}){const s=`objects/${r.slice(0,2)}/${r.slice(2)}`,a=`${t}/${s}`;await n.exists(a)||await n.write(a,e)}let oi=null;async function an(n){return oi===null&&(oi=ha()),oi?fa(n):D.deflate(n)}async function fa(n){const t=new CompressionStream("deflate"),e=new Blob([n]).stream().pipeThrough(t);return new Uint8Array(await new Response(e).arrayBuffer())}function ha(){try{return new CompressionStream("deflate").writable.close(),new Blob([]).stream().cancel(),!0}catch{return!1}}async function gt({fs:n,gitdir:t,type:e,object:i,format:r="content",oid:s=void 0,dryRun:a=!1}){return r!=="deflated"&&(r!=="wrapped"&&(i=Xt.wrap({type:e,object:i})),s=await Rt(i),i=U.from(await an(i))),a||await ua({fs:n,gitdir:t,object:i,format:"deflated",oid:s}),s}function on(n){let t;for(;~(t=n.indexOf(92));)n[t]=47;return n}async function cn({fs:n,dir:t,gitdir:e=m.join(t,".git"),filepath:i,cache:r={},force:s=!1,parallel:a=!0}){try{w("fs",n),w("dir",t),w("gitdir",e),w("filepath",i);const o=new q(n);await at.acquire({fs:o,gitdir:e,cache:r},async u=>{const c=await(await st.get({fs:o,gitdir:e})).get("core.autocrlf");return ci({dir:t,gitdir:e,fs:o,filepath:i,index:u,force:s,parallel:a,autocrlf:c})})}catch(o){throw o.caller="git.add",o}}async function ci({dir:n,gitdir:t,fs:e,filepath:i,index:r,force:s,parallel:a,autocrlf:o}){i=Array.isArray(i)?i:[i];const u=i.map(async f=>{if(!s&&await ne.isIgnored({fs:e,dir:n,gitdir:t,filepath:f}))return;const d=await e.lstat(m.join(n,f));if(!d)throw new J(f);if(d.isDirectory()){const y=await e.readdir(m.join(n,f));if(a){const b=y.map(_=>ci({dir:n,gitdir:t,fs:e,filepath:[m.join(f,_)],index:r,force:s,parallel:a,autocrlf:o}));await Promise.all(b)}else for(const b of y)await ci({dir:n,gitdir:t,fs:e,filepath:[m.join(f,b)],index:r,force:s,parallel:a,autocrlf:o})}else{const y=d.isSymbolicLink()?await e.readlink(m.join(n,f)).then(on):await e.read(m.join(n,f),{autocrlf:o});if(y===null)throw new J(f);const b=await gt({fs:e,gitdir:t,type:"blob",object:y});r.insert({filepath:f,stats:d,oid:b})}}),l=await Promise.allSettled(u),c=l.filter(f=>f.status==="rejected").map(f=>f.reason);if(c.length>1)throw new ge(c);if(c.length===1)throw c[0];return l.filter(f=>f.status==="fulfilled"&&f.value).map(f=>f.value)}async function $e({fs:n,gitdir:t,path:e}){return(await st.get({fs:n,gitdir:t})).get(e)}function ln(n,...t){for(const e of t)if(e)for(const i of Object.keys(e)){const r=e[i];r!==void 0&&(n[i]=r)}return n}async function Dt({fs:n,gitdir:t,author:e,commit:i}){const r=Math.floor(Date.now()/1e3),s={name:await $e({fs:n,gitdir:t,path:"user.name"}),email:await $e({fs:n,gitdir:t,path:"user.email"})||"",timestamp:r,timezoneOffset:new Date(r*1e3).getTimezoneOffset()},a=ln({},s,i?i.author:void 0,e);if(a.name!==void 0)return a}async function re({fs:n,gitdir:t,author:e,committer:i,commit:r}){const s=Math.floor(Date.now()/1e3),a={name:await $e({fs:n,gitdir:t,path:"user.name"}),email:await $e({fs:n,gitdir:t,path:"user.email"})||"",timestamp:s,timezoneOffset:new Date(s*1e3).getTimezoneOffset()},o=ln({},a,r?r.committer:void 0,e,i);if(o.name!==void 0)return o}async function un({fs:n,cache:t,gitdir:e,oid:i}){const{type:r,object:s}=await et({fs:n,cache:t,gitdir:e,oid:i});if(r==="tag")return i=mt.from(s).parse().object,un({fs:n,cache:t,gitdir:e,oid:i});if(r!=="commit")throw new wt(i,r,"commit");return{commit:it.from(s),oid:i}}async function se({fs:n,cache:t,gitdir:e,oid:i}){const{commit:r,oid:s}=await un({fs:n,cache:t,gitdir:e,oid:i});return{oid:s,commit:r.parse(),payload:r.withoutSignature()}}async function He({fs:n,cache:t,onSign:e,gitdir:i,message:r,author:s,committer:a,signingKey:o,amend:u=!1,dryRun:l=!1,noUpdateBranch:c=!1,ref:h,parent:f,tree:d}){let y=!1;h||(h=await S.resolve({fs:n,gitdir:i,ref:"HEAD",depth:2}));let b,_;try{b=await S.resolve({fs:n,gitdir:i,ref:h}),_=await se({fs:n,gitdir:i,oid:b,cache:{}})}catch{y=!0}if(u&&y)throw new Se(h);const k=u?await Dt({fs:n,gitdir:i,author:s,commit:_.commit}):await Dt({fs:n,gitdir:i,author:s});if(!k)throw new ht("author");const v=u?await re({fs:n,gitdir:i,author:k,committer:a,commit:_.commit}):await re({fs:n,gitdir:i,author:k,committer:a});if(!v)throw new ht("committer");return at.acquire({fs:n,gitdir:i,cache:t,allowUnmerged:!1},async function(O){const L=Mi(O.entries).get(".");if(d||(d=await fn({fs:n,gitdir:i,inode:L,dryRun:l})),f?f=await Promise.all(f.map(E=>S.resolve({fs:n,gitdir:i,ref:E}))):u?f=_.commit.parent:f=b?[b]:[],!r)if(u)r=_.commit.message;else throw new yt("message");let N=it.from({tree:d,parent:f,author:k,committer:v,message:r});o&&(N=await it.sign(N,e,o));const $=await gt({fs:n,gitdir:i,type:"commit",object:N.toObject(),dryRun:l});return!c&&!l&&await S.writeRef({fs:n,gitdir:i,ref:h,value:$}),$})}async function fn({fs:n,gitdir:t,inode:e,dryRun:i}){const r=e.children;for(const u of r)u.type==="tree"&&(u.metadata.mode="040000",u.metadata.oid=await fn({fs:n,gitdir:t,inode:u,dryRun:i}));const s=r.map(u=>({mode:u.metadata.mode,path:u.basename,oid:u.metadata.oid,type:u.type})),a=pt.from(s);return await gt({fs:n,gitdir:t,type:"tree",object:a.toObject(),dryRun:i})}async function xe({fs:n,cache:t,gitdir:e,oid:i,filepath:r}){if(r.startsWith("/"))throw new Ct("leading-slash");if(r.endsWith("/"))throw new Ct("trailing-slash");const s=i,a=await ee({fs:n,cache:t,gitdir:e,oid:i}),o=a.tree;if(r==="")i=a.oid;else{const u=r.split("/");i=await hn({fs:n,cache:t,gitdir:e,tree:o,pathArray:u,oid:s,filepath:r})}return i}async function hn({fs:n,cache:t,gitdir:e,tree:i,pathArray:r,oid:s,filepath:a}){const o=r.shift();for(const u of i)if(u.path===o){if(r.length===0)return u.oid;{const{type:l,object:c}=await et({fs:n,cache:t,gitdir:e,oid:u.oid});if(l!=="tree")throw new wt(s,l,"tree",a);return i=pt.from(c),hn({fs:n,cache:t,gitdir:e,tree:i,pathArray:r,oid:s,filepath:a})}}throw new J(`file or directory found at "${s}:${a}"`)}async function ae({fs:n,cache:t,gitdir:e,oid:i,filepath:r=void 0}){r!==void 0&&(i=await xe({fs:n,cache:t,gitdir:e,oid:i,filepath:r}));const{tree:s,oid:a}=await ee({fs:n,cache:t,gitdir:e,oid:i});return{oid:a,tree:s.entries()}}async function Ee({fs:n,gitdir:t,tree:e}){const i=pt.from(e).toObject();return await gt({fs:n,gitdir:t,type:"tree",object:i,format:"content"})}async function da({fs:n,cache:t,onSign:e,gitdir:i,ref:r,oid:s,note:a,force:o,author:u,committer:l,signingKey:c}){let h;try{h=await S.resolve({gitdir:i,fs:n,ref:r})}catch(k){if(!(k instanceof J))throw k}let d=(await ae({fs:n,cache:t,gitdir:i,oid:h||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;if(o)d=d.filter(k=>k.path!==s);else for(const k of d)if(k.path===s)throw new St("note",s);typeof a=="string"&&(a=U.from(a,"utf8"));const y=await gt({fs:n,gitdir:i,type:"blob",object:a,format:"content"});d.push({mode:"100644",path:s,oid:y,type:"blob"});const b=await Ee({fs:n,gitdir:i,tree:d});return await He({fs:n,cache:t,onSign:e,gitdir:i,ref:r,tree:b,parent:h&&[h],message:`Note added by 'isomorphic-git addNote'
`,author:u,committer:l,signingKey:c})}async function dn({fs:n,onSign:t,dir:e,gitdir:i=m.join(e,".git"),ref:r="refs/notes/commits",oid:s,note:a,force:o,author:u,committer:l,signingKey:c,cache:h={}}){try{w("fs",n),w("gitdir",i),w("oid",s),w("note",a),c&&w("onSign",t);const f=new q(n),d=await Dt({fs:f,gitdir:i,author:u});if(!d)throw new ht("author");const y=await re({fs:f,gitdir:i,author:d,committer:l});if(!y)throw new ht("committer");return await da({fs:new q(f),cache:h,onSign:t,gitdir:i,ref:r,oid:s,note:a,force:o,author:d,committer:y,signingKey:c})}catch(f){throw f.caller="git.addNote",f}}async function wn({fs:n,gitdir:t,remote:e,url:i,force:r}){if(e!==p.clean(e))throw new $t(e,p.clean(e));const s=await st.get({fs:n,gitdir:t});if(!r&&(await s.getSubsections("remote")).includes(e)&&i!==await s.get(`remote.${e}.url`))throw new St("remote",e);await s.set(`remote.${e}.url`,i),await s.set(`remote.${e}.fetch`,`+refs/heads/*:refs/remotes/${e}/*`),await st.save({fs:n,gitdir:t,config:s})}async function mn({fs:n,dir:t,gitdir:e=m.join(t,".git"),remote:i,url:r,force:s=!1}){try{return w("fs",n),w("gitdir",e),w("remote",i),w("url",r),await wn({fs:new q(n),gitdir:e,remote:i,url:r,force:s})}catch(a){throw a.caller="git.addRemote",a}}async function wa({fs:n,cache:t,onSign:e,gitdir:i,ref:r,tagger:s,message:a=r,gpgsig:o,object:u,signingKey:l,force:c=!1}){if(r=r.startsWith("refs/tags/")?r:`refs/tags/${r}`,!c&&await S.exists({fs:n,gitdir:i,ref:r}))throw new St("tag",r);const h=await S.resolve({fs:n,gitdir:i,ref:u||"HEAD"}),{type:f}=await et({fs:n,cache:t,gitdir:i,oid:h});let d=mt.from({object:h,type:f,tag:r.replace("refs/tags/",""),tagger:s,message:a,gpgsig:o});l&&(d=await mt.sign(d,e,l));const y=await gt({fs:n,gitdir:i,type:"tag",object:d.toObject()});await S.writeRef({fs:n,gitdir:i,ref:r,value:y})}async function pn({fs:n,onSign:t,dir:e,gitdir:i=m.join(e,".git"),ref:r,tagger:s,message:a=r,gpgsig:o,object:u,signingKey:l,force:c=!1,cache:h={}}){try{w("fs",n),w("gitdir",i),w("ref",r),l&&w("onSign",t);const f=new q(n),d=await Dt({fs:f,gitdir:i,author:s});if(!d)throw new ht("tagger");return await wa({fs:f,cache:h,onSign:t,gitdir:i,ref:r,tagger:d,message:a,gpgsig:o,object:u,signingKey:l,force:c})}catch(f){throw f.caller="git.annotatedTag",f}}async function ma({fs:n,gitdir:t,ref:e,object:i,checkout:r=!1,force:s=!1}){if(e!==p.clean(e))throw new $t(e,p.clean(e));const a=`refs/heads/${e}`;if(!s&&await S.exists({fs:n,gitdir:t,ref:a}))throw new St("branch",e,!1);let o;try{o=await S.resolve({fs:n,gitdir:t,ref:i||"HEAD"})}catch{}o&&await S.writeRef({fs:n,gitdir:t,ref:a,value:o}),r&&await S.writeSymbolicRef({fs:n,gitdir:t,ref:"HEAD",value:a})}async function yn({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i,object:r,checkout:s=!1,force:a=!1}){try{return w("fs",n),w("gitdir",e),w("ref",i),await ma({fs:new q(n),gitdir:e,ref:i,object:r,checkout:s,force:a})}catch(o){throw o.caller="git.branch",o}}const gn=(n,t)=>n==="."||t==null||t.length===0||t==="."?!0:t.length>=n.length?t.startsWith(n):n.startsWith(t);async function li({fs:n,cache:t,onProgress:e,onPostCheckout:i,dir:r,gitdir:s,remote:a,ref:o,filepaths:u,noCheckout:l,noUpdateHead:c,dryRun:h,force:f,track:d=!0,nonBlocking:y=!1,batchSize:b=100}){let _;if(i)try{_=await S.resolve({fs:n,gitdir:s,ref:"HEAD"})}catch{_="0000000000000000000000000000000000000000"}let k;try{k=await S.resolve({fs:n,gitdir:s,ref:o})}catch(v){if(o==="HEAD")throw v;const O=`${a}/${o}`;if(k=await S.resolve({fs:n,gitdir:s,ref:O}),d){const F=await st.get({fs:n,gitdir:s});await F.set(`branch.${o}.remote`,a),await F.set(`branch.${o}.merge`,`refs/heads/${o}`),await st.save({fs:n,gitdir:s,config:F})}await S.writeRef({fs:n,gitdir:s,ref:`refs/heads/${o}`,value:k})}if(!l){let v;try{v=await pa({fs:n,cache:t,onProgress:e,dir:r,gitdir:s,ref:o,force:f,filepaths:u})}catch($){throw $ instanceof J&&$.data.what===k?new de(o,k):$}const O=v.filter(([$])=>$==="conflict").map(([$,E])=>E);if(O.length>0)throw new he(O);const F=v.filter(([$])=>$==="error").map(([$,E])=>E);if(F.length>0)throw new M(F.join(", "));if(h){i&&await i({previousHead:_,newHead:k,type:u!=null&&u.length>0?"file":"branch"});return}let L=0;const N=v.length;if(await at.acquire({fs:n,gitdir:s,cache:t},async function($){await Promise.all(v.filter(([E])=>E==="delete"||E==="delete-index").map(async function([E,A]){const G=`${r}/${A}`;E==="delete"&&await n.rm(G),$.delete({filepath:A}),e&&await e({phase:"Updating workdir",loaded:++L,total:N})}))}),await at.acquire({fs:n,gitdir:s,cache:t},async function($){for(const[E,A]of v)if(E==="rmdir"||E==="rmdir-index"){const G=`${r}/${A}`;try{E==="rmdir"&&await n.rmdir(G),$.delete({filepath:A}),e&&await e({phase:"Updating workdir",loaded:++L,total:N})}catch(Y){if(Y.code==="ENOTEMPTY")console.log(`Did not delete ${A} because directory is not empty`);else throw Y}}}),await Promise.all(v.filter(([$])=>$==="mkdir"||$==="mkdir-index").map(async function([$,E]){const A=`${r}/${E}`;await n.mkdir(A),e&&await e({phase:"Updating workdir",loaded:++L,total:N})})),y){const $=v.filter(([A])=>A==="create"||A==="create-index"||A==="update"||A==="mkdir-index"),E=await bn("Update Working Dir",$.map(([A,G,Y,ot,Z])=>()=>ga({fs:n,cache:t,gitdir:s,dir:r},[A,G,Y,ot,Z])),e,b);await at.acquire({fs:n,gitdir:s,cache:t,allowUnmerged:!0},async function(A){await bn("Update Index",E.map(([G,Y,ot])=>()=>ya({index:A,fullpath:G,oid:Y,stats:ot})),e,b)})}else await at.acquire({fs:n,gitdir:s,cache:t,allowUnmerged:!0},async function($){await Promise.all(v.filter(([E])=>E==="create"||E==="create-index"||E==="update"||E==="mkdir-index").map(async function([E,A,G,Y,ot]){const Z=`${r}/${A}`;try{if(E!=="create-index"&&E!=="mkdir-index"){const{object:ut}=await et({fs:n,cache:t,gitdir:s,oid:G});if(ot&&await n.rm(Z),Y===33188)await n.write(Z,ut);else if(Y===33261)await n.write(Z,ut,{mode:511});else if(Y===40960)await n.writelink(Z,ut);else throw new M(`Invalid mode 0o${Y.toString(8)} detected in blob ${G}`)}const ct=await n.lstat(Z);Y===33261&&(ct.mode=493),E==="mkdir-index"&&(ct.mode=57344),$.insert({filepath:A,stats:ct,oid:G}),e&&await e({phase:"Updating workdir",loaded:++L,total:N})}catch(ct){console.log(ct)}}))});i&&await i({previousHead:_,newHead:k,type:u!=null&&u.length>0?"file":"branch"})}if(!c){const v=await S.expand({fs:n,gitdir:s,ref:o});v.startsWith("refs/heads")?await S.writeSymbolicRef({fs:n,gitdir:s,ref:"HEAD",value:v}):await S.writeRef({fs:n,gitdir:s,ref:"HEAD",value:k})}}async function pa({fs:n,cache:t,onProgress:e,dir:i,gitdir:r,ref:s,force:a,filepaths:o}){let u=0;return Bt({fs:n,cache:t,dir:i,gitdir:r,trees:[_t({ref:s}),ie(),Ft()],map:async function(l,[c,h,f]){if(l===".")return;if(o&&!o.some(y=>gn(l,y)))return null;switch(e&&await e({phase:"Analyzing workdir",loaded:++u}),[!!f,!!c,!!h].map(Number).join("")){case"000":return;case"001":return a&&o&&o.includes(l)?["delete",l]:void 0;case"010":switch(await c.type()){case"tree":return["mkdir",l];case"blob":return["create",l,await c.oid(),await c.mode()];case"commit":return["mkdir-index",l,await c.oid(),await c.mode()];default:return["error",`new entry Unhandled type ${await c.type()}`]}case"011":switch(`${await c.type()}-${await h.type()}`){case"tree-tree":return;case"tree-blob":case"blob-tree":return["conflict",l];case"blob-blob":return await c.oid()!==await h.oid()?a?["update",l,await c.oid(),await c.mode(),await c.mode()!==await h.mode()]:["conflict",l]:await c.mode()!==await h.mode()?a?["update",l,await c.oid(),await c.mode(),!0]:["conflict",l]:["create-index",l,await c.oid(),await c.mode()];case"commit-tree":return;case"commit-blob":return["conflict",l];default:return["error",`new entry Unhandled type ${c.type}`]}case"100":return["delete-index",l];case"101":switch(await f.type()){case"tree":return["rmdir-index",l];case"blob":return await f.oid()!==await h.oid()?a?["delete",l]:["conflict",l]:["delete",l];case"commit":return["rmdir-index",l];default:return["error",`delete entry Unhandled type ${await f.type()}`]}case"110":case"111":switch(`${await f.type()}-${await c.type()}`){case"tree-tree":return;case"blob-blob":{if(await f.oid()===await c.oid()&&await f.mode()===await c.mode()&&!a)return;if(h){if(await h.oid()!==await f.oid()&&await h.oid()!==await c.oid())return a?["update",l,await c.oid(),await c.mode(),await c.mode()!==await h.mode()]:["conflict",l]}else if(a)return["update",l,await c.oid(),await c.mode(),await c.mode()!==await f.mode()];return await c.mode()!==await f.mode()?["update",l,await c.oid(),await c.mode(),!0]:await c.oid()!==await f.oid()?["update",l,await c.oid(),await c.mode(),!1]:void 0}case"tree-blob":return["update-dir-to-blob",l,await c.oid()];case"blob-tree":return["update-blob-to-tree",l];case"commit-commit":return["mkdir-index",l,await c.oid(),await c.mode()];default:return["error",`update entry Unhandled type ${await f.type()}-${await c.type()}`]}}},reduce:async function(l,c){return c=Ki(c),l?l&&l[0]==="rmdir"?(c.push(l),c):(c.unshift(l),c):c}})}async function ya({index:n,fullpath:t,stats:e,oid:i}){try{n.insert({filepath:t,stats:e,oid:i})}catch(r){console.warn(`Error inserting ${t} into index:`,r)}}async function ga({fs:n,cache:t,gitdir:e,dir:i},[r,s,a,o,u]){const l=`${i}/${s}`;if(r!=="create-index"&&r!=="mkdir-index"){const{object:h}=await et({fs:n,cache:t,gitdir:e,oid:a});if(u&&await n.rm(l),o===33188)await n.write(l,h);else if(o===33261)await n.write(l,h,{mode:511});else if(o===40960)await n.writelink(l,h);else throw new M(`Invalid mode 0o${o.toString(8)} detected in blob ${a}`)}const c=await n.lstat(l);return o===33261&&(c.mode=493),r==="mkdir-index"&&(c.mode=57344),[s,a,c]}async function bn(n,t,e,i){const r=[];try{for(let s=0;s<t.length;s+=i){const a=t.slice(s,s+i).map(u=>u());(await Promise.allSettled(a)).forEach(u=>{u.status==="fulfilled"&&r.push(u.value)}),e&&await e({phase:"Updating workdir",loaded:s+a.length,total:t.length})}return r}catch(s){console.error(`Error during ${n}: ${s}`)}return r}async function ui({fs:n,onProgress:t,onPostCheckout:e,dir:i,gitdir:r=m.join(i,".git"),remote:s="origin",ref:a,filepaths:o,noCheckout:u=!1,noUpdateHead:l=a===void 0,dryRun:c=!1,force:h=!1,track:f=!0,cache:d={},nonBlocking:y=!1,batchSize:b=100}){try{w("fs",n),w("dir",i),w("gitdir",r);const _=a||"HEAD";return await li({fs:new q(n),cache:d,onProgress:t,onPostCheckout:e,dir:i,gitdir:r,remote:s,ref:_,filepaths:o,noCheckout:u,noUpdateHead:l,dryRun:c,force:h,track:f,nonBlocking:y,batchSize:b})}catch(_){throw _.caller="git.checkout",_}}const ba=new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");function Ht(n){const t=ba.exec(n);return t?t[1]==="remotes/"&&n.endsWith("/HEAD")?t[2].slice(0,-5):t[2]:n}async function Nt({fs:n,gitdir:t,fullname:e=!1,test:i=!1}){const r=await S.resolve({fs:n,gitdir:t,ref:"HEAD",depth:2});if(i)try{await S.resolve({fs:n,gitdir:t,ref:r})}catch{return}if(r.startsWith("refs/"))return e?r:Ht(r)}function _a(n){return n=n.replace(/^git@([^:]+):/,"https://$1/"),n=n.replace(/^ssh:\/\//,"https://"),n}function _n({username:n="",password:t=""}){return`Basic ${U.from(`${n}:${t}`).toString("base64")}`}async function je(n,t){const e=Yi(n);for(;;){const{value:i,done:r}=await e.next();if(i&&await t(i),r)break}e.return&&e.return()}async function ze(n){let t=0;const e=[];await je(n,s=>{e.push(s),t+=s.byteLength});const i=new Uint8Array(t);let r=0;for(const s of e)i.set(s,r),r+=s.byteLength;return i}function kn(n){let t=n.match(/^https?:\/\/([^/]+)@/);if(t==null)return{url:n,auth:{}};t=t[1];const[e,i]=t.split(":");return n=n.replace(`${t}@`,""),{url:n,auth:{username:e,password:i}}}function fi(n,t){const e=t.toString(16);return"0".repeat(n-e.length)+e}class rt{static flush(){return U.from("0000","utf8")}static delim(){return U.from("0001","utf8")}static encode(t){typeof t=="string"&&(t=U.from(t));const e=t.length+4,i=fi(4,e);return U.concat([U.from(i,"utf8"),t])}static streamReader(t){const e=new Zi(t);return async function(){try{let r=await e.read(4);if(r==null)return!0;if(r=parseInt(r.toString("utf8"),16),r===0||r===1)return null;const s=await e.read(r-4);return s??!0}catch(r){return t.error=r,!0}}}}async function vn(n){const t={};let e;for(;e=await n(),e!==!0;){if(e===null)continue;e=e.toString("utf8").replace(/\n$/,"");const i=e.indexOf("=");if(i>-1){const r=e.slice(0,i),s=e.slice(i+1);t[r]=s}else t[e]=!0}return{protocolVersion:2,capabilities2:t}}async function Sn(n,{service:t}){const e=new Set,i=new Map,r=new Map,s=rt.streamReader(n);let a=await s();for(;a===null;)a=await s();if(a===!0)throw new we;if(a.includes("version 2"))return vn(s);if(a.toString("utf8").replace(/\n$/,"")!==`# service=${t}`)throw new Ut(`# service=${t}\\n`,a.toString("utf8"));let o=await s();for(;o===null;)o=await s();if(o===!0)return{capabilities:e,refs:i,symrefs:r};if(o=o.toString("utf8"),o.includes("version 2"))return vn(s);const[u,l]=hi(o,"\0","\\x00");if(l.split(" ").map(c=>e.add(c)),u!=="0000000000000000000000000000000000000000 capabilities^{}"){const[c,h]=hi(u," "," ");for(i.set(h,c);;){const f=await s();if(f===!0)break;if(f!==null){const[d,y]=hi(f.toString("utf8")," "," ");i.set(y,d)}}}for(const c of e)if(c.startsWith("symref=")){const h=c.match(/symref=([^:]+):(.*)/);h.length===3&&r.set(h[1],h[2])}return{protocolVersion:1,capabilities:e,refs:i,symrefs:r}}function hi(n,t,e){const i=n.trim().split(t);if(i.length!==2)throw new Ut(`Two strings separated by '${e}'`,n.toString("utf8"));return i}const $n=(n,t)=>n.endsWith("?")?`${n}${t}`:`${n}/${t.replace(/^https?:\/\//,"")}`,xn=(n,t)=>{(t.username||t.password)&&(n.Authorization=_n(t)),t.headers&&Object.assign(n,t.headers)},di=async n=>{try{const t=U.from(await ze(n.body)),e=t.toString("utf8");return{preview:e.length<256?e:e.slice(0,256)+"...",response:e,data:t}}catch{return{}}};class qe{static async capabilities(){return["discover","connect"]}static async discover({http:t,onProgress:e,onAuth:i,onAuthSuccess:r,onAuthFailure:s,corsProxy:a,service:o,url:u,headers:l,protocolVersion:c}){let{url:h,auth:f}=kn(u);const d=a?$n(a,h):h;(f.username||f.password)&&(l.Authorization=_n(f)),c===2&&(l["Git-Protocol"]="version=2");let y,b,_=!1;do if(y=await t.request({onProgress:e,method:"GET",url:`${d}/info/refs?service=${o}`,headers:l}),b=!1,y.statusCode===401||y.statusCode===203){const k=_?s:i;if(k){if(f=await k(h,{...f,headers:{...l}}),f&&f.cancel)throw new te;f&&(xn(l,f),_=!0,b=!0)}}else y.statusCode===200&&_&&r&&await r(h,f);while(b);if(y.statusCode!==200){const{response:k}=await di(y);throw new Zt(y.statusCode,y.statusMessage,k)}if(y.headers["content-type"]===`application/x-${o}-advertisement`){const k=await Sn(y.body,{service:o});return k.auth=f,k}else{const{preview:k,response:v,data:O}=await di(y);try{const F=await Sn([O],{service:o});return F.auth=f,F}catch{throw new be(k,v)}}}static async connect({http:t,onProgress:e,corsProxy:i,service:r,url:s,auth:a,body:o,headers:u}){const l=kn(s);l&&(s=l.url),i&&(s=$n(i,s)),u["content-type"]=`application/x-${r}-request`,u.accept=`application/x-${r}-result`,xn(u,a);const c=await t.request({onProgress:e,method:"POST",url:`${s}/${r}`,body:o,headers:u});if(c.statusCode!==200){const{response:h}=di(c);throw new Zt(c.statusCode,c.statusMessage,h)}return c}}class Le{static getRemoteHelperFor({url:t}){const e=new Map;e.set("http",qe),e.set("https",qe);const i=ka({url:t});if(!i)throw new ke(t);if(e.has(i.transport))return e.get(i.transport);throw new _e(t,i.transport,i.transport==="ssh"?_a(t):void 0)}}function ka({url:n}){if(n.startsWith("git@"))return{transport:"ssh",address:n};const t=n.match(/(\w+)(:\/\/|::)(.*)/);if(t!==null){if(t[2]==="://")return{transport:t[1],address:t[0]};if(t[2]==="::")return{transport:t[1],address:t[3]}}}let zt=null;class Re{static async read({fs:t,gitdir:e}){zt===null&&(zt=new B);const i=m.join(e,"shallow"),r=new Set;return await zt.acquire(i,async function(){const s=await t.read(i,{encoding:"utf8"});if(s===null||s.trim()==="")return r;s.trim().split(`
`).map(a=>r.add(a))}),r}static async write({fs:t,gitdir:e,oids:i}){zt===null&&(zt=new B);const r=m.join(e,"shallow");if(i.size>0){const s=[...i].join(`
`)+`
`;await zt.acquire(r,async function(){await t.write(r,s,{encoding:"utf8"})})}else await zt.acquire(r,async function(){await t.rm(r)})}}async function va({fs:n,gitdir:t,oid:e}){const i=`objects/${e.slice(0,2)}/${e.slice(2)}`;return n.exists(`${t}/${i}`)}async function Sa({fs:n,cache:t,gitdir:e,oid:i,getExternalRefDelta:r}){let s=await n.readdir(m.join(e,"objects/pack"));s=s.filter(a=>a.endsWith(".idx"));for(const a of s){const o=`${e}/objects/pack/${a}`,u=await ni({fs:n,cache:t,filename:o,getExternalRefDelta:r});if(u.error)throw new M(u.error);if(u.offsets.has(i))return!0}return!1}async function En({fs:n,cache:t,gitdir:e,oid:i,format:r="content"}){const s=o=>et({fs:n,cache:t,gitdir:e,oid:o});let a=await va({fs:n,gitdir:e,oid:i});return a||(a=await Sa({fs:n,cache:t,gitdir:e,oid:i,getExternalRefDelta:s})),a}function $a(n){const r="5041434b"+"00000002"+"00000000";return n.slice(0,12).toString("hex")===r}function jn(n,t){const e=n.map(i=>i.split("=",1)[0]);return t.filter(i=>{const r=i.split("=",1)[0];return e.includes(r)})}const We={name:"isomorphic-git",version:"1.33.1",agent:"git/isomorphic-git@1.33.1"};class Ge{constructor(){this._queue=[]}write(t){if(this._ended)throw Error("You cannot write to a FIFO that has already been ended!");if(this._waiting){const e=this._waiting;this._waiting=null,e({value:t})}else this._queue.push(t)}end(){if(this._ended=!0,this._waiting){const t=this._waiting;this._waiting=null,t({done:!0})}}destroy(t){this.error=t,this.end()}async next(){if(this._queue.length>0)return{value:this._queue.shift()};if(this._ended)return{done:!0};if(this._waiting)throw Error("You cannot call read until the previous call to read has returned!");return new Promise(t=>{this._waiting=t})}}function xa(n){const t=n.indexOf("\r"),e=n.indexOf(`
`);return t===-1&&e===-1?-1:t===-1?e+1:e===-1?t+1:e===t+1?e+1:Math.min(t,e)+1}function Rn(n){const t=new Ge;let e="";return(async()=>(await je(n,i=>{for(i=i.toString("utf8"),e+=i;;){const r=xa(e);if(r===-1)break;t.write(e.slice(0,r)),e=e.slice(r)}}),e.length>0&&t.write(e),t.end()))(),t}class On{static demux(t){const e=rt.streamReader(t),i=new Ge,r=new Ge,s=new Ge,a=async function(){const o=await e();if(o===null)return a();if(o===!0){i.end(),s.end(),t.error?r.destroy(t.error):r.end();return}switch(o[0]){case 1:{r.write(o.slice(1));break}case 2:{s.write(o.slice(1));break}case 3:{const u=o.slice(1);s.write(u),i.end(),s.end(),r.destroy(new Error(u.toString("utf8")));return}default:i.write(o)}a()};return a(),{packetlines:i,packfile:r,progress:s}}}async function Ea(n){const{packetlines:t,packfile:e,progress:i}=On.demux(n),r=[],s=[],a=[];let o=!1,u=!1;return new Promise((l,c)=>{je(t,h=>{const f=h.toString("utf8").trim();if(f.startsWith("shallow")){const d=f.slice(-41).trim();d.length!==40&&c(new Pt(d)),r.push(d)}else if(f.startsWith("unshallow")){const d=f.slice(-41).trim();d.length!==40&&c(new Pt(d)),s.push(d)}else if(f.startsWith("ACK")){const[,d,y]=f.split(" ");a.push({oid:d,status:y}),y||(u=!0)}else f.startsWith("NAK")?(o=!0,u=!0):(u=!0,o=!0);u&&(n.error?c(n.error):l({shallows:r,unshallows:s,acks:a,nak:o,packfile:e,progress:i}))}).finally(()=>{u||(n.error?c(n.error):l({shallows:r,unshallows:s,acks:a,nak:o,packfile:e,progress:i}))})})}function ja({capabilities:n=[],wants:t=[],haves:e=[],shallows:i=[],depth:r=null,since:s=null,exclude:a=[]}){const o=[];t=[...new Set(t)];let u=` ${n.join(" ")}`;for(const l of t)o.push(rt.encode(`want ${l}${u}
`)),u="";for(const l of i)o.push(rt.encode(`shallow ${l}
`));r!==null&&o.push(rt.encode(`deepen ${r}
`)),s!==null&&o.push(rt.encode(`deepen-since ${Math.floor(s.valueOf()/1e3)}
`));for(const l of a)o.push(rt.encode(`deepen-not ${l}
`));o.push(rt.flush());for(const l of e)o.push(rt.encode(`have ${l}
`));return o.push(rt.encode(`done
`)),o}async function wi({fs:n,cache:t,http:e,onProgress:i,onMessage:r,onAuth:s,onAuthSuccess:a,onAuthFailure:o,gitdir:u,ref:l,remoteRef:c,remote:h,url:f,corsProxy:d,depth:y=null,since:b=null,exclude:_=[],relative:k=!1,tags:v=!1,singleBranch:O=!1,headers:F={},prune:L=!1,pruneTags:N=!1}){const $=l||await Nt({fs:n,gitdir:u,test:!0}),E=await st.get({fs:n,gitdir:u}),A=h||$&&await E.get(`branch.${$}.remote`)||"origin",G=f||await E.get(`remote.${A}.url`);if(typeof G>"u")throw new yt("remote OR url");const Y=c||$&&await E.get(`branch.${$}.merge`)||l||"HEAD";d===void 0&&(d=await E.get("http.corsProxy"));const ot=Le.getRemoteHelperFor({url:G}),Z=await ot.discover({http:e,onAuth:s,onAuthSuccess:a,onAuthFailure:o,corsProxy:d,service:"git-upload-pack",url:G,headers:F,protocolVersion:1}),ct=Z.auth,ut=Z.refs;if(ut.size===0)return{defaultBranch:null,fetchHead:null,fetchHeadDescription:null};if(y!==null&&!Z.capabilities.has("shallow"))throw new At("shallow","depth");if(b!==null&&!Z.capabilities.has("deepen-since"))throw new At("deepen-since","since");if(_.length>0&&!Z.capabilities.has("deepen-not"))throw new At("deepen-not","exclude");if(k===!0&&!Z.capabilities.has("deepen-relative"))throw new At("deepen-relative","relative");const{oid:qt,fullref:Lt}=S.resolveAgainstMap({ref:Y,map:ut});for(const K of ut.keys())K===Lt||K==="HEAD"||K.startsWith("refs/heads/")||v&&K.startsWith("refs/tags/")||ut.delete(K);const ce=jn([...Z.capabilities],["multi_ack_detailed","no-done","side-band-64k","ofs-delta",`agent=${We.agent}`]);k&&ce.push("deepen-relative");const _i=O?[qt]:ut.values(),ki=O?[$]:await S.listRefs({fs:n,gitdir:u,filepath:"refs"});let kt=[];for(let K of ki)try{K=await S.expand({fs:n,gitdir:u,ref:K});const ft=await S.resolve({fs:n,gitdir:u,ref:K});await En({fs:n,cache:t,gitdir:u,oid:ft})&&kt.push(ft)}catch{}kt=[...new Set(kt)];const nt=await Re.read({fs:n,gitdir:u}),xt=Z.capabilities.has("shallow")?[...nt]:[],dt=ja({capabilities:ce,wants:_i,haves:kt,shallows:xt,depth:y,since:b,exclude:_}),Oe=U.from(await ze(dt)),Wt=await ot.connect({http:e,onProgress:i,corsProxy:d,service:"git-upload-pack",url:G,auth:ct,body:[Oe],headers:F}),lt=await Ea(Wt.body);Wt.headers&&(lt.headers=Wt.headers);for(const K of lt.shallows)if(!nt.has(K))try{const{object:ft}=await et({fs:n,cache:t,gitdir:u,oid:K}),vt=new it(ft),Et=await Promise.all(vt.headers().parent.map(Pe=>En({fs:n,cache:t,gitdir:u,oid:Pe})));Et.length===0||Et.every(Pe=>Pe)||nt.add(K)}catch{nt.add(K)}for(const K of lt.unshallows)nt.delete(K);if(await Re.write({fs:n,gitdir:u,oids:nt}),O){const K=new Map([[Lt,qt]]),ft=new Map;let vt=10,Et=Lt;for(;vt--;){const Si=Z.symrefs.get(Et);if(Si===void 0)break;ft.set(Et,Si),Et=Si}const vi=ut.get(Et);vi&&K.set(Et,vi);const{pruned:Pe}=await S.updateRemoteRefs({fs:n,gitdir:u,remote:A,refs:K,symrefs:ft,tags:v,prune:L});L&&(lt.pruned=Pe)}else{const{pruned:K}=await S.updateRemoteRefs({fs:n,gitdir:u,remote:A,refs:ut,symrefs:Z.symrefs,tags:v,prune:L,pruneTags:N});L&&(lt.pruned=K)}if(lt.HEAD=Z.symrefs.get("HEAD"),lt.HEAD===void 0){const{oid:K}=S.resolveAgainstMap({ref:"HEAD",map:ut});for(const[ft,vt]of ut.entries())if(ft!=="HEAD"&&vt===K){lt.HEAD=ft;break}}const yo=Lt.startsWith("refs/tags")?"tag":"branch";if(lt.FETCH_HEAD={oid:qt,description:`${yo} '${Ht(Lt)}' of ${G}`},i||r){const K=Rn(lt.progress);je(K,async ft=>{if(r&&await r(ft),i){const vt=ft.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);vt&&await i({phase:vt[1].trim(),loaded:parseInt(vt[2],10),total:parseInt(vt[3],10)})}})}const Xe=U.from(await ze(lt.packfile));if(Wt.body.error)throw Wt.body.error;const Jr=Xe.slice(-20).toString("hex"),Ie={defaultBranch:lt.HEAD,fetchHead:lt.FETCH_HEAD.oid,fetchHeadDescription:lt.FETCH_HEAD.description};if(lt.headers&&(Ie.headers=lt.headers),L&&(Ie.pruned=lt.pruned),Jr!==""&&!$a(Xe)){Ie.packfile=`objects/pack/pack-${Jr}.pack`;const K=m.join(u,Ie.packfile);await n.write(K,Xe);const ft=Et=>et({fs:n,cache:t,gitdir:u,oid:Et}),vt=await Yt.fromPack({pack:Xe,getExternalRefDelta:ft,onProgress:i});await n.write(K.replace(/\.pack$/,".idx"),await vt.toBuffer())}return Ie}async function In({fs:n,bare:t=!1,dir:e,gitdir:i=t?e:m.join(e,".git"),defaultBranch:r="master"}){if(await n.exists(i+"/config"))return;let s=["hooks","info","objects/info","objects/pack","refs/heads","refs/tags"];s=s.map(a=>i+"/"+a);for(const a of s)await n.mkdir(a);await n.write(i+"/config",`[core]
	repositoryformatversion = 0
	filemode = false
	bare = ${t}
`+(t?"":`	logallrefupdates = true
`)+`	symlinks = false
	ignorecase = true
`),await n.write(i+"/HEAD",`ref: refs/heads/${r}
`)}async function Ra({fs:n,cache:t,http:e,onProgress:i,onMessage:r,onAuth:s,onAuthSuccess:a,onAuthFailure:o,onPostCheckout:u,dir:l,gitdir:c,url:h,corsProxy:f,ref:d,remote:y,depth:b,since:_,exclude:k,relative:v,singleBranch:O,noCheckout:F,noTags:L,headers:N,nonBlocking:$,batchSize:E=100}){try{if(await In({fs:n,gitdir:c}),await wn({fs:n,gitdir:c,remote:y,url:h,force:!1}),f){const Y=await st.get({fs:n,gitdir:c});await Y.set("http.corsProxy",f),await st.save({fs:n,gitdir:c,config:Y})}const{defaultBranch:A,fetchHead:G}=await wi({fs:n,cache:t,http:e,onProgress:i,onMessage:r,onAuth:s,onAuthSuccess:a,onAuthFailure:o,gitdir:c,ref:d,remote:y,corsProxy:f,depth:b,since:_,exclude:k,relative:v,singleBranch:O,headers:N,tags:!L});if(G===null)return;d=d||A,d=d.replace("refs/heads/",""),await li({fs:n,cache:t,onProgress:i,onPostCheckout:u,dir:l,gitdir:c,ref:d,remote:y,noCheckout:F,nonBlocking:$,batchSize:E})}catch(A){throw await n.rmdir(c,{recursive:!0,maxRetries:10}).catch(()=>{}),A}}async function Pn({fs:n,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,onPostCheckout:o,dir:u,gitdir:l=m.join(u,".git"),url:c,corsProxy:h=void 0,ref:f=void 0,remote:d="origin",depth:y=void 0,since:b=void 0,exclude:_=[],relative:k=!1,singleBranch:v=!1,noCheckout:O=!1,noTags:F=!1,headers:L={},cache:N={},nonBlocking:$=!1,batchSize:E=100}){try{return w("fs",n),w("http",t),w("gitdir",l),O||w("dir",u),w("url",c),await Ra({fs:new q(n),cache:N,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,onPostCheckout:o,dir:u,gitdir:l,url:c,corsProxy:h,ref:f,remote:d,depth:y,since:b,exclude:_,relative:k,singleBranch:v,noCheckout:O,noTags:F,headers:L,nonBlocking:$,batchSize:E})}catch(A){throw A.caller="git.clone",A}}async function Tn({fs:n,onSign:t,dir:e,gitdir:i=m.join(e,".git"),message:r,author:s,committer:a,signingKey:o,amend:u=!1,dryRun:l=!1,noUpdateBranch:c=!1,ref:h,parent:f,tree:d,cache:y={}}){try{w("fs",n),u||w("message",r),o&&w("onSign",t);const b=new q(n);return await He({fs:b,cache:y,onSign:t,gitdir:i,message:r,author:s,committer:a,signingKey:o,amend:u,dryRun:l,noUpdateBranch:c,ref:h,parent:f,tree:d})}catch(b){throw b.caller="git.commit",b}}async function Cn({fs:n,dir:t,gitdir:e=m.join(t,".git"),fullname:i=!1,test:r=!1}){try{return w("fs",n),w("gitdir",e),await Nt({fs:new q(n),gitdir:e,fullname:i,test:r})}catch(s){throw s.caller="git.currentBranch",s}}async function Oa({fs:n,gitdir:t,ref:e}){if(e=e.startsWith("refs/heads/")?e:`refs/heads/${e}`,!await S.exists({fs:n,gitdir:t,ref:e}))throw new J(e);const r=await S.expand({fs:n,gitdir:t,ref:e}),s=await Nt({fs:n,gitdir:t,fullname:!0});if(r===s){const u=await S.resolve({fs:n,gitdir:t,ref:r});await S.writeRef({fs:n,gitdir:t,ref:"HEAD",value:u})}await S.deleteRef({fs:n,gitdir:t,ref:r});const a=Ht(e),o=await st.get({fs:n,gitdir:t});await o.deleteSection("branch",a),await st.save({fs:n,gitdir:t,config:o})}async function An({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i}){try{return w("fs",n),w("ref",i),await Oa({fs:new q(n),gitdir:e,ref:i})}catch(r){throw r.caller="git.deleteBranch",r}}async function Bn({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i}){try{w("fs",n),w("ref",i),await S.deleteRef({fs:new q(n),gitdir:e,ref:i})}catch(r){throw r.caller="git.deleteRef",r}}async function Ia({fs:n,gitdir:t,remote:e}){const i=await st.get({fs:n,gitdir:t});await i.deleteSection("remote",e),await st.save({fs:n,gitdir:t,config:i})}async function Dn({fs:n,dir:t,gitdir:e=m.join(t,".git"),remote:i}){try{return w("fs",n),w("remote",i),await Ia({fs:new q(n),gitdir:e,remote:i})}catch(r){throw r.caller="git.deleteRemote",r}}async function Pa({fs:n,gitdir:t,ref:e}){e=e.startsWith("refs/tags/")?e:`refs/tags/${e}`,await S.deleteRef({fs:n,gitdir:t,ref:e})}async function Nn({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i}){try{return w("fs",n),w("ref",i),await Pa({fs:new q(n),gitdir:e,ref:i})}catch(r){throw r.caller="git.deleteTag",r}}async function Ta({fs:n,gitdir:t,oid:e}){const i=e.slice(0,2);return(await n.readdir(`${t}/objects/${i}`)).map(s=>`${i}${s}`).filter(s=>s.startsWith(e))}async function Ca({fs:n,cache:t,gitdir:e,oid:i,getExternalRefDelta:r}){const s=[];let a=await n.readdir(m.join(e,"objects/pack"));a=a.filter(o=>o.endsWith(".idx"));for(const o of a){const u=`${e}/objects/pack/${o}`,l=await ni({fs:n,cache:t,filename:u,getExternalRefDelta:r});if(l.error)throw new M(l.error);for(const c of l.offsets.keys())c.startsWith(i)&&s.push(c)}return s}async function Aa({fs:n,cache:t,gitdir:e,oid:i}){const r=o=>et({fs:n,cache:t,gitdir:e,oid:o}),s=await Ta({fs:n,gitdir:e,oid:i}),a=await Ca({fs:n,cache:t,gitdir:e,oid:i,getExternalRefDelta:r});for(const o of a)s.indexOf(o)===-1&&s.push(o);if(s.length===1)return s[0];throw s.length>1?new fe("oids",i,s):new J(`an object matching "${i}"`)}async function Mn({fs:n,dir:t,gitdir:e=m.join(t,".git"),oid:i,cache:r={}}){try{return w("fs",n),w("gitdir",e),w("oid",i),await Aa({fs:new q(n),cache:r,gitdir:e,oid:i})}catch(s){throw s.caller="git.expandOid",s}}async function Fn({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i}){try{return w("fs",n),w("gitdir",e),w("ref",i),await S.expand({fs:new q(n),gitdir:e,ref:i})}catch(r){throw r.caller="git.expandRef",r}}async function mi({fs:n,cache:t,gitdir:e,oids:i}){const r={},s=i.length;let a=i.map((o,u)=>({index:u,oid:o}));for(;a.length;){const o=new Set;for(const{oid:l,index:c}of a)r[l]||(r[l]=new Set),r[l].add(c),r[l].size===s&&o.add(l);if(o.size>0)return[...o];const u=new Map;for(const{oid:l,index:c}of a)try{const{object:h}=await et({fs:n,cache:t,gitdir:e,oid:l}),f=it.from(h),{parent:d}=f.parseHeaders();for(const y of d)(!r[y]||!r[y].has(c))&&u.set(y+":"+c,{oid:y,index:c})}catch{}a=Array.from(u.values())}return[]}const pi=/^.*(\r?\n|$)/gm;function Ba({branches:n,contents:t}){const e=n[1],i=n[2],r=t[0],s=t[1],a=t[2],o=s.match(pi),u=r.match(pi),l=a.match(pi),c=H(o,u,l),h=7;let f="",d=!0;for(const y of c)y.ok&&(f+=y.ok.join("")),y.conflict&&(d=!1,f+=`${"<".repeat(h)} ${e}
`,f+=y.conflict.a.join(""),f+=`${"=".repeat(h)}
`,f+=y.conflict.b.join(""),f+=`${">".repeat(h)} ${i}
`);return{cleanMerge:d,mergedText:f}}async function Da({fs:n,cache:t,dir:e,gitdir:i=m.join(e,".git"),index:r,ourOid:s,baseOid:a,theirOid:o,ourName:u="ours",baseName:l="base",theirName:c="theirs",dryRun:h=!1,abortOnConflict:f=!0,mergeDriver:d}){const y=_t({ref:s}),b=_t({ref:a}),_=_t({ref:o}),k=[],v=[],O=[],F=[],L=await Bt({fs:n,cache:t,dir:e,gitdir:i,trees:[y,b,_],map:async function(N,[$,E,A]){const G=Ce(N),Y=await Ue($,E),ot=await Ue(A,E);switch(`${Y}-${ot}`){case"false-false":return{mode:await E.mode(),path:G,oid:await E.oid(),type:await E.type()};case"false-true":return!A&&await $.type()==="tree"?{mode:await $.mode(),path:G,oid:await $.oid(),type:await $.type()}:A?{mode:await A.mode(),path:G,oid:await A.oid(),type:await A.type()}:void 0;case"true-false":return!$&&await A.type()==="tree"?{mode:await A.mode(),path:G,oid:await A.oid(),type:await A.type()}:$?{mode:await $.mode(),path:G,oid:await $.oid(),type:await $.type()}:void 0;case"true-true":{if($&&A&&await $.type()==="tree"&&await A.type()==="tree")return{mode:await $.mode(),path:G,oid:await $.oid(),type:"tree"};if($&&A&&await $.type()==="blob"&&await A.type()==="blob")return Na({fs:n,gitdir:i,path:G,ours:$,base:E,theirs:A,ourName:u,baseName:l,theirName:c,mergeDriver:d}).then(async Z=>{if(Z.cleanMerge)f||r.insert({filepath:N,oid:Z.mergeResult.oid,stage:0});else if(k.push(N),v.push(N),!f){let ct="";E&&await E.type()==="blob"&&(ct=await E.oid());const ut=await $.oid(),qt=await A.oid();r.delete({filepath:N}),ct&&r.insert({filepath:N,oid:ct,stage:1}),r.insert({filepath:N,oid:ut,stage:2}),r.insert({filepath:N,oid:qt,stage:3})}return Z.mergeResult});if(E&&!$&&A&&await E.type()==="blob"&&await A.type()==="blob"){if(k.push(N),O.push(N),!f){const Z=await E.oid(),ct=await A.oid();r.delete({filepath:N}),r.insert({filepath:N,oid:Z,stage:1}),r.insert({filepath:N,oid:ct,stage:3})}return{mode:await A.mode(),oid:await A.oid(),type:"blob",path:G}}if(E&&$&&!A&&await E.type()==="blob"&&await $.type()==="blob"){if(k.push(N),F.push(N),!f){const Z=await E.oid(),ct=await $.oid();r.delete({filepath:N}),r.insert({filepath:N,oid:Z,stage:1}),r.insert({filepath:N,oid:ct,stage:2})}return{mode:await $.mode(),oid:await $.oid(),type:"blob",path:G}}if(E&&!$&&!A&&(await E.type()==="blob"||await E.type()==="tree"))return;throw new Qt}}},reduce:k.length!==0&&(!e||f)?void 0:async(N,$)=>{const E=$.filter(Boolean);if(N&&!(N&&N.type==="tree"&&E.length===0&&N.path!==".")){if(E.length>0||N.path==="."&&E.length===0){const G=new pt(E).toObject(),Y=await gt({fs:n,gitdir:i,type:"tree",object:G,dryRun:h});N.oid=Y}return N}}});return k.length!==0?(e&&!f&&await Bt({fs:n,cache:t,dir:e,gitdir:i,trees:[_t({ref:L.oid})],map:async function(N,[$]){const E=`${e}/${N}`;if(await $.type()==="blob"){const A=await $.mode(),G=new TextDecoder().decode(await $.content());await n.write(E,G,{mode:A})}return!0}}),new Jt(k,v,O,F)):L.oid}async function Na({fs:n,gitdir:t,path:e,ours:i,base:r,theirs:s,ourName:a,theirName:o,baseName:u,dryRun:l,mergeDriver:c=Ba}){const h="blob";let f="100755",d="",y="";r&&await r.type()==="blob"&&(f=await r.mode(),d=await r.oid(),y=U.from(await r.content()).toString("utf8"));const b=f===await i.mode()?await s.mode():await i.mode();if(await i.oid()===await s.oid())return{cleanMerge:!0,mergeResult:{mode:b,path:e,oid:await i.oid(),type:h}};if(await i.oid()===d)return{cleanMerge:!0,mergeResult:{mode:b,path:e,oid:await s.oid(),type:h}};if(await s.oid()===d)return{cleanMerge:!0,mergeResult:{mode:b,path:e,oid:await i.oid(),type:h}};const _=U.from(await i.content()).toString("utf8"),k=U.from(await s.content()).toString("utf8"),{mergedText:v,cleanMerge:O}=await c({branches:[u,a,o],contents:[y,_,k],path:e}),F=await gt({fs:n,gitdir:t,type:"blob",object:U.from(v,"utf8"),dryRun:l});return{cleanMerge:O,mergeResult:{mode:b,path:e,oid:F,type:h}}}async function Un({fs:n,cache:t,dir:e,gitdir:i,ours:r,theirs:s,fastForward:a=!0,fastForwardOnly:o=!1,dryRun:u=!1,noUpdateBranch:l=!1,abortOnConflict:c=!0,message:h,author:f,committer:d,signingKey:y,onSign:b,mergeDriver:_,allowUnrelatedHistories:k=!1}){r===void 0&&(r=await Nt({fs:n,gitdir:i,fullname:!0})),r=await S.expand({fs:n,gitdir:i,ref:r}),s=await S.expand({fs:n,gitdir:i,ref:s});const v=await S.resolve({fs:n,gitdir:i,ref:r}),O=await S.resolve({fs:n,gitdir:i,ref:s}),F=await mi({fs:n,cache:t,gitdir:i,oids:[v,O]});if(F.length!==1)if(F.length===0&&k)F.push("4b825dc642cb6eb9a060e54bf8d69288fbee4904");else throw new Qt;const L=F[0];if(L===O)return{oid:v,alreadyMerged:!0};if(a&&L===v)return!u&&!l&&await S.writeRef({fs:n,gitdir:i,ref:r,value:O}),{oid:O,fastForward:!0};{if(o)throw new me;const N=await at.acquire({fs:n,gitdir:i,cache:t,allowUnmerged:!1},async E=>Da({fs:n,cache:t,dir:e,gitdir:i,index:E,ourOid:v,theirOid:O,baseOid:L,ourName:Ht(r),baseName:"base",theirName:Ht(s),dryRun:u,abortOnConflict:c,mergeDriver:_}));if(N instanceof Jt)throw N;return h||(h=`Merge branch '${Ht(s)}' into ${Ht(r)}`),{oid:await He({fs:n,cache:t,gitdir:i,message:h,ref:r,tree:N,parent:[v,O],author:f,committer:d,signingKey:y,onSign:b,dryRun:u,noUpdateBranch:l}),tree:N,mergeCommit:!0}}}async function Hn({fs:n,cache:t,http:e,onProgress:i,onMessage:r,onAuth:s,onAuthSuccess:a,onAuthFailure:o,dir:u,gitdir:l,ref:c,url:h,remote:f,remoteRef:d,prune:y,pruneTags:b,fastForward:_,fastForwardOnly:k,corsProxy:v,singleBranch:O,headers:F,author:L,committer:N,signingKey:$}){try{if(!c){const G=await Nt({fs:n,gitdir:l});if(!G)throw new yt("ref");c=G}const{fetchHead:E,fetchHeadDescription:A}=await wi({fs:n,cache:t,http:e,onProgress:i,onMessage:r,onAuth:s,onAuthSuccess:a,onAuthFailure:o,gitdir:l,corsProxy:v,ref:c,url:h,remote:f,remoteRef:d,singleBranch:O,headers:F,prune:y,pruneTags:b});await Un({fs:n,cache:t,gitdir:l,ours:c,theirs:E,fastForward:_,fastForwardOnly:k,message:`Merge ${A}`,author:L,committer:N,signingKey:$,dryRun:!1,noUpdateBranch:!1}),await li({fs:n,cache:t,onProgress:i,dir:u,gitdir:l,ref:c,remote:f,noCheckout:!1})}catch(E){throw E.caller="git.pull",E}}async function zn({fs:n,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:u=m.join(o,".git"),ref:l,url:c,remote:h,remoteRef:f,corsProxy:d,singleBranch:y,headers:b={},cache:_={}}){try{w("fs",n),w("http",t),w("gitdir",u);const k={name:"",email:"",timestamp:Date.now(),timezoneOffset:0};return await Hn({fs:new q(n),cache:_,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:u,ref:l,url:c,remote:h,remoteRef:f,fastForwardOnly:!0,corsProxy:d,singleBranch:y,headers:b,author:k,committer:k})}catch(k){throw k.caller="git.fastForward",k}}async function qn({fs:n,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:u=m.join(o,".git"),ref:l,remote:c,remoteRef:h,url:f,corsProxy:d,depth:y=null,since:b=null,exclude:_=[],relative:k=!1,tags:v=!1,singleBranch:O=!1,headers:F={},prune:L=!1,pruneTags:N=!1,cache:$={}}){try{return w("fs",n),w("http",t),w("gitdir",u),await wi({fs:new q(n),cache:$,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,gitdir:u,ref:l,remote:c,remoteRef:h,url:f,corsProxy:d,depth:y,since:b,exclude:_,relative:k,tags:v,singleBranch:O,headers:F,prune:L,pruneTags:N})}catch(E){throw E.caller="git.fetch",E}}async function Ln({fs:n,dir:t,gitdir:e=m.join(t,".git"),oids:i,cache:r={}}){try{return w("fs",n),w("gitdir",e),w("oids",i),await mi({fs:new q(n),cache:r,gitdir:e,oids:i})}catch(s){throw s.caller="git.findMergeBase",s}}async function Wn({fs:n,filepath:t}){if(await n.exists(m.join(t,".git")))return t;{const e=Vt(t);if(e===t)throw new J(`git root for ${t}`);return Wn({fs:n,filepath:e})}}async function Gn({fs:n,filepath:t}){try{return w("fs",n),w("filepath",t),await Wn({fs:new q(n),filepath:t})}catch(e){throw e.caller="git.findRoot",e}}async function Vn({fs:n,dir:t,gitdir:e=m.join(t,".git"),path:i}){try{return w("fs",n),w("gitdir",e),w("path",i),await $e({fs:new q(n),gitdir:e,path:i})}catch(r){throw r.caller="git.getConfig",r}}async function Ma({fs:n,gitdir:t,path:e}){return(await st.get({fs:n,gitdir:t})).getall(e)}async function Xn({fs:n,dir:t,gitdir:e=m.join(t,".git"),path:i}){try{return w("fs",n),w("gitdir",e),w("path",i),await Ma({fs:new q(n),gitdir:e,path:i})}catch(r){throw r.caller="git.getConfigAll",r}}async function Yn({http:n,onAuth:t,onAuthSuccess:e,onAuthFailure:i,corsProxy:r,url:s,headers:a={},forPush:o=!1}){try{w("http",n),w("url",s);const l=await Le.getRemoteHelperFor({url:s}).discover({http:n,onAuth:t,onAuthSuccess:e,onAuthFailure:i,corsProxy:r,service:o?"git-receive-pack":"git-upload-pack",url:s,headers:a,protocolVersion:1}),c={capabilities:[...l.capabilities]};for(const[h,f]of l.refs){const d=h.split("/"),y=d.pop();let b=c;for(const _ of d)b[_]=b[_]||{},b=b[_];b[y]=f}for(const[h,f]of l.symrefs){const d=h.split("/"),y=d.pop();let b=c;for(const _ of d)b[_]=b[_]||{},b=b[_];b[y]=f}return c}catch(u){throw u.caller="git.getRemoteInfo",u}}function Zn(n,t,e,i){const r=[];for(const[s,a]of n.refs){if(t&&!s.startsWith(t))continue;if(s.endsWith("^{}")){if(i){const u=s.replace("^{}",""),l=r[r.length-1],c=l.ref===u?l:r.find(h=>h.ref===u);if(c===void 0)throw new Error("I did not expect this to happen");c.peeled=a}continue}const o={ref:s,oid:a};e&&n.symrefs.has(s)&&(o.target=n.symrefs.get(s)),r.push(o)}return r}async function Qn({http:n,onAuth:t,onAuthSuccess:e,onAuthFailure:i,corsProxy:r,url:s,headers:a={},forPush:o=!1,protocolVersion:u=2}){try{w("http",n),w("url",s);const c=await Le.getRemoteHelperFor({url:s}).discover({http:n,onAuth:t,onAuthSuccess:e,onAuthFailure:i,corsProxy:r,service:o?"git-receive-pack":"git-upload-pack",url:s,headers:a,protocolVersion:u});if(c.protocolVersion===2)return{protocolVersion:c.protocolVersion,capabilities:c.capabilities2};const h={};for(const f of c.capabilities){const[d,y]=f.split("=");y?h[d]=y:h[d]=!0}return{protocolVersion:1,capabilities:h,refs:Zn(c,void 0,!0,!0)}}catch(l){throw l.caller="git.getRemoteInfo2",l}}async function Fa({type:n,object:t,format:e="content",oid:i=void 0}){return e!=="deflated"&&(e!=="wrapped"&&(t=Xt.wrap({type:n,object:t})),i=await Rt(t)),{oid:i,object:t}}async function Jn({object:n}){try{w("object",n),typeof n=="string"?n=U.from(n,"utf8"):n instanceof Uint8Array||(n=new Uint8Array(n));const t="blob",{oid:e,object:i}=await Fa({type:t,format:"content",object:n});return{oid:e,type:t,object:i,format:"wrapped"}}catch(t){throw t.caller="git.hashBlob",t}}async function Ua({fs:n,cache:t,onProgress:e,dir:i,gitdir:r,filepath:s}){try{s=m.join(i,s);const a=await n.read(s),o=l=>et({fs:n,cache:t,gitdir:r,oid:l}),u=await Yt.fromPack({pack:a,getExternalRefDelta:o,onProgress:e});return await n.write(s.replace(/\.pack$/,".idx"),await u.toBuffer()),{oids:[...u.hashes]}}catch(a){throw a.caller="git.indexPack",a}}async function Kn({fs:n,onProgress:t,dir:e,gitdir:i=m.join(e,".git"),filepath:r,cache:s={}}){try{return w("fs",n),w("dir",e),w("gitdir",e),w("filepath",r),await Ua({fs:new q(n),cache:s,onProgress:t,dir:e,gitdir:i,filepath:r})}catch(a){throw a.caller="git.indexPack",a}}async function tr({fs:n,bare:t=!1,dir:e,gitdir:i=t?e:m.join(e,".git"),defaultBranch:r="master"}){try{return w("fs",n),w("gitdir",i),t||w("dir",e),await In({fs:new q(n),bare:t,dir:e,gitdir:i,defaultBranch:r})}catch(s){throw s.caller="git.init",s}}async function er({fs:n,cache:t,gitdir:e,oid:i,ancestor:r,depth:s}){const a=await Re.read({fs:n,gitdir:e});if(!i)throw new yt("oid");if(!r)throw new yt("ancestor");if(i===r)return!1;const o=[i],u=new Set;let l=0;for(;o.length;){if(l++===s)throw new ye(s);const c=o.shift(),{type:h,object:f}=await et({fs:n,cache:t,gitdir:e,oid:c});if(h!=="commit")throw new wt(c,h,"commit");const d=it.from(f).parse();for(const y of d.parent)if(y===r)return!0;if(!a.has(c))for(const y of d.parent)u.has(y)||(o.push(y),u.add(y))}return!1}async function ir({fs:n,dir:t,gitdir:e=m.join(t,".git"),oid:i,ancestor:r,depth:s=-1,cache:a={}}){try{return w("fs",n),w("gitdir",e),w("oid",i),w("ancestor",r),await er({fs:new q(n),cache:a,gitdir:e,oid:i,ancestor:r,depth:s})}catch(o){throw o.caller="git.isDescendent",o}}async function nr({fs:n,dir:t,gitdir:e=m.join(t,".git"),filepath:i}){try{return w("fs",n),w("dir",t),w("gitdir",e),w("filepath",i),ne.isIgnored({fs:new q(n),dir:t,gitdir:e,filepath:i})}catch(r){throw r.caller="git.isIgnored",r}}async function rr({fs:n,dir:t,gitdir:e=m.join(t,".git"),remote:i}){try{return w("fs",n),w("gitdir",e),S.listBranches({fs:new q(n),gitdir:e,remote:i})}catch(r){throw r.caller="git.listBranches",r}}async function Ha({fs:n,gitdir:t,ref:e,cache:i}){if(e){const r=await S.resolve({gitdir:t,fs:n,ref:e}),s=[];return await sr({fs:n,cache:i,gitdir:t,oid:r,filenames:s,prefix:""}),s}else return at.acquire({fs:n,gitdir:t,cache:i},async function(r){return r.entries.map(s=>s.path)})}async function sr({fs:n,cache:t,gitdir:e,oid:i,filenames:r,prefix:s}){const{tree:a}=await ae({fs:n,cache:t,gitdir:e,oid:i});for(const o of a)o.type==="tree"?await sr({fs:n,cache:t,gitdir:e,oid:o.oid,filenames:r,prefix:m.join(s,o.path)}):r.push(m.join(s,o.path))}async function ar({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i,cache:r={}}){try{return w("fs",n),w("gitdir",e),await Ha({fs:new q(n),cache:r,gitdir:e,ref:i})}catch(s){throw s.caller="git.listFiles",s}}async function za({fs:n,cache:t,gitdir:e,ref:i}){let r;try{r=await S.resolve({gitdir:e,fs:n,ref:i})}catch(o){if(o instanceof J)return[]}return(await ae({fs:n,cache:t,gitdir:e,oid:r})).tree.map(o=>({target:o.path,note:o.oid}))}async function or({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i="refs/notes/commits",cache:r={}}){try{return w("fs",n),w("gitdir",e),w("ref",i),await za({fs:new q(n),cache:r,gitdir:e,ref:i})}catch(s){throw s.caller="git.listNotes",s}}async function cr({fs:n,dir:t,gitdir:e=m.join(t,".git"),filepath:i}){try{return w("fs",n),w("gitdir",e),S.listRefs({fs:new q(n),gitdir:e,filepath:i})}catch(r){throw r.caller="git.listRefs",r}}async function qa({fs:n,gitdir:t}){const e=await st.get({fs:n,gitdir:t}),i=await e.getSubsections("remote");return Promise.all(i.map(async s=>{const a=await e.get(`remote.${s}.url`);return{remote:s,url:a}}))}async function lr({fs:n,dir:t,gitdir:e=m.join(t,".git")}){try{return w("fs",n),w("gitdir",e),await qa({fs:new q(n),gitdir:e})}catch(i){throw i.caller="git.listRemotes",i}}async function La(n){const t=rt.streamReader(n),e=[];let i;for(;i=await t(),i!==!0;){if(i===null)continue;i=i.toString("utf8").replace(/\n$/,"");const[r,s,...a]=i.split(" "),o={ref:s,oid:r};for(const u of a){const[l,c]=u.split(":");l==="symref-target"?o.target=c:l==="peeled"&&(o.peeled=c)}e.push(o)}return e}async function Wa({prefix:n,symrefs:t,peelTags:e}){const i=[];return i.push(rt.encode(`command=ls-refs
`)),i.push(rt.encode(`agent=${We.agent}
`)),(e||t||n)&&i.push(rt.delim()),e&&i.push(rt.encode("peel")),t&&i.push(rt.encode("symrefs")),n&&i.push(rt.encode(`ref-prefix ${n}`)),i.push(rt.flush()),i}async function ur({http:n,onAuth:t,onAuthSuccess:e,onAuthFailure:i,corsProxy:r,url:s,headers:a={},forPush:o=!1,protocolVersion:u=2,prefix:l,symrefs:c,peelTags:h}){try{w("http",n),w("url",s);const f=await qe.discover({http:n,onAuth:t,onAuthSuccess:e,onAuthFailure:i,corsProxy:r,service:o?"git-receive-pack":"git-upload-pack",url:s,headers:a,protocolVersion:u});if(f.protocolVersion===1)return Zn(f,l,c,h);const d=await Wa({prefix:l,symrefs:c,peelTags:h}),y=await qe.connect({http:n,auth:f.auth,headers:a,corsProxy:r,service:o?"git-receive-pack":"git-upload-pack",url:s,body:d});return La(y.body)}catch(f){throw f.caller="git.listServerRefs",f}}async function fr({fs:n,dir:t,gitdir:e=m.join(t,".git")}){try{return w("fs",n),w("gitdir",e),S.listTags({fs:new q(n),gitdir:e})}catch(i){throw i.caller="git.listTags",i}}function Ga(n,t){return n.committer.timestamp-t.committer.timestamp}const Va="e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";async function hr({fs:n,cache:t,gitdir:e,oid:i,fileId:r}){if(r===Va)return;const s=i;let a;const o=await ee({fs:n,cache:t,gitdir:e,oid:i}),u=o.tree;return r===o.oid?a=o.path:(a=await dr({fs:n,cache:t,gitdir:e,tree:u,fileId:r,oid:s}),Array.isArray(a)&&(a.length===0?a=void 0:a.length===1&&(a=a[0]))),a}async function dr({fs:n,cache:t,gitdir:e,tree:i,fileId:r,oid:s,filepaths:a=[],parentPath:o=""}){const u=i.entries().map(function(l){let c;return l.oid===r?(c=m.join(o,l.path),a.push(c)):l.type==="tree"&&(c=et({fs:n,cache:t,gitdir:e,oid:l.oid}).then(function({object:h}){return dr({fs:n,cache:t,gitdir:e,tree:pt.from(h),fileId:r,oid:s,filepaths:a,parentPath:m.join(o,l.path)})})),c});return await Promise.all(u),a}async function Xa({fs:n,cache:t,gitdir:e,filepath:i,ref:r,depth:s,since:a,force:o,follow:u}){const l=typeof a>"u"?void 0:Math.floor(a.valueOf()/1e3),c=[],h=await Re.read({fs:n,gitdir:e}),f=await S.resolve({fs:n,gitdir:e,ref:r}),d=[await se({fs:n,cache:t,gitdir:e,oid:f})];let y,b,_;function k(v){_&&i&&c.push(v)}for(;d.length>0;){const v=d.pop();if(l!==void 0&&v.commit.committer.timestamp<=l)break;if(i){let O;try{O=await xe({fs:n,cache:t,gitdir:e,oid:v.commit.tree,filepath:i}),b&&y!==O&&c.push(b),y=O,b=v,_=!0}catch(F){if(F instanceof J){let L=u&&y;if(L&&(L=await hr({fs:n,cache:t,gitdir:e,oid:v.commit.tree,fileId:y}),L))if(Array.isArray(L)){if(b){const N=await hr({fs:n,cache:t,gitdir:e,oid:b.commit.tree,fileId:y});if(Array.isArray(N))if(L=L.filter($=>N.indexOf($)===-1),L.length===1)L=L[0],i=L,b&&c.push(b);else{L=!1,b&&c.push(b);break}}}else i=L,b&&c.push(b);if(!L){if(_&&y&&(c.push(b),!o))break;if(!o&&!u)throw F}b=v,_=!1}else throw F}}else c.push(v);if(s!==void 0&&c.length===s){k(v);break}if(!h.has(v.oid))for(const O of v.commit.parent){const F=await se({fs:n,cache:t,gitdir:e,oid:O});d.map(L=>L.oid).includes(F.oid)||d.push(F)}d.length===0&&k(v),d.sort((O,F)=>Ga(O.commit,F.commit))}return c}async function wr({fs:n,dir:t,gitdir:e=m.join(t,".git"),filepath:i,ref:r="HEAD",depth:s,since:a,force:o,follow:u,cache:l={}}){try{return w("fs",n),w("gitdir",e),w("ref",r),await Xa({fs:new q(n),cache:l,gitdir:e,filepath:i,ref:r,depth:s,since:a,force:o,follow:u})}catch(c){throw c.caller="git.log",c}}async function mr({fs:n,onSign:t,dir:e,gitdir:i=m.join(e,".git"),ours:r,theirs:s,fastForward:a=!0,fastForwardOnly:o=!1,dryRun:u=!1,noUpdateBranch:l=!1,abortOnConflict:c=!0,message:h,author:f,committer:d,signingKey:y,cache:b={},mergeDriver:_,allowUnrelatedHistories:k=!1}){try{w("fs",n),y&&w("onSign",t);const v=new q(n),O=await Dt({fs:v,gitdir:i,author:f});if(!O&&(!o||!a))throw new ht("author");const F=await re({fs:v,gitdir:i,author:O,committer:d});if(!F&&(!o||!a))throw new ht("committer");return await Un({fs:v,cache:b,dir:e,gitdir:i,ours:r,theirs:s,fastForward:a,fastForwardOnly:o,dryRun:u,noUpdateBranch:l,abortOnConflict:c,message:h,author:O,committer:F,signingKey:y,onSign:t,mergeDriver:_,allowUnrelatedHistories:k})}catch(v){throw v.caller="git.merge",v}}const Ya={commit:16,tree:32,blob:48,tag:64,ofs_delta:96,ref_delta:112};async function pr({fs:n,cache:t,dir:e,gitdir:i=m.join(e,".git"),oids:r}){const s=new I,a=[];function o(c,h){const f=U.from(c,h);a.push(f),s.update(f)}async function u({stype:c,object:h}){const f=Ya[c];let d=h.length,y=d>15?128:0;const b=d&15;d=d>>>4;let _=(y|f|b).toString(16);for(o(_,"hex");y;)y=d>127?128:0,_=y|d&127,o(fi(2,_),"hex"),d=d>>>7;o(U.from(await an(h)))}o("PACK"),o("00000002","hex"),o(fi(8,r.length),"hex");for(const c of r){const{type:h,object:f}=await et({fs:n,cache:t,gitdir:i,oid:c});await u({object:f,stype:h})}const l=s.digest();return a.push(l),a}async function Za({fs:n,cache:t,gitdir:e,oids:i,write:r}){const s=await pr({fs:n,cache:t,gitdir:e,oids:i}),a=U.from(await ze(s)),u=`pack-${a.slice(-20).toString("hex")}.pack`;return r?(await n.write(m.join(e,`objects/pack/${u}`),a),{filename:u}):{filename:u,packfile:new Uint8Array(a)}}async function yr({fs:n,dir:t,gitdir:e=m.join(t,".git"),oids:i,write:r=!1,cache:s={}}){try{return w("fs",n),w("gitdir",e),w("oids",i),await Za({fs:new q(n),cache:s,gitdir:e,oids:i,write:r})}catch(a){throw a.caller="git.packObjects",a}}async function gr({fs:n,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:u=m.join(o,".git"),ref:l,url:c,remote:h,remoteRef:f,prune:d=!1,pruneTags:y=!1,fastForward:b=!0,fastForwardOnly:_=!1,corsProxy:k,singleBranch:v,headers:O={},author:F,committer:L,signingKey:N,cache:$={}}){try{w("fs",n),w("gitdir",u);const E=new q(n),A=await Dt({fs:E,gitdir:u,author:F});if(!A)throw new ht("author");const G=await re({fs:E,gitdir:u,author:A,committer:L});if(!G)throw new ht("committer");return await Hn({fs:E,cache:$,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:u,ref:l,url:c,remote:h,remoteRef:f,fastForward:b,fastForwardOnly:_,corsProxy:k,singleBranch:v,headers:O,author:A,committer:G,signingKey:N,prune:d,pruneTags:y})}catch(E){throw E.caller="git.pull",E}}async function Qa({fs:n,cache:t,dir:e,gitdir:i=m.join(e,".git"),start:r,finish:s}){const a=await Re.read({fs:n,gitdir:i}),o=new Set,u=new Set;for(const h of r)o.add(await S.resolve({fs:n,gitdir:i,ref:h}));for(const h of s)try{const f=await S.resolve({fs:n,gitdir:i,ref:h});u.add(f)}catch{}const l=new Set;async function c(h){l.add(h);const{type:f,object:d}=await et({fs:n,cache:t,gitdir:i,oid:h});if(f==="tag"){const b=mt.from(d).headers().object;return c(b)}if(f!=="commit")throw new wt(h,f,"commit");if(!a.has(h)){const b=it.from(d).headers().parent;for(h of b)!u.has(h)&&!l.has(h)&&await c(h)}}for(const h of o)await c(h);return l}async function yi({fs:n,cache:t,dir:e,gitdir:i=m.join(e,".git"),oids:r}){const s=new Set;async function a(o){if(s.has(o))return;s.add(o);const{type:u,object:l}=await et({fs:n,cache:t,gitdir:i,oid:o});if(u==="tag"){const h=mt.from(l).headers().object;await a(h)}else if(u==="commit"){const h=it.from(l).headers().tree;await a(h)}else if(u==="tree"){const c=pt.from(l);for(const h of c)h.type==="blob"&&s.add(h.oid),h.type==="tree"&&await a(h.oid)}}for(const o of r)await a(o);return s}async function Ja(n){const t={};let e="";const i=rt.streamReader(n);let r=await i();for(;r!==!0;)r!==null&&(e+=r.toString("utf8")+`
`),r=await i();const s=e.toString("utf8").split(`
`);if(r=s.shift(),!r.startsWith("unpack "))throw new Ut('unpack ok" or "unpack [error message]',r);t.ok=r==="unpack ok",t.ok||(t.error=r.slice(7)),t.refs={};for(const a of s){if(a.trim()==="")continue;const o=a.slice(0,2),u=a.slice(3);let l=u.indexOf(" ");l===-1&&(l=u.length);const c=u.slice(0,l),h=u.slice(l+1);t.refs[c]={ok:o==="ok",error:h}}return t}async function Ka({capabilities:n=[],triplets:t=[]}){const e=[];let i=`\0 ${n.join(" ")}`;for(const r of t)e.push(rt.encode(`${r.oldoid} ${r.oid} ${r.fullRef}${i}
`)),i="";return e.push(rt.flush()),e}async function to({fs:n,cache:t,http:e,onProgress:i,onMessage:r,onAuth:s,onAuthSuccess:a,onAuthFailure:o,onPrePush:u,gitdir:l,ref:c,remoteRef:h,remote:f,url:d,force:y=!1,delete:b=!1,corsProxy:_,headers:k={}}){const v=c||await Nt({fs:n,gitdir:l});if(typeof v>"u")throw new yt("ref");const O=await st.get({fs:n,gitdir:l});f=f||await O.get(`branch.${v}.pushRemote`)||await O.get("remote.pushDefault")||await O.get(`branch.${v}.remote`)||"origin";const F=d||await O.get(`remote.${f}.pushurl`)||await O.get(`remote.${f}.url`);if(typeof F>"u")throw new yt("remote OR url");const L=h||await O.get(`branch.${v}.merge`);if(typeof F>"u")throw new yt("remoteRef");_===void 0&&(_=await O.get("http.corsProxy"));const N=await S.expand({fs:n,gitdir:l,ref:v}),$=b?"0000000000000000000000000000000000000000":await S.resolve({fs:n,gitdir:l,ref:N}),E=Le.getRemoteHelperFor({url:F}),A=await E.discover({http:e,onAuth:s,onAuthSuccess:a,onAuthFailure:o,corsProxy:_,service:"git-receive-pack",url:F,headers:k,protocolVersion:1}),G=A.auth;let Y;if(!L)Y=N;else try{Y=await S.expandAgainstMap({ref:L,map:A.refs})}catch(nt){if(nt instanceof J)Y=L.startsWith("refs/")?L:`refs/heads/${L}`;else throw nt}const ot=A.refs.get(Y)||"0000000000000000000000000000000000000000";if(u&&!await u({remote:f,url:F,localRef:{ref:b?"(delete)":N,oid:$},remoteRef:{ref:Y,oid:ot}}))throw new te;const Z=!A.capabilities.has("no-thin");let ct=new Set;if(!b){const nt=[...A.refs.values()];let xt=new Set;if(ot!=="0000000000000000000000000000000000000000"){const dt=await mi({fs:n,cache:t,gitdir:l,oids:[$,ot]});for(const Oe of dt)nt.push(Oe);Z&&(xt=await yi({fs:n,cache:t,gitdir:l,oids:dt}))}if(!nt.includes($)){const dt=await Qa({fs:n,cache:t,gitdir:l,start:[$],finish:nt});ct=await yi({fs:n,cache:t,gitdir:l,oids:dt})}if(Z){try{const dt=await S.resolve({fs:n,gitdir:l,ref:`refs/remotes/${f}/HEAD`,depth:2}),{oid:Oe}=await S.resolveAgainstMap({ref:dt.replace(`refs/remotes/${f}/`,""),fullref:dt,map:A.refs}),Wt=[Oe];for(const lt of await yi({fs:n,cache:t,gitdir:l,oids:Wt}))xt.add(lt)}catch{}for(const dt of xt)ct.delete(dt)}if($===ot&&(y=!0),!y){if(N.startsWith("refs/tags")&&ot!=="0000000000000000000000000000000000000000")throw new Kt("tag-exists");if($!=="0000000000000000000000000000000000000000"&&ot!=="0000000000000000000000000000000000000000"&&!await er({fs:n,cache:t,gitdir:l,oid:$,ancestor:ot,depth:-1}))throw new Kt("not-fast-forward")}}const ut=jn([...A.capabilities],["report-status","side-band-64k",`agent=${We.agent}`]),qt=await Ka({capabilities:ut,triplets:[{oldoid:ot,oid:$,fullRef:Y}]}),Lt=b?[]:await pr({fs:n,cache:t,gitdir:l,oids:[...ct]}),ce=await E.connect({http:e,onProgress:i,corsProxy:_,service:"git-receive-pack",url:F,auth:G,headers:k,body:[...qt,...Lt]}),{packfile:_i,progress:ki}=await On.demux(ce.body);if(r){const nt=Rn(ki);je(nt,async xt=>{await r(xt)})}const kt=await Ja(_i);if(ce.headers&&(kt.headers=ce.headers),f&&kt.ok&&kt.refs[Y].ok&&!N.startsWith("refs/tags")){const nt=`refs/remotes/${f}/${Y.replace("refs/heads","")}`;b?await S.deleteRef({fs:n,gitdir:l,ref:nt}):await S.writeRef({fs:n,gitdir:l,ref:nt,value:$})}if(kt.ok&&Object.values(kt.refs).every(nt=>nt.ok))return kt;{const nt=Object.entries(kt.refs).filter(([xt,dt])=>!dt.ok).map(([xt,dt])=>`
  - ${xt}: ${dt.error}`).join("");throw new pe(nt,kt)}}async function br({fs:n,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,onPrePush:o,dir:u,gitdir:l=m.join(u,".git"),ref:c,remoteRef:h,remote:f="origin",url:d,force:y=!1,delete:b=!1,corsProxy:_,headers:k={},cache:v={}}){try{return w("fs",n),w("http",t),w("gitdir",l),await to({fs:new q(n),cache:v,http:t,onProgress:e,onMessage:i,onAuth:r,onAuthSuccess:s,onAuthFailure:a,onPrePush:o,gitdir:l,ref:c,remoteRef:h,remote:f,url:d,force:y,delete:b,corsProxy:_,headers:k})}catch(O){throw O.caller="git.push",O}}async function _r({fs:n,cache:t,gitdir:e,oid:i}){const{type:r,object:s}=await et({fs:n,cache:t,gitdir:e,oid:i});if(r==="tag")return i=mt.from(s).parse().object,_r({fs:n,cache:t,gitdir:e,oid:i});if(r!=="blob")throw new wt(i,r,"blob");return{oid:i,blob:new Uint8Array(s)}}async function kr({fs:n,cache:t,gitdir:e,oid:i,filepath:r=void 0}){return r!==void 0&&(i=await xe({fs:n,cache:t,gitdir:e,oid:i,filepath:r})),await _r({fs:n,cache:t,gitdir:e,oid:i})}async function vr({fs:n,dir:t,gitdir:e=m.join(t,".git"),oid:i,filepath:r,cache:s={}}){try{return w("fs",n),w("gitdir",e),w("oid",i),await kr({fs:new q(n),cache:s,gitdir:e,oid:i,filepath:r})}catch(a){throw a.caller="git.readBlob",a}}async function gi({fs:n,dir:t,gitdir:e=m.join(t,".git"),oid:i,cache:r={}}){try{return w("fs",n),w("gitdir",e),w("oid",i),await se({fs:new q(n),cache:r,gitdir:e,oid:i})}catch(s){throw s.caller="git.readCommit",s}}async function eo({fs:n,cache:t,gitdir:e,ref:i="refs/notes/commits",oid:r}){const s=await S.resolve({gitdir:e,fs:n,ref:i}),{blob:a}=await kr({fs:n,cache:t,gitdir:e,oid:s,filepath:r});return a}async function Sr({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i="refs/notes/commits",oid:r,cache:s={}}){try{return w("fs",n),w("gitdir",e),w("ref",i),w("oid",r),await eo({fs:new q(n),cache:s,gitdir:e,ref:i,oid:r})}catch(a){throw a.caller="git.readNote",a}}async function $r({fs:n,dir:t,gitdir:e=m.join(t,".git"),oid:i,format:r="parsed",filepath:s=void 0,encoding:a=void 0,cache:o={}}){try{w("fs",n),w("gitdir",e),w("oid",i);const u=new q(n);s!==void 0&&(i=await xe({fs:u,cache:o,gitdir:e,oid:i,filepath:s}));const c=await et({fs:u,cache:o,gitdir:e,oid:i,format:r==="parsed"?"content":r});if(c.oid=i,r==="parsed")switch(c.format="parsed",c.type){case"commit":c.object=it.from(c.object).parse();break;case"tree":c.object=pt.from(c.object).entries();break;case"blob":a?c.object=c.object.toString(a):(c.object=new Uint8Array(c.object),c.format="content");break;case"tag":c.object=mt.from(c.object).parse();break;default:throw new wt(c.oid,c.type,"blob|commit|tag|tree")}else(c.format==="deflated"||c.format==="wrapped")&&(c.type=c.format);return c}catch(u){throw u.caller="git.readObject",u}}async function io({fs:n,cache:t,gitdir:e,oid:i}){const{type:r,object:s}=await et({fs:n,cache:t,gitdir:e,oid:i,format:"content"});if(r!=="tag")throw new wt(i,r,"tag");const a=mt.from(s);return{oid:i,tag:a.parse(),payload:a.payload()}}async function xr({fs:n,dir:t,gitdir:e=m.join(t,".git"),oid:i,cache:r={}}){try{return w("fs",n),w("gitdir",e),w("oid",i),await io({fs:new q(n),cache:r,gitdir:e,oid:i})}catch(s){throw s.caller="git.readTag",s}}async function Er({fs:n,dir:t,gitdir:e=m.join(t,".git"),oid:i,filepath:r=void 0,cache:s={}}){try{return w("fs",n),w("gitdir",e),w("oid",i),await ae({fs:new q(n),cache:s,gitdir:e,oid:i,filepath:r})}catch(a){throw a.caller="git.readTree",a}}async function jr({fs:n,dir:t,gitdir:e=m.join(t,".git"),filepath:i,cache:r={}}){try{w("fs",n),w("gitdir",e),w("filepath",i),await at.acquire({fs:new q(n),gitdir:e,cache:r},async function(s){s.delete({filepath:i})})}catch(s){throw s.caller="git.remove",s}}async function no({fs:n,cache:t,onSign:e,gitdir:i,ref:r="refs/notes/commits",oid:s,author:a,committer:o,signingKey:u}){let l;try{l=await S.resolve({gitdir:i,fs:n,ref:r})}catch(y){if(!(y instanceof J))throw y}let h=(await ae({fs:n,gitdir:i,oid:l||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;h=h.filter(y=>y.path!==s);const f=await Ee({fs:n,gitdir:i,tree:h});return await He({fs:n,cache:t,onSign:e,gitdir:i,ref:r,tree:f,parent:l&&[l],message:`Note removed by 'isomorphic-git removeNote'
`,author:a,committer:o,signingKey:u})}async function Rr({fs:n,onSign:t,dir:e,gitdir:i=m.join(e,".git"),ref:r="refs/notes/commits",oid:s,author:a,committer:o,signingKey:u,cache:l={}}){try{w("fs",n),w("gitdir",i),w("oid",s);const c=new q(n),h=await Dt({fs:c,gitdir:i,author:a});if(!h)throw new ht("author");const f=await re({fs:c,gitdir:i,author:h,committer:o});if(!f)throw new ht("committer");return await no({fs:c,cache:l,onSign:t,gitdir:i,ref:r,oid:s,author:h,committer:f,signingKey:u})}catch(c){throw c.caller="git.removeNote",c}}async function ro({fs:n,gitdir:t,oldref:e,ref:i,checkout:r=!1}){if(i!==p.clean(i))throw new $t(i,p.clean(i));if(e!==p.clean(e))throw new $t(e,p.clean(e));const s=`refs/heads/${e}`,a=`refs/heads/${i}`;if(await S.exists({fs:n,gitdir:t,ref:a}))throw new St("branch",i,!1);const u=await S.resolve({fs:n,gitdir:t,ref:s,depth:1});await S.writeRef({fs:n,gitdir:t,ref:a,value:u}),await S.deleteRef({fs:n,gitdir:t,ref:s});const c=await Nt({fs:n,gitdir:t,fullname:!0})===s;(r||c)&&await S.writeSymbolicRef({fs:n,gitdir:t,ref:"HEAD",value:a})}async function Or({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i,oldref:r,checkout:s=!1}){try{return w("fs",n),w("gitdir",e),w("ref",i),w("oldref",r),await ro({fs:new q(n),gitdir:e,ref:i,oldref:r,checkout:s})}catch(a){throw a.caller="git.renameBranch",a}}async function Ir({gitdir:n,type:t,object:e}){return Rt(Xt.wrap({type:t,object:e}))}async function Pr({fs:n,dir:t,gitdir:e=m.join(t,".git"),filepath:i,ref:r,cache:s={}}){try{w("fs",n),w("gitdir",e),w("filepath",i);const a=new q(n);let o,u;try{o=await S.resolve({fs:a,gitdir:e,ref:r||"HEAD"})}catch(h){if(r)throw h}if(o)try{o=await xe({fs:a,cache:s,gitdir:e,oid:o,filepath:i})}catch{o=null}let l={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:0,uid:0,gid:0,size:0};const c=t&&await a.read(m.join(t,i));c&&(u=await Ir({gitdir:e,type:"blob",object:c}),o===u&&(l=await a.lstat(m.join(t,i)))),await at.acquire({fs:a,gitdir:e,cache:s},async function(h){h.delete({filepath:i}),o&&h.insert({filepath:i,stats:l,oid:o})})}catch(a){throw a.caller="git.reset",a}}async function Tr({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i,depth:r}){try{return w("fs",n),w("gitdir",e),w("ref",i),await S.resolve({fs:new q(n),gitdir:e,ref:i,depth:r})}catch(s){throw s.caller="git.resolveRef",s}}async function Cr({fs:n,dir:t,gitdir:e=m.join(t,".git"),path:i,value:r,append:s=!1}){try{w("fs",n),w("gitdir",e),w("path",i);const a=new q(n),o=await st.get({fs:a,gitdir:e});s?await o.append(i,r):await o.set(i,r),await st.save({fs:a,gitdir:e,config:o})}catch(a){throw a.caller="git.setConfig",a}}async function Ar({fs:n,gitdir:t,commit:e}){const i=it.from(e).toObject();return await gt({fs:n,gitdir:t,type:"commit",object:i,format:"content"})}class Ve{static get timezoneOffsetForRefLogEntry(){const t=new Date().getTimezoneOffset(),e=Math.abs(Math.floor(t/60)),i=Math.abs(t%60).toString().padStart(2,"0");return`${t>0?"-":"+"}${e.toString().padStart(2,"0")}${i}`}static createStashReflogEntry(t,e,i){const r=t.name.replace(/\s/g,""),s="0000000000000000000000000000000000000000",a=Math.floor(Date.now()/1e3),o=Ve.timezoneOffsetForRefLogEntry;return`${s} ${e} ${r} ${t.email} ${a} ${o}	${i}
`}static getStashReflogEntry(t,e=!1){return t.split(`
`).filter(s=>s).reverse().map((s,a)=>e?`stash@{${a}}: ${s.split("	")[1]}`:s)}}const so={stage:Ft,workdir:ie};let bi;async function oe(n,t){return bi===void 0&&(bi=new B),bi.acquire(n,t)}async function ao(n,t,e,i,r=null){const s=m.join(e,i),a=await n.lstat(s);if(!a)throw new J(s);if(a.isDirectory())throw new M(`${s}: file expected, but found directory`);const o=r?await Wi({fs:n,gitdir:t,oid:r}):void 0;let u=o?r:void 0;return o||await oe({fs:n,gitdir:t,currentFilepath:s},async()=>{const l=a.isSymbolicLink()?await n.readlink(s).then(on):await n.read(s);if(l===null)throw new J(s);u=await gt({fs:n,gitdir:t,type:"blob",object:l})}),u}async function oo({fs:n,dir:t,gitdir:e,entries:i}){async function r(s){if(s.type==="tree"){if(!s.oid){const a=await Promise.all(s.children.map(r));s.oid=await Ee({fs:n,gitdir:e,tree:a}),s.mode=16384}}else s.type==="blob"&&(s.oid=await ao(n,e,t,s.path,s.oid),s.mode=33188);return s.path=s.path.split("/").pop(),s}return Promise.all(i.map(r))}async function Br({fs:n,dir:t,gitdir:e,treePair:i}){const r=i[1]==="stage",s=i.map(d=>typeof d=="string"?so[d]():d),a=[],c=await Bt({fs:n,cache:{},dir:t,gitdir:e,trees:s,map:async(d,[y,b])=>{if(!(d==="."||await ne.isIgnored({fs:n,dir:t,gitdir:e,filepath:d}))&&b)return(!y||await y.oid()!==await b.oid()&&await b.oid()!==void 0)&&a.push([y,b]),{mode:await b.mode(),path:d,oid:await b.oid(),type:await b.type()}},reduce:async(d,y)=>(y=y.filter(Boolean),d?(d.children=y,d):y.length>0?y:void 0),iterate:async(d,y)=>{const b=[];for(const _ of y){const[k,v]=_;r?v&&(await n.exists(`${t}/${v.toString()}`)?b.push(_):a.push([null,v])):k&&(v?b.push(_):a.push([k,null]))}return b.length?Promise.all(b.map(d)):[]}});if(a.length===0||c.length===0)return null;const f=(await oo({fs:n,dir:t,gitdir:e,entries:c})).filter(Boolean).map(d=>({mode:d.mode,path:d.path,oid:d.oid,type:d.type}));return Ee({fs:n,gitdir:e,tree:f})}async function co({fs:n,dir:t,gitdir:e,stashCommit:i,parentCommit:r,wasStaged:s}){const a=[],o=[],u=await Bt({fs:n,cache:{},dir:t,gitdir:e,trees:[_t({ref:r}),_t({ref:i})],map:async(l,[c,h])=>{if(l==="."||await ne.isIgnored({fs:n,dir:t,gitdir:e,filepath:l}))return;const f=h?await h.type():await c.type();if(f!=="tree"&&f!=="blob")return;if(!h&&c){const y=f==="tree"?"rmdir":"rm";return f==="tree"&&a.push(l),f==="blob"&&s&&o.push({filepath:l,oid:await c.oid()}),{method:y,filepath:l}}const d=await h.oid();if(!c||await c.oid()!==d)return f==="tree"?{method:"mkdir",filepath:l}:(s&&o.push({filepath:l,oid:d,stats:await n.lstat(m.join(t,l))}),{method:"write",filepath:l,oid:d})}});await oe({fs:n,gitdir:e,dirRemoved:a,ops:u},async()=>{for(const l of u){const c=m.join(t,l.filepath);switch(l.method){case"rmdir":await n.rmdir(c);break;case"mkdir":await n.mkdir(c);break;case"rm":await n.rm(c);break;case"write":if(!a.some(h=>c.startsWith(h))){const{object:h}=await et({fs:n,cache:{},gitdir:e,oid:l.oid});await n.exists(c)&&await n.rm(c),await n.write(c,h)}break}}}),await at.acquire({fs:n,gitdir:e,cache:{}},async l=>{o.forEach(({filepath:c,stats:h,oid:f})=>{l.insert({filepath:c,stats:h,oid:f})})})}class It{constructor({fs:t,dir:e,gitdir:i=m.join(e,".git")}){Object.assign(this,{fs:t,dir:e,gitdir:i,_author:null})}static get refStash(){return"refs/stash"}static get refLogsStash(){return"logs/refs/stash"}get refStashPath(){return m.join(this.gitdir,It.refStash)}get refLogsStashPath(){return m.join(this.gitdir,It.refLogsStash)}async getAuthor(){if(!this._author&&(this._author=await Dt({fs:this.fs,gitdir:this.gitdir,author:{}}),!this._author))throw new ht("author");return this._author}async getStashSHA(t,e){return await this.fs.exists(this.refStashPath)?(e||await this.readStashReflogs({parsed:!1}))[t].split(" ")[1]:null}async writeStashCommit({message:t,tree:e,parent:i}){return Ar({fs:this.fs,gitdir:this.gitdir,commit:{message:t,tree:e,parent:i,author:await this.getAuthor(),committer:await this.getAuthor()}})}async readStashCommit(t){const e=await this.readStashReflogs({parsed:!1});if(t!==0&&(t<0||t>e.length-1))throw new $t(`stash@${t}`,"number that is in range of [0, num of stash pushed]");const i=await this.getStashSHA(t,e);return i?se({fs:this.fs,cache:{},gitdir:this.gitdir,oid:i}):{}}async writeStashRef(t){return S.writeRef({fs:this.fs,gitdir:this.gitdir,ref:It.refStash,value:t})}async writeStashReflogEntry({stashCommit:t,message:e}){const i=await this.getAuthor(),r=Ve.createStashReflogEntry(i,t,e),s=this.refLogsStashPath;await oe({filepath:s,entry:r},async()=>{const a=await this.fs.exists(s)?await this.fs.read(s,"utf8"):"";await this.fs.write(s,a+r,"utf8")})}async readStashReflogs({parsed:t=!1}){if(!await this.fs.exists(this.refLogsStashPath))return[];const i=(await this.fs.read(this.refLogsStashPath)).toString();return Ve.getStashReflogEntry(i,t)}}async function lo({fs:n,dir:t,gitdir:e,message:i=""}){const r=new It({fs:n,dir:t,gitdir:e});await r.getAuthor();const s=await Nt({fs:n,gitdir:e,fullname:!1}),a=await S.resolve({fs:n,gitdir:e,ref:"HEAD"}),u=(await gi({fs:n,dir:t,gitdir:e,oid:a})).commit.message,l=[a];let c=null,h=_t({ref:"HEAD"});const f=await Br({fs:n,dir:t,gitdir:e,treePair:[_t({ref:"HEAD"}),"stage"]});if(f){const _=await r.writeStashCommit({message:`stash-Index: WIP on ${s} - ${new Date().toISOString()}`,tree:f,parent:l});l.push(_),c=f,h=Ft()}const d=await Br({fs:n,dir:t,gitdir:e,treePair:[h,"workdir"]});if(d){const _=await r.writeStashCommit({message:`stash-WorkDir: WIP on ${s} - ${new Date().toISOString()}`,tree:d,parent:[l[l.length-1]]});l.push(_),c=d}if(!c||!f&&!d)throw new J("changes, nothing to stash");const y=(i.trim()||`WIP on ${s}`)+`: ${a.substring(0,7)} ${u}`,b=await r.writeStashCommit({message:y,tree:c,parent:l});return await r.writeStashRef(b),await r.writeStashReflogEntry({stashCommit:b,message:y}),await ui({fs:n,dir:t,gitdir:e,ref:s,track:!1,force:!0}),b}async function Dr({fs:n,dir:t,gitdir:e,refIdx:i=0}){const s=await new It({fs:n,dir:t,gitdir:e}).readStashCommit(i),{parent:a=null}=s.commit?s.commit:{};if(!(!a||!Array.isArray(a)))for(let o=0;o<a.length-1;o++){const l=(await se({fs:n,cache:{},gitdir:e,oid:a[o+1]})).commit.message.startsWith("stash-Index");await co({fs:n,dir:t,gitdir:e,stashCommit:a[o+1],parentCommit:a[o],wasStaged:l})}}async function Nr({fs:n,dir:t,gitdir:e,refIdx:i=0}){const r=new It({fs:n,dir:t,gitdir:e});if(!(await r.readStashCommit(i)).commit)return;const a=r.refStashPath;await oe(a,async()=>{await n.exists(a)&&await n.rm(a)});const o=await r.readStashReflogs({parsed:!1});if(!o.length)return;o.splice(i,1);const u=r.refLogsStashPath;await oe({reflogEntries:o,stashReflogPath:u,stashMgr:r},async()=>{if(o.length){await n.write(u,o.join(`
`),"utf8");const l=o[o.length-1].split(" ")[1];await r.writeStashRef(l)}else await n.rm(u)})}async function uo({fs:n,dir:t,gitdir:e}){return new It({fs:n,dir:t,gitdir:e}).readStashReflogs({parsed:!0})}async function fo({fs:n,dir:t,gitdir:e}){const i=new It({fs:n,dir:t,gitdir:e}),r=[i.refStashPath,i.refLogsStashPath];await oe(r,async()=>{await Promise.all(r.map(async s=>{if(await n.exists(s))return n.rm(s)}))})}async function ho({fs:n,dir:t,gitdir:e,refIdx:i=0}){await Dr({fs:n,dir:t,gitdir:e,refIdx:i}),await Nr({fs:n,dir:t,gitdir:e,refIdx:i})}async function Mr({fs:n,dir:t,gitdir:e=m.join(t,".git"),op:i="push",message:r="",refIdx:s=0}){w("fs",n),w("dir",t),w("gitdir",e),w("op",i);const a={push:lo,apply:Dr,drop:Nr,list:uo,clear:fo,pop:ho},o=["apply","drop","pop"];try{const u=new q(n);["refs","logs","logs/refs"].map(h=>m.join(e,h)).forEach(async h=>{await u.exists(h)||await u.mkdir(h)});const c=a[i];if(c){if(o.includes(i)&&s<0)throw new $t(`stash@${s}`,"number that is in range of [0, num of stash pushed]");return await c({fs:u,dir:t,gitdir:e,message:r,refIdx:s})}throw new Error(`To be implemented: ${i}`)}catch(u){throw u.caller="git.stash",u}}async function Fr({fs:n,dir:t,gitdir:e=m.join(t,".git"),filepath:i,cache:r={}}){try{w("fs",n),w("gitdir",e),w("filepath",i);const s=new q(n);if(await ne.isIgnored({fs:s,gitdir:e,dir:t,filepath:i}))return"ignored";const o=await wo({fs:s,cache:r,gitdir:e}),u=await Ur({fs:s,cache:r,gitdir:e,tree:o,path:i}),l=await at.acquire({fs:s,gitdir:e,cache:r},async function(b){for(const _ of b)if(_.path===i)return _;return null}),c=await s.lstat(m.join(t,i)),h=u!==null,f=l!==null,d=c!==null,y=async()=>{if(f&&!Te(l,c))return l.oid;{const b=await s.read(m.join(t,i)),_=await Ir({gitdir:e,type:"blob",object:b});return f&&l.oid===_&&c.size!==-1&&at.acquire({fs:s,gitdir:e,cache:r},async function(k){k.insert({filepath:i,stats:c,oid:_})}),_}};if(!h&&!d&&!f)return"absent";if(!h&&!d&&f)return"*absent";if(!h&&d&&!f)return"*added";if(!h&&d&&f)return await y()===l.oid?"added":"*added";if(h&&!d&&!f)return"deleted";if(h&&!d&&f)return u===l.oid,"*deleted";if(h&&d&&!f)return await y()===u?"*undeleted":"*undeletemodified";if(h&&d&&f){const b=await y();return b===u?b===l.oid?"unmodified":"*unmodified":b===l.oid?"modified":"*modified"}}catch(s){throw s.caller="git.status",s}}async function Ur({fs:n,cache:t,gitdir:e,tree:i,path:r}){typeof r=="string"&&(r=r.split("/"));const s=r.shift();for(const a of i)if(a.path===s){if(r.length===0)return a.oid;const{type:o,object:u}=await et({fs:n,cache:t,gitdir:e,oid:a.oid});if(o==="tree"){const l=pt.from(u);return Ur({fs:n,cache:t,gitdir:e,tree:l,path:r})}if(o==="blob")throw new wt(a.oid,o,"blob",r.join("/"))}return null}async function wo({fs:n,cache:t,gitdir:e}){let i;try{i=await S.resolve({fs:n,gitdir:e,ref:"HEAD"})}catch(s){if(s instanceof J)return[]}const{tree:r}=await ae({fs:n,cache:t,gitdir:e,oid:i});return r}async function Hr({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i="HEAD",filepaths:r=["."],filter:s,cache:a={},ignored:o=!1}){try{w("fs",n),w("gitdir",e),w("ref",i);const u=new q(n);return await Bt({fs:u,cache:a,dir:t,gitdir:e,trees:[_t({ref:i}),ie(),Ft()],map:async function(l,[c,h,f]){if(!c&&!f&&h&&!o&&await ne.isIgnored({fs:u,dir:t,filepath:l})||!r.some(N=>gn(l,N)))return null;if(s&&!s(l))return;const[d,y,b]=await Promise.all([c&&c.type(),h&&h.type(),f&&f.type()]),_=[d,y,b].includes("blob");if((d==="tree"||d==="special")&&!_)return;if(d==="commit")return null;if((y==="tree"||y==="special")&&!_)return;if(b==="commit")return null;if((b==="tree"||b==="special")&&!_)return;const k=d==="blob"?await c.oid():void 0,v=b==="blob"?await f.oid():void 0;let O;d!=="blob"&&y==="blob"&&b!=="blob"?O="42":y==="blob"&&(O=await h.oid());const F=[void 0,k,O,v],L=F.map(N=>F.indexOf(N));return L.shift(),[l,...L]}})}catch(u){throw u.caller="git.statusMatrix",u}}async function zr({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i,object:r,force:s=!1}){try{w("fs",n),w("gitdir",e),w("ref",i);const a=new q(n);if(i===void 0)throw new yt("ref");i=i.startsWith("refs/tags/")?i:`refs/tags/${i}`;const o=await S.resolve({fs:a,gitdir:e,ref:r||"HEAD"});if(!s&&await S.exists({fs:a,gitdir:e,ref:i}))throw new St("tag",i);await S.writeRef({fs:a,gitdir:e,ref:i,value:o})}catch(a){throw a.caller="git.tag",a}}async function qr({fs:n,dir:t,gitdir:e=m.join(t,".git"),cache:i={},filepath:r,oid:s,mode:a,add:o,remove:u,force:l}){try{w("fs",n),w("gitdir",e),w("filepath",r);const c=new q(n);if(u)return await at.acquire({fs:c,gitdir:e,cache:i},async function(f){if(!l){const d=await c.lstat(m.join(t,r));if(d){if(d.isDirectory())throw new Ct("directory");return}}f.has({filepath:r})&&f.delete({filepath:r})});let h;if(!s){if(h=await c.lstat(m.join(t,r)),!h)throw new J(`file at "${r}" on disk and "remove" not set`);if(h.isDirectory())throw new Ct("directory")}return await at.acquire({fs:c,gitdir:e,cache:i},async function(f){if(!o&&!f.has({filepath:r}))throw new J(`file at "${r}" in index and "add" not set`);let d;if(s)d={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:a,uid:0,gid:0,size:0};else{d=h;const y=d.isSymbolicLink()?await c.readlink(m.join(t,r)):await c.read(m.join(t,r));s=await gt({fs:c,gitdir:e,type:"blob",format:"content",object:y})}return f.insert({filepath:r,oid:s,stats:d}),s})}catch(c){throw c.caller="git.updateIndex",c}}function Lr(){try{return We.version}catch(n){throw n.caller="git.version",n}}async function Wr({fs:n,dir:t,gitdir:e=m.join(t,".git"),trees:i,map:r,reduce:s,iterate:a,cache:o={}}){try{return w("fs",n),w("gitdir",e),w("trees",i),await Bt({fs:new q(n),cache:o,dir:t,gitdir:e,trees:i,map:r,reduce:s,iterate:a})}catch(u){throw u.caller="git.walk",u}}async function Gr({fs:n,dir:t,gitdir:e=m.join(t,".git"),blob:i}){try{return w("fs",n),w("gitdir",e),w("blob",i),await gt({fs:new q(n),gitdir:e,type:"blob",object:i,format:"content"})}catch(r){throw r.caller="git.writeBlob",r}}async function Vr({fs:n,dir:t,gitdir:e=m.join(t,".git"),commit:i}){try{return w("fs",n),w("gitdir",e),w("commit",i),await Ar({fs:new q(n),gitdir:e,commit:i})}catch(r){throw r.caller="git.writeCommit",r}}async function Xr({fs:n,dir:t,gitdir:e=m.join(t,".git"),type:i,object:r,format:s="parsed",oid:a,encoding:o=void 0}){try{const u=new q(n);if(s==="parsed"){switch(i){case"commit":r=it.from(r).toObject();break;case"tree":r=pt.from(r).toObject();break;case"blob":r=U.from(r,o);break;case"tag":r=mt.from(r).toObject();break;default:throw new wt(a||"",i,"blob|commit|tag|tree")}s="content"}return a=await gt({fs:u,gitdir:e,type:i,object:r,oid:a,format:s}),a}catch(u){throw u.caller="git.writeObject",u}}async function Yr({fs:n,dir:t,gitdir:e=m.join(t,".git"),ref:i,value:r,force:s=!1,symbolic:a=!1}){try{w("fs",n),w("gitdir",e),w("ref",i),w("value",r);const o=new q(n);if(i!==p.clean(i))throw new $t(i,p.clean(i));if(!s&&await S.exists({fs:o,gitdir:e,ref:i}))throw new St("ref",i);a?await S.writeSymbolicRef({fs:o,gitdir:e,ref:i,value:r}):(r=await S.resolve({fs:o,gitdir:e,ref:r}),await S.writeRef({fs:o,gitdir:e,ref:i,value:r}))}catch(o){throw o.caller="git.writeRef",o}}async function mo({fs:n,gitdir:t,tag:e}){const i=mt.from(e).toObject();return await gt({fs:n,gitdir:t,type:"tag",object:i,format:"content"})}async function Zr({fs:n,dir:t,gitdir:e=m.join(t,".git"),tag:i}){try{return w("fs",n),w("gitdir",e),w("tag",i),await mo({fs:new q(n),gitdir:e,tag:i})}catch(r){throw r.caller="git.writeTag",r}}async function Qr({fs:n,dir:t,gitdir:e=m.join(t,".git"),tree:i}){try{return w("fs",n),w("gitdir",e),w("tree",i),await Ee({fs:new q(n),gitdir:e,tree:i})}catch(r){throw r.caller="git.writeTree",r}}var po={Errors:Ji,STAGE:Ft,TREE:_t,WORKDIR:ie,add:cn,abortMerge:sn,addNote:dn,addRemote:mn,annotatedTag:pn,branch:yn,checkout:ui,clone:Pn,commit:Tn,getConfig:Vn,getConfigAll:Xn,setConfig:Cr,currentBranch:Cn,deleteBranch:An,deleteRef:Bn,deleteRemote:Dn,deleteTag:Nn,expandOid:Mn,expandRef:Fn,fastForward:zn,fetch:qn,findMergeBase:Ln,findRoot:Gn,getRemoteInfo:Yn,getRemoteInfo2:Qn,hashBlob:Jn,indexPack:Kn,init:tr,isDescendent:ir,isIgnored:nr,listBranches:rr,listFiles:ar,listNotes:or,listRefs:cr,listRemotes:lr,listServerRefs:ur,listTags:fr,log:wr,merge:mr,packObjects:yr,pull:gr,push:br,readBlob:vr,readCommit:gi,readNote:Sr,readObject:$r,readTag:xr,readTree:Er,remove:jr,removeNote:Rr,renameBranch:Or,resetIndex:Pr,updateIndex:qr,resolveRef:Tr,status:Fr,statusMatrix:Hr,tag:zr,version:Lr,walk:Wr,writeBlob:Gr,writeCommit:Vr,writeObject:Xr,writeRef:Yr,writeTag:Zr,writeTree:Qr,stash:Mr};return C.Errors=Ji,C.STAGE=Ft,C.TREE=_t,C.WORKDIR=ie,C.abortMerge=sn,C.add=cn,C.addNote=dn,C.addRemote=mn,C.annotatedTag=pn,C.branch=yn,C.checkout=ui,C.clone=Pn,C.commit=Tn,C.currentBranch=Cn,C.default=po,C.deleteBranch=An,C.deleteRef=Bn,C.deleteRemote=Dn,C.deleteTag=Nn,C.expandOid=Mn,C.expandRef=Fn,C.fastForward=zn,C.fetch=qn,C.findMergeBase=Ln,C.findRoot=Gn,C.getConfig=Vn,C.getConfigAll=Xn,C.getRemoteInfo=Yn,C.getRemoteInfo2=Qn,C.hashBlob=Jn,C.indexPack=Kn,C.init=tr,C.isDescendent=ir,C.isIgnored=nr,C.listBranches=rr,C.listFiles=ar,C.listNotes=or,C.listRefs=cr,C.listRemotes=lr,C.listServerRefs=ur,C.listTags=fr,C.log=wr,C.merge=mr,C.packObjects=yr,C.pull=gr,C.push=br,C.readBlob=vr,C.readCommit=gi,C.readNote=Sr,C.readObject=$r,C.readTag=xr,C.readTree=Er,C.remove=jr,C.removeNote=Rr,C.renameBranch=Or,C.resetIndex=Pr,C.resolveRef=Tr,C.setConfig=Cr,C.stash=Mr,C.status=Fr,C.statusMatrix=Hr,C.tag=zr,C.updateIndex=qr,C.version=Lr,C.walk=Wr,C.writeBlob=Gr,C.writeCommit=Vr,C.writeObject=Xr,C.writeRef=Yr,C.writeTag=Zr,C.writeTree=Qr,C}var Zo=Yo();const hc=hs(Zo);export{cc as F,hc as g};
