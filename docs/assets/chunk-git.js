import{g as po,a as fs}from"./chunk-eruda.js";import{B as yo,D as go,F as bo,H as _o,J as ko,K as vo,O as So,Q as xo,R as $o,U as Eo,V as jo,W as Ro}from"./chunk-vendor.js";var xn,Ji;function Dn(){if(Ji)return xn;Ji=1;function x(g){if(g.length===0)return".";let p=m(g);return p=p.reduce(j,[]),$(...p)}function I(...g){let p="";for(let U of g)U.startsWith("/")?p=U:p=x($(p,U));return p}function $(...g){if(g.length===0)return"";let p=g.join("/");return p=p.replace(/\/{2,}/g,"/"),p}function m(g){if(g.length===0)return[];if(g==="/")return["/"];let p=g.split("/");return p[p.length-1]===""&&p.pop(),g[0]==="/"?p[0]="/":p[0]!=="."&&p.unshift("."),p}function E(g){const p=g.lastIndexOf("/");if(p===-1)throw new Error(`Cannot get dirname of "${g}"`);return p===0?"/":g.slice(0,p)}function O(g){if(g==="/")throw new Error(`Cannot get basename of "${g}"`);const p=g.lastIndexOf("/");return p===-1?g:g.slice(p+1)}function j(g,p){if(g.length===0)return g.push(p),g;if(p===".")return g;if(p===".."){if(g.length===1){if(g[0]==="/")throw new Error("Unable to normalize path - traverses above root directory");if(g[0]===".")return g.push(p),g}return g[g.length-1]===".."?(g.push(".."),g):(g.pop(),g)}return g.push(p),g}return xn={join:$,normalize:x,split:m,basename:O,dirname:E,resolve:I},xn}var $n,Ki;function us(){if(Ki)return $n;Ki=1;function x(g){return class extends Error{constructor(...p){super(...p),this.code=g,this.message?this.message=g+": "+this.message:this.message=g}}}const I=x("EEXIST"),$=x("ENOENT"),m=x("ENOTDIR"),E=x("ENOTEMPTY"),O=x("ETIMEDOUT"),j=x("EISDIR");return $n={EEXIST:I,ENOENT:$,ENOTDIR:m,ENOTEMPTY:E,ETIMEDOUT:O,EISDIR:j},$n}var En,ts;function Oo(){if(ts)return En;ts=1;const x=Dn(),{EEXIST:I,ENOENT:$,ENOTDIR:m,ENOTEMPTY:E,EISDIR:O}=us(),j=0;return En=class{constructor(){}_makeRoot(p=new Map){return p.set(j,{mode:511,type:"dir",size:0,ino:0,mtimeMs:Date.now()}),p}activate(p=null){p===null?this._root=new Map([["/",this._makeRoot()]]):typeof p=="string"?this._root=new Map([["/",this._makeRoot(this.parse(p))]]):this._root=p}get activated(){return!!this._root}deactivate(){this._root=void 0}size(){return this._countInodes(this._root.get("/"))-1}_countInodes(p){let U=1;for(let[P,L]of p)P!==j&&(U+=this._countInodes(L));return U}autoinc(){return this._maxInode(this._root.get("/"))+1}_maxInode(p){let U=p.get(j).ino;for(let[P,L]of p)P!==j&&(U=Math.max(U,this._maxInode(L)));return U}print(p=this._root.get("/")){let U="";const P=(L,M)=>{for(let[T,H]of L){if(T===0)continue;let G=H.get(j),V=G.mode.toString(8);U+=`${"	".repeat(M)}${T}	${V}`,G.type==="file"?U+=`	${G.size}	${G.mtimeMs}
`:(U+=`
`,P(H,M+1))}};return P(p,0),U}parse(p){let U=0;function P(H){const G=++U,V=H.length===1?"dir":"file";let[K,Z,gt]=H;return K=parseInt(K,8),Z=Z?parseInt(Z):0,gt=gt?parseInt(gt):Date.now(),new Map([[j,{mode:K,type:V,size:Z,mtimeMs:gt,ino:G}]])}let L=p.trim().split(`
`),M=this._makeRoot(),T=[{indent:-1,node:M},{indent:0,node:null}];for(let H of L){let V=H.match(/^\t*/)[0].length;H=H.slice(V);let[K,...Z]=H.split("	"),gt=P(Z);if(V<=T[T.length-1].indent)for(;V<=T[T.length-1].indent;)T.pop();T.push({indent:V,node:gt}),T[T.length-2].node.set(K,gt)}return M}_lookup(p,U=!0){let P=this._root,L="/",M=x.split(p);for(let T=0;T<M.length;++T){let H=M[T];if(P=P.get(H),!P)throw new $(p);if(U||T<M.length-1){const G=P.get(j);if(G.type==="symlink"){let V=x.resolve(L,G.target);P=this._lookup(V)}L?L=x.join(L,H):L=H}}return P}mkdir(p,{mode:U}){if(p==="/")throw new I;let P=this._lookup(x.dirname(p)),L=x.basename(p);if(P.has(L))throw new I;let M=new Map,T={mode:U,type:"dir",size:0,mtimeMs:Date.now(),ino:this.autoinc()};M.set(j,T),P.set(L,M)}rmdir(p){let U=this._lookup(p);if(U.get(j).type!=="dir")throw new m;if(U.size>1)throw new E;let P=this._lookup(x.dirname(p)),L=x.basename(p);P.delete(L)}readdir(p){let U=this._lookup(p);if(U.get(j).type!=="dir")throw new m;return[...U.keys()].filter(P=>typeof P=="string")}writeStat(p,U,{mode:P}){let L,M;try{M=this.stat(p)}catch{}if(M!==void 0){if(M.type==="dir")throw new O;P==null&&(P=M.mode),L=M.ino}P==null&&(P=438),L==null&&(L=this.autoinc());let T=this._lookup(x.dirname(p)),H=x.basename(p),G={mode:P,type:"file",size:U,mtimeMs:Date.now(),ino:L},V=new Map;return V.set(j,G),T.set(H,V),G}unlink(p){let U=this._lookup(x.dirname(p)),P=x.basename(p);U.delete(P)}rename(p,U){let P=x.basename(U),L=this._lookup(p);this._lookup(x.dirname(U)).set(P,L),this.unlink(p)}stat(p){return this._lookup(p).get(j)}lstat(p){return this._lookup(p,!1).get(j)}readlink(p){return this._lookup(p,!1).get(j).target}symlink(p,U){let P,L;try{let V=this.stat(U);L===null&&(L=V.mode),P=V.ino}catch{}L==null&&(L=40960),P==null&&(P=this.autoinc());let M=this._lookup(x.dirname(U)),T=x.basename(U),H={mode:L,type:"symlink",target:p,size:0,mtimeMs:Date.now(),ino:P},G=new Map;return G.set(j,H),M.set(T,G),H}_du(p){let U=0;for(const[P,L]of p.entries())P===j?U+=L.size:U+=this._du(L);return U}du(p){let U=this._lookup(p);return this._du(U)}},En}class hs{constructor(I="keyval-store",$="keyval"){this.storeName=$,this._dbName=I,this._storeName=$,this._init()}_init(){this._dbp||(this._dbp=new Promise((I,$)=>{const m=indexedDB.open(this._dbName);m.onerror=()=>$(m.error),m.onsuccess=()=>I(m.result),m.onupgradeneeded=()=>{m.result.createObjectStore(this._storeName)}}))}_withIDBStore(I,$){return this._init(),this._dbp.then(m=>new Promise((E,O)=>{const j=m.transaction(this.storeName,I);j.oncomplete=()=>E(),j.onabort=j.onerror=()=>O(j.error),$(j.objectStore(this.storeName))}))}_close(){return this._init(),this._dbp.then(I=>{I.close(),this._dbp=void 0})}}let jn;function Wt(){return jn||(jn=new hs),jn}function Io(x,I=Wt()){let $;return I._withIDBStore("readwrite",m=>{$=m.get(x)}).then(()=>$.result)}function Bo(x,I,$=Wt()){return $._withIDBStore("readwrite",m=>{m.put(I,x)})}function Po(x,I,$=Wt()){return $._withIDBStore("readwrite",m=>{const E=m.get(x);E.onsuccess=()=>{m.put(I(E.result),x)}})}function To(x,I=Wt()){return I._withIDBStore("readwrite",$=>{$.delete(x)})}function Co(x=Wt()){return x._withIDBStore("readwrite",I=>{I.clear()})}function Ao(x=Wt()){const I=[];return x._withIDBStore("readwrite",$=>{($.openKeyCursor||$.openCursor).call($).onsuccess=function(){this.result&&(I.push(this.result.key),this.result.continue())}}).then(()=>I)}function Do(x=Wt()){return x._close()}const No=Object.freeze(Object.defineProperty({__proto__:null,Store:hs,clear:Co,close:Do,del:To,get:Io,keys:Ao,set:Bo,update:Po},Symbol.toStringTag,{value:"Module"})),ds=po(No);var Rn,es;function Mo(){if(es)return Rn;es=1;const x=ds;return Rn=class{constructor($,m){this._database=$,this._storename=m,this._store=new x.Store(this._database,this._storename)}saveSuperblock($){return x.set("!root",$,this._store)}loadSuperblock(){return x.get("!root",this._store)}readFile($){return x.get($,this._store)}writeFile($,m){return x.set($,m,this._store)}unlink($){return x.del($,this._store)}wipe(){return x.clear(this._store)}close(){return x.close(this._store)}},Rn}var On,ns;function Fo(){return ns||(ns=1,On=class{constructor(I){this._url=I}loadSuperblock(){return fetch(this._url+"/.superblock.txt").then(I=>I.ok?I.text():null)}async readFile(I){const $=await fetch(this._url+I);if($.status===200)return $.arrayBuffer();throw new Error("ENOENT")}async sizeFile(I){const $=await fetch(this._url+I,{method:"HEAD"});if($.status===200)return $.headers.get("content-length");throw new Error("ENOENT")}}),On}var In,rs;function Uo(){if(rs)return In;rs=1;const x=ds,I=$=>new Promise(m=>setTimeout(m,$));return In=class{constructor(m,E){this._id=Math.random(),this._database=m,this._storename=E,this._store=new x.Store(this._database,this._storename),this._lock=null}async has({margin:m=2e3}={}){if(this._lock&&this._lock.holder===this._id){const E=Date.now();return this._lock.expires>E+m?!0:await this.renew()}else return!1}async renew({ttl:m=5e3}={}){let E;return await x.update("lock",O=>{const g=Date.now()+m;return E=O&&O.holder===this._id,this._lock=E?{holder:this._id,expires:g}:O,this._lock},this._store),E}async acquire({ttl:m=5e3}={}){let E,O,j;if(await x.update("lock",g=>{const p=Date.now(),U=p+m;return O=g&&g.expires<p,E=g===void 0||O,j=g&&g.holder===this._id,this._lock=E?{holder:this._id,expires:U}:g,this._lock},this._store),j)throw new Error("Mutex double-locked");return E}async wait({interval:m=100,limit:E=6e3,ttl:O}={}){for(;E--;){if(await this.acquire({ttl:O}))return!0;await I(m)}throw new Error("Mutex timeout")}async release({force:m=!1}={}){let E,O,j;if(await x.update("lock",g=>(E=m||g&&g.holder===this._id,O=g===void 0,j=g&&g.holder!==this._id,this._lock=E?void 0:g,this._lock),this._store),await x.close(this._store),!E&&!m){if(O)throw new Error("Mutex double-freed");if(j)throw new Error("Mutex lost ownership")}return E}},In}var Bn,is;function Ho(){return is||(is=1,Bn=class{constructor(I){this._id=Math.random(),this._database=I,this._has=!1,this._release=null}async has(){return this._has}async acquire(){return new Promise(I=>{navigator.locks.request(this._database+"_lock",{ifAvailable:!0},$=>(this._has=!!$,I(!!$),new Promise(m=>{this._release=m})))})}async wait({timeout:I=6e5}={}){return new Promise(($,m)=>{const E=new AbortController;setTimeout(()=>{E.abort(),m(new Error("Mutex timeout"))},I),navigator.locks.request(this._database+"_lock",{signal:E.signal},O=>(this._has=!!O,$(!!O),new Promise(j=>{this._release=j})))})}async release({force:I=!1}={}){this._has=!1,this._release?this._release():I&&navigator.locks.request(this._database+"_lock",{steal:!0},$=>!0)}}),Bn}var Pn,ss;function zo(){if(ss)return Pn;ss=1;const{encode:x,decode:I}=yo(),$=go(),m=Oo(),{ENOENT:E,ENOTEMPTY:O,ETIMEDOUT:j}=us(),g=Mo(),p=Fo(),U=Uo(),P=Ho(),L=Dn();return Pn=class{constructor(){this.saveSuperblock=$(()=>{this.flush()},500)}async init(T,{wipe:H,url:G,urlauto:V,fileDbName:K=T,db:Z=null,fileStoreName:gt=T+"_files",lockDbName:Et=T+"_lock",lockStoreName:Xe=T+"_lock"}={}){this._name=T,this._idb=Z||new g(K,gt),this._mutex=navigator.locks?new P(T):new U(Et,Xe),this._cache=new m(T),this._opts={wipe:H,url:G},this._needsWipe=!!H,G&&(this._http=new p(G),this._urlauto=!!V)}async activate(){if(this._cache.activated)return;this._needsWipe&&(this._needsWipe=!1,await this._idb.wipe(),await this._mutex.release({force:!0})),await this._mutex.has()||await this._mutex.wait();const T=await this._idb.loadSuperblock();if(T)this._cache.activate(T);else if(this._http){const H=await this._http.loadSuperblock();this._cache.activate(H),await this._saveSuperblock()}else this._cache.activate();if(!await this._mutex.has())throw new j}async deactivate(){await this._mutex.has()&&await this._saveSuperblock(),this._cache.deactivate();try{await this._mutex.release()}catch(T){console.log(T)}await this._idb.close()}async _saveSuperblock(){this._cache.activated&&(this._lastSavedAt=Date.now(),await this._idb.saveSuperblock(this._cache._root))}_writeStat(T,H,G){let V=L.split(L.dirname(T)),K=V.shift();for(let Z of V){K=L.join(K,Z);try{this._cache.mkdir(K,{mode:511})}catch{}}return this._cache.writeStat(T,H,G)}async readFile(T,H){const G=typeof H=="string"?H:H&&H.encoding;if(G&&G!=="utf8")throw new Error('Only "utf8" encoding is supported in readFile');let V=null,K=null;try{K=this._cache.stat(T),V=await this._idb.readFile(K.ino)}catch(Z){if(!this._urlauto)throw Z}if(!V&&this._http){let Z=this._cache.lstat(T);for(;Z.type==="symlink";)T=L.resolve(L.dirname(T),Z.target),Z=this._cache.lstat(T);V=await this._http.readFile(T)}if(V&&((!K||K.size!=V.byteLength)&&(K=await this._writeStat(T,V.byteLength,{mode:K?K.mode:438}),this.saveSuperblock()),G==="utf8"?V=I(V):V.toString=()=>I(V)),!K)throw new E(T);return V}async writeFile(T,H,G){const{mode:V,encoding:K="utf8"}=G;if(typeof H=="string"){if(K!=="utf8")throw new Error('Only "utf8" encoding is supported in writeFile');H=x(H)}const Z=await this._cache.writeStat(T,H.byteLength,{mode:V});await this._idb.writeFile(Z.ino,H)}async unlink(T,H){const G=this._cache.lstat(T);this._cache.unlink(T),G.type!=="symlink"&&await this._idb.unlink(G.ino)}readdir(T,H){return this._cache.readdir(T)}mkdir(T,H){const{mode:G=511}=H;this._cache.mkdir(T,{mode:G})}rmdir(T,H){if(T==="/")throw new O;this._cache.rmdir(T)}rename(T,H){this._cache.rename(T,H)}stat(T,H){return this._cache.stat(T)}lstat(T,H){return this._cache.lstat(T)}readlink(T,H){return this._cache.readlink(T)}symlink(T,H){this._cache.symlink(T,H)}async backFile(T,H){let G=await this._http.sizeFile(T);await this._writeStat(T,G,H)}du(T){return this._cache.du(T)}flush(){return this._saveSuperblock()}},Pn}var Tn,as;function qo(){return as||(as=1,Tn=class{constructor(I){this.type=I.type,this.mode=I.mode,this.size=I.size,this.ino=I.ino,this.mtimeMs=I.mtimeMs,this.ctimeMs=I.ctimeMs||I.mtimeMs,this.uid=1,this.gid=1,this.dev=1}isFile(){return this.type==="file"}isDirectory(){return this.type==="dir"}isSymbolicLink(){return this.type==="symlink"}}),Tn}var Cn,os;function Lo(){if(os)return Cn;os=1;const x=zo(),I=qo(),$=Dn();function m(j,g,...p){return j=$.normalize(j),(typeof g>"u"||typeof g=="function")&&(g={}),typeof g=="string"&&(g={encoding:g}),[j,g,...p]}function E(j,g,p,...U){return j=$.normalize(j),(typeof p>"u"||typeof p=="function")&&(p={}),typeof p=="string"&&(p={encoding:p}),[j,g,p,...U]}function O(j,g,...p){return[$.normalize(j),$.normalize(g),...p]}return Cn=class{constructor(g,p={}){this.init=this.init.bind(this),this.readFile=this._wrap(this.readFile,m,!1),this.writeFile=this._wrap(this.writeFile,E,!0),this.unlink=this._wrap(this.unlink,m,!0),this.readdir=this._wrap(this.readdir,m,!1),this.mkdir=this._wrap(this.mkdir,m,!0),this.rmdir=this._wrap(this.rmdir,m,!0),this.rename=this._wrap(this.rename,O,!0),this.stat=this._wrap(this.stat,m,!1),this.lstat=this._wrap(this.lstat,m,!1),this.readlink=this._wrap(this.readlink,m,!1),this.symlink=this._wrap(this.symlink,O,!0),this.backFile=this._wrap(this.backFile,m,!0),this.du=this._wrap(this.du,m,!1),this._deactivationPromise=null,this._deactivationTimeout=null,this._activationPromise=null,this._operations=new Set,g&&this.init(g,p)}async init(...g){return this._initPromiseResolve&&await this._initPromise,this._initPromise=this._init(...g),this._initPromise}async _init(g,p={}){await this._gracefulShutdown(),this._activationPromise&&await this._deactivate(),this._backend&&this._backend.destroy&&await this._backend.destroy(),this._backend=p.backend||new x,this._backend.init&&await this._backend.init(g,p),this._initPromiseResolve&&(this._initPromiseResolve(),this._initPromiseResolve=null),p.defer||this.stat("/")}async _gracefulShutdown(){this._operations.size>0&&(this._isShuttingDown=!0,await new Promise(g=>this._gracefulShutdownResolve=g),this._isShuttingDown=!1,this._gracefulShutdownResolve=null)}_wrap(g,p,U){return async(...P)=>{P=p(...P);let L={name:g.name,args:P};this._operations.add(L);try{return await this._activate(),await g.apply(this,P)}finally{this._operations.delete(L),U&&this._backend.saveSuperblock(),this._operations.size===0&&(this._deactivationTimeout||clearTimeout(this._deactivationTimeout),this._deactivationTimeout=setTimeout(this._deactivate.bind(this),500))}}}async _activate(){this._initPromise||console.warn(new Error(`Attempted to use LightningFS ${this._name} before it was initialized.`)),await this._initPromise,this._deactivationTimeout&&(clearTimeout(this._deactivationTimeout),this._deactivationTimeout=null),this._deactivationPromise&&await this._deactivationPromise,this._deactivationPromise=null,this._activationPromise||(this._activationPromise=this._backend.activate?this._backend.activate():Promise.resolve()),await this._activationPromise}async _deactivate(){return this._activationPromise&&await this._activationPromise,this._deactivationPromise||(this._deactivationPromise=this._backend.deactivate?this._backend.deactivate():Promise.resolve()),this._activationPromise=null,this._gracefulShutdownResolve&&this._gracefulShutdownResolve(),this._deactivationPromise}async readFile(g,p){return this._backend.readFile(g,p)}async writeFile(g,p,U){return await this._backend.writeFile(g,p,U),null}async unlink(g,p){return await this._backend.unlink(g,p),null}async readdir(g,p){return this._backend.readdir(g,p)}async mkdir(g,p){return await this._backend.mkdir(g,p),null}async rmdir(g,p){return await this._backend.rmdir(g,p),null}async rename(g,p){return await this._backend.rename(g,p),null}async stat(g,p){const U=await this._backend.stat(g,p);return new I(U)}async lstat(g,p){const U=await this._backend.lstat(g,p);return new I(U)}async readlink(g,p){return this._backend.readlink(g,p)}async symlink(g,p){return await this._backend.symlink(g,p),null}async backFile(g,p){return await this._backend.backFile(g,p),null}async du(g){return this._backend.du(g)}async flush(){return this._backend.flush()}},Cn}var An,cs;function Wo(){if(cs)return An;cs=1;const x=bo(),I=Lo();function $(m,E){return typeof m=="function"&&(E=m),E=x(E),[(...j)=>E(null,...j),E]}return An=class{constructor(...E){this.promises=new I(...E),this.init=this.init.bind(this),this.readFile=this.readFile.bind(this),this.writeFile=this.writeFile.bind(this),this.unlink=this.unlink.bind(this),this.readdir=this.readdir.bind(this),this.mkdir=this.mkdir.bind(this),this.rmdir=this.rmdir.bind(this),this.rename=this.rename.bind(this),this.stat=this.stat.bind(this),this.lstat=this.lstat.bind(this),this.readlink=this.readlink.bind(this),this.symlink=this.symlink.bind(this),this.backFile=this.backFile.bind(this),this.du=this.du.bind(this),this.flush=this.flush.bind(this)}init(E,O){return this.promises.init(E,O)}readFile(E,O,j){const[g,p]=$(O,j);this.promises.readFile(E,O).then(g).catch(p)}writeFile(E,O,j,g){const[p,U]=$(j,g);this.promises.writeFile(E,O,j).then(p).catch(U)}unlink(E,O,j){const[g,p]=$(O,j);this.promises.unlink(E,O).then(g).catch(p)}readdir(E,O,j){const[g,p]=$(O,j);this.promises.readdir(E,O).then(g).catch(p)}mkdir(E,O,j){const[g,p]=$(O,j);this.promises.mkdir(E,O).then(g).catch(p)}rmdir(E,O,j){const[g,p]=$(O,j);this.promises.rmdir(E,O).then(g).catch(p)}rename(E,O,j){const[g,p]=$(j);this.promises.rename(E,O).then(g).catch(p)}stat(E,O,j){const[g,p]=$(O,j);this.promises.stat(E).then(g).catch(p)}lstat(E,O,j){const[g,p]=$(O,j);this.promises.lstat(E).then(g).catch(p)}readlink(E,O,j){const[g,p]=$(O,j);this.promises.readlink(E).then(g).catch(p)}symlink(E,O,j){const[g,p]=$(j);this.promises.symlink(E,O).then(g).catch(p)}backFile(E,O,j){const[g,p]=$(O,j);this.promises.backFile(E,O).then(g).catch(p)}du(E,O){const[j,g]=$(O);this.promises.du(E).then(j).catch(g)}flush(E){const[O,j]=$(E);this.promises.flush().then(O).catch(j)}},An}var Go=Wo();const hc=fs(Go);var A={},ls;function Vo(){if(ls)return A;ls=1,Object.defineProperty(A,"__esModule",{value:!0});function x(r){return r&&typeof r=="object"&&"default"in r?r.default:r}var I=x(_o()),$=x(ko()),m=vo(),E=x(So()),O=x(xo()),j=x(jo()),g=x($o()),p=x(Eo()),U=x(Ro());class P extends Error{constructor(t){super(t),this.caller=""}toJSON(){return{code:this.code,data:this.data,caller:this.caller,message:this.message,stack:this.stack}}fromJSON(t){const e=new P(t.message);return e.code=t.code,e.data=t.data,e.caller=t.caller,e.stack=t.stack,e}get isIsomorphicGitError(){return!0}}class L extends P{constructor(t){super(`Modifying the index is not possible because you have unmerged files: ${t.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`),this.code=this.name=L.code,this.data={filepaths:t}}}L.code="UnmergedPathsError";class M extends P{constructor(t){super(`An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${t}`),this.code=this.name=M.code,this.data={message:t}}}M.code="InternalError";class T extends P{constructor(t){super(`The filepath "${t}" contains unsafe character sequences`),this.code=this.name=T.code,this.data={filepath:t}}}T.code="UnsafeFilepathError";class H{constructor(t){this.buffer=t,this._start=0}eof(){return this._start>=this.buffer.length}tell(){return this._start}seek(t){this._start=t}slice(t){const e=this.buffer.slice(this._start,this._start+t);return this._start+=t,e}toString(t,e){const n=this.buffer.toString(t,this._start,this._start+e);return this._start+=e,n}write(t,e,n){const i=this.buffer.write(t,this._start,e,n);return this._start+=e,i}copy(t,e,n){const i=t.copy(this.buffer,this._start,e,n);return this._start+=i,i}readUInt8(){const t=this.buffer.readUInt8(this._start);return this._start+=1,t}writeUInt8(t){const e=this.buffer.writeUInt8(t,this._start);return this._start+=1,e}readUInt16BE(){const t=this.buffer.readUInt16BE(this._start);return this._start+=2,t}writeUInt16BE(t){const e=this.buffer.writeUInt16BE(t,this._start);return this._start+=2,e}readUInt32BE(){const t=this.buffer.readUInt32BE(this._start);return this._start+=4,t}writeUInt32BE(t){const e=this.buffer.writeUInt32BE(t,this._start);return this._start+=4,e}}function G(r,t){return-(r<t)||+(r>t)}function V(r,t){return G(r.path,t.path)}function K(r){let t=r>0?r>>12:0;t!==4&&t!==8&&t!==10&&t!==14&&(t=8);let e=r&511;return e&73?e=493:e=420,t!==8&&(e=0),(t<<12)+e}const Z=2**32;function gt(r,t,e,n){if(r!==void 0&&t!==void 0)return[r,t];e===void 0&&(e=n.valueOf());const i=Math.floor(e/1e3),s=(e-i*1e3)*1e6;return[i,s]}function Et(r){const[t,e]=gt(r.ctimeSeconds,r.ctimeNanoseconds,r.ctimeMs,r.ctime),[n,i]=gt(r.mtimeSeconds,r.mtimeNanoseconds,r.mtimeMs,r.mtime);return{ctimeSeconds:t%Z,ctimeNanoseconds:e%Z,mtimeSeconds:n%Z,mtimeNanoseconds:i%Z,dev:r.dev%Z,ino:r.ino%Z,mode:K(r.mode%Z),uid:r.uid%Z,gid:r.gid%Z,size:r.size>-1?r.size%Z:0}}function Xe(r){let t="";for(const e of new Uint8Array(r))e<16&&(t+="0"),t+=e.toString(16);return t}let Ye=null;async function jt(r){return Ye===null&&(Ye=await ms()),Ye?Nn(r):ws(r)}function ws(r){return new $().update(r).digest("hex")}async function Nn(r){const t=await crypto.subtle.digest("SHA-1",r);return Xe(t)}async function ms(){try{return await Nn(new Uint8Array([]))==="da39a3ee5e6b4b0d3255bfef95601890afd80709"}catch{}return!1}function ps(r){return{assumeValid:!!(r&32768),extended:!!(r&16384),stage:(r&12288)>>12,nameLength:r&4095}}function ys(r){const t=r.flags;return t.extended=!1,t.nameLength=Math.min(Buffer.from(r.path).length,4095),(t.assumeValid?32768:0)+(t.extended?16384:0)+((t.stage&3)<<12)+(t.nameLength&4095)}class Nt{constructor(t,e){this._dirty=!1,this._unmergedPaths=e||new Set,this._entries=t||new Map}_addEntry(t){if(t.flags.stage===0)t.stages=[t],this._entries.set(t.path,t),this._unmergedPaths.delete(t.path);else{let e=this._entries.get(t.path);e||(this._entries.set(t.path,t),e=t),e.stages[t.flags.stage]=t,this._unmergedPaths.add(t.path)}}static async from(t){if(Buffer.isBuffer(t))return Nt.fromBuffer(t);if(t===null)return new Nt(null);throw new M("invalid type passed to GitIndex.from")}static async fromBuffer(t){if(t.length===0)throw new M("Index file is empty (.git/index)");const e=new Nt,n=new H(t),i=n.toString("utf8",4);if(i!=="DIRC")throw new M(`Invalid dircache magic file number: ${i}`);const s=await jt(t.slice(0,-20)),a=t.slice(-20).toString("hex");if(a!==s)throw new M(`Invalid checksum in GitIndex buffer: expected ${a} but saw ${s}`);const o=n.readUInt32BE();if(o!==2)throw new M(`Unsupported dircache version: ${o}`);const f=n.readUInt32BE();let l=0;for(;!n.eof()&&l<f;){const c={};c.ctimeSeconds=n.readUInt32BE(),c.ctimeNanoseconds=n.readUInt32BE(),c.mtimeSeconds=n.readUInt32BE(),c.mtimeNanoseconds=n.readUInt32BE(),c.dev=n.readUInt32BE(),c.ino=n.readUInt32BE(),c.mode=n.readUInt32BE(),c.uid=n.readUInt32BE(),c.gid=n.readUInt32BE(),c.size=n.readUInt32BE(),c.oid=n.slice(20).toString("hex");const h=n.readUInt16BE();c.flags=ps(h);const u=t.indexOf(0,n.tell()+1)-n.tell();if(u<1)throw new M(`Got a path length of: ${u}`);if(c.path=n.toString("utf8",u),c.path.includes("..\\")||c.path.includes("../"))throw new T(c.path);let d=8-(n.tell()-12)%8;for(d===0&&(d=8);d--;){const y=n.readUInt8();if(y!==0)throw new M(`Expected 1-8 null characters but got '${y}' after ${c.path}`);if(n.eof())throw new M("Unexpected end of file")}c.stages=[],e._addEntry(c),l++}return e}get unmergedPaths(){return[...this._unmergedPaths]}get entries(){return[...this._entries.values()].sort(V)}get entriesMap(){return this._entries}get entriesFlat(){return[...this.entries].flatMap(t=>t.stages.length>1?t.stages.filter(e=>e):t)}*[Symbol.iterator](){for(const t of this.entries)yield t}insert({filepath:t,stats:e,oid:n,stage:i=0}){e||(e={ctimeSeconds:0,ctimeNanoseconds:0,mtimeSeconds:0,mtimeNanoseconds:0,dev:0,ino:0,mode:0,uid:0,gid:0,size:0}),e=Et(e);const s=Buffer.from(t),a={ctimeSeconds:e.ctimeSeconds,ctimeNanoseconds:e.ctimeNanoseconds,mtimeSeconds:e.mtimeSeconds,mtimeNanoseconds:e.mtimeNanoseconds,dev:e.dev,ino:e.ino,mode:e.mode||33188,uid:e.uid,gid:e.gid,size:e.size,path:t,oid:n,flags:{assumeValid:!1,extended:!1,stage:i,nameLength:s.length<4095?s.length:4095},stages:[]};this._addEntry(a),this._dirty=!0}delete({filepath:t}){if(this._entries.has(t))this._entries.delete(t);else for(const e of this._entries.keys())e.startsWith(t+"/")&&this._entries.delete(e);this._unmergedPaths.has(t)&&this._unmergedPaths.delete(t),this._dirty=!0}clear(){this._entries.clear(),this._dirty=!0}has({filepath:t}){return this._entries.has(t)}render(){return this.entries.map(t=>`${t.mode.toString(8)} ${t.oid}    ${t.path}`).join(`
`)}static async _entryToBuffer(t){const e=Buffer.from(t.path),n=Math.ceil((62+e.length+1)/8)*8,i=Buffer.alloc(n),s=new H(i),a=Et(t);return s.writeUInt32BE(a.ctimeSeconds),s.writeUInt32BE(a.ctimeNanoseconds),s.writeUInt32BE(a.mtimeSeconds),s.writeUInt32BE(a.mtimeNanoseconds),s.writeUInt32BE(a.dev),s.writeUInt32BE(a.ino),s.writeUInt32BE(a.mode),s.writeUInt32BE(a.uid),s.writeUInt32BE(a.gid),s.writeUInt32BE(a.size),s.write(t.oid,20,"hex"),s.writeUInt16BE(ys(t)),s.write(t.path,e.length,"utf8"),i}async toObject(){const t=Buffer.alloc(12),e=new H(t);e.write("DIRC",4,"utf8"),e.writeUInt32BE(2),e.writeUInt32BE(this.entriesFlat.length);let n=[];for(const o of this.entries)if(n.push(Nt._entryToBuffer(o)),o.stages.length>1)for(const f of o.stages)f&&f!==o&&n.push(Nt._entryToBuffer(f));n=await Promise.all(n);const i=Buffer.concat(n),s=Buffer.concat([t,i]),a=await jt(s);return Buffer.concat([s,Buffer.from(a,"hex")])}}function Be(r,t,e=!0,n=!0){const i=Et(r),s=Et(t);return e&&i.mode!==s.mode||i.mtimeSeconds!==s.mtimeSeconds||i.ctimeSeconds!==s.ctimeSeconds||i.uid!==s.uid||i.gid!==s.gid||n&&i.ino!==s.ino||i.size!==s.size}let Ze=null;const Qe=Symbol("IndexCache");function gs(){return{map:new Map,stats:new Map}}async function bs(r,t,e){const[n,i]=await Promise.all([r.lstat(t),r.read(t)]),s=await Nt.from(i);e.map.set(t,s),e.stats.set(t,n)}async function _s(r,t,e){const n=e.stats.get(t);if(n===void 0)return!0;if(n===null)return!1;const i=await r.lstat(t);return i===null?!1:Be(n,i)}class st{static async acquire({fs:t,gitdir:e,cache:n,allowUnmerged:i=!0},s){n[Qe]||(n[Qe]=gs());const a=`${e}/index`;Ze===null&&(Ze=new I({maxPending:1/0}));let o,f=[];return await Ze.acquire(a,async()=>{const l=n[Qe];await _s(t,a,l)&&await bs(t,a,l);const c=l.map.get(a);if(f=c.unmergedPaths,f.length&&!i)throw new L(f);if(o=await s(c),c._dirty){const h=await c.toObject();await t.write(a,h),l.stats.set(a,await t.lstat(a)),c._dirty=!1}}),o}}function Pe(r){const t=Math.max(r.lastIndexOf("/"),r.lastIndexOf("\\"));return t>-1&&(r=r.slice(t+1)),r}function Gt(r){const t=Math.max(r.lastIndexOf("/"),r.lastIndexOf("\\"));return t===-1?".":t===0?"/":r.slice(0,t)}function Mn(r){const t=new Map,e=function(i){if(!t.has(i)){const s={type:"tree",fullpath:i,basename:Pe(i),metadata:{},children:[]};t.set(i,s),s.parent=e(Gt(i)),s.parent&&s.parent!==s&&s.parent.children.push(s)}return t.get(i)},n=function(i,s){if(!t.has(i)){const a={type:"blob",fullpath:i,basename:Pe(i),metadata:s,parent:e(Gt(i)),children:[]};a.parent&&a.parent.children.push(a),t.set(i,a)}return t.get(i)};e(".");for(const i of r)n(i.path,i);return t}function ks(r){switch(r){case 16384:return"tree";case 33188:return"blob";case 33261:return"blob";case 40960:return"blob";case 57344:return"commit"}throw new M(`Unexpected GitTree entry mode: ${r.toString(8)}`)}class vs{constructor({fs:t,gitdir:e,cache:n}){this.treePromise=st.acquire({fs:t,gitdir:e,cache:n},async function(s){return Mn(s.entries)});const i=this;this.ConstructEntry=class{constructor(a){this._fullpath=a,this._type=!1,this._mode=!1,this._stat=!1,this._oid=!1}async type(){return i.type(this)}async mode(){return i.mode(this)}async stat(){return i.stat(this)}async content(){return i.content(this)}async oid(){return i.oid(this)}}}async readdir(t){const e=t._fullpath,i=(await this.treePromise).get(e);if(!i||i.type==="blob")return null;if(i.type!=="tree")throw new Error(`ENOTDIR: not a directory, scandir '${e}'`);const s=i.children.map(a=>a.fullpath);return s.sort(G),s}async type(t){return t._type===!1&&await t.stat(),t._type}async mode(t){return t._mode===!1&&await t.stat(),t._mode}async stat(t){if(t._stat===!1){const n=(await this.treePromise).get(t._fullpath);if(!n)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);const i=n.type==="tree"?{}:Et(n.metadata);t._type=n.type==="tree"?"tree":ks(i.mode),t._mode=i.mode,n.type==="tree"?t._stat=void 0:t._stat=i}return t._stat}async content(t){}async oid(t){if(t._oid===!1){const n=(await this.treePromise).get(t._fullpath);t._oid=n.metadata.oid}return t._oid}}const Te=Symbol("GitWalkSymbol");function Mt(){const r=Object.create(null);return Object.defineProperty(r,Te,{value:function({fs:t,gitdir:e,cache:n}){return new vs({fs:t,gitdir:e,cache:n})}}),Object.freeze(r),r}class Q extends P{constructor(t){super(`Could not find ${t}.`),this.code=this.name=Q.code,this.data={what:t}}}Q.code="NotFoundError";class dt extends P{constructor(t,e,n,i){super(`Object ${t} ${i?`at ${i}`:""}was anticipated to be a ${n} but it is a ${e}.`),this.code=this.name=dt.code,this.data={oid:t,actual:e,expected:n,filepath:i}}}dt.code="ObjectTypeError";class It extends P{constructor(t){super(`Expected a 40-char hex object id but saw "${t}".`),this.code=this.name=It.code,this.data={value:t}}}It.code="InvalidOidError";class ce extends P{constructor(t){super(`Could not find a fetch refspec for remote "${t}". Make sure the config file has an entry like the following:
[remote "${t}"]
	fetch = +refs/heads/*:refs/remotes/origin/*
`),this.code=this.name=ce.code,this.data={remote:t}}}ce.code="NoRefspecError";class Ce{constructor(t){if(this.refs=new Map,this.parsedConfig=[],t){let e=null;this.parsedConfig=t.trim().split(`
`).map(n=>{if(/^\s*#/.test(n))return{line:n,comment:!0};const i=n.indexOf(" ");if(n.startsWith("^")){const s=n.slice(1);return this.refs.set(e+"^{}",s),{line:n,ref:e,peeled:s}}else{const s=n.slice(0,i);return e=n.slice(i+1),this.refs.set(e,s),{line:n,ref:e,oid:s}}})}return this}static from(t){return new Ce(t)}delete(t){this.parsedConfig=this.parsedConfig.filter(e=>e.ref!==t),this.refs.delete(t)}toString(){return this.parsedConfig.map(({line:t})=>t).join(`
`)+`
`}}class Ae{constructor({remotePath:t,localPath:e,force:n,matchPrefix:i}){Object.assign(this,{remotePath:t,localPath:e,force:n,matchPrefix:i})}static from(t){const[e,n,i,s,a]=t.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1),o=e==="+",f=i==="*";if(f!==(a==="*"))throw new M("Invalid refspec");return new Ae({remotePath:n,localPath:s,force:o,matchPrefix:f})}translate(t){if(this.matchPrefix){if(t.startsWith(this.remotePath))return this.localPath+t.replace(this.remotePath,"")}else if(t===this.remotePath)return this.localPath;return null}reverseTranslate(t){if(this.matchPrefix){if(t.startsWith(this.localPath))return this.remotePath+t.replace(this.localPath,"")}else if(t===this.localPath)return this.remotePath;return null}}class Je{constructor(t=[]){this.rules=t}static from(t){const e=[];for(const n of t)e.push(Ae.from(n));return new Je(e)}add(t){const e=Ae.from(t);this.rules.push(e)}translate(t){const e=[];for(const n of this.rules)for(const i of t){const s=n.translate(i);s&&e.push([i,s])}return e}translateOne(t){let e=null;for(const n of this.rules){const i=n.translate(t);i&&(e=i)}return e}localNamespaces(){return this.rules.filter(t=>t.matchPrefix).map(t=>t.localPath.replace(/\/$/,""))}}function Ss(r,t){const e=r.replace(/\^\{\}$/,""),n=t.replace(/\^\{\}$/,""),i=-(e<n)||+(e>n);return i===0?r.endsWith("^{}")?1:-1:i}const xs=r=>{if(typeof r=="number")return r;r=r.toLowerCase();let t=parseInt(r);return r.endsWith("k")&&(t*=1024),r.endsWith("m")&&(t*=1024*1024),r.endsWith("g")&&(t*=1024*1024*1024),t},le=r=>{if(typeof r=="boolean")return r;if(r=r.trim().toLowerCase(),r==="true"||r==="yes"||r==="on")return!0;if(r==="false"||r==="no"||r==="off")return!1;throw Error(`Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${r}`)},Fn={core:{filemode:le,bare:le,logallrefupdates:le,symlinks:le,ignorecase:le,bigFileThreshold:xs}},$s=/^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/,Es=/^[A-Za-z0-9-.]+$/,js=/^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/,Rs=/^[A-Za-z][A-Za-z-]*$/,Os=/^(.*?)( *[#;].*)$/,Is=r=>{const t=$s.exec(r);if(t!=null){const[e,n]=t.slice(1);return[e,n]}return null},Bs=r=>{const t=js.exec(r);if(t!=null){const[e,n="true"]=t.slice(1),i=Ps(n),s=Ts(i);return[e,s]}return null},Ps=r=>{const t=Os.exec(r);if(t==null)return r;const[e,n]=t.slice(1);return Un(e)&&Un(n)?`${e}${n}`:e},Un=r=>(r.match(/(?:^|[^\\])"/g)||[]).length%2!==0,Ts=r=>r.split("").reduce((t,e,n,i)=>{const s=e==='"'&&i[n-1]!=="\\",a=e==="\\"&&i[n+1]==='"';return s||a?t:t+e},""),Hn=r=>r!=null?r.toLowerCase():null,Ke=(r,t,e)=>[Hn(r),t,Hn(e)].filter(n=>n!=null).join("."),zn=r=>{const t=r.split("."),e=t.shift(),n=t.pop(),i=t.length?t.join("."):void 0;return{section:e,subsection:i,name:n,path:Ke(e,i,n),sectionPath:Ke(e,i,null),isSection:!!e}},Cs=(r,t)=>r.reduce((e,n,i)=>t(n)?i:e,-1);class tn{constructor(t){let e=null,n=null;this.parsedConfig=t?t.split(`
`).map(i=>{let s=null,a=null;const o=i.trim(),f=Is(o),l=f!=null;if(l)[e,n]=f;else{const h=Bs(o);h!=null&&([s,a]=h)}const c=Ke(e,n,s);return{line:i,isSection:l,section:e,subsection:n,name:s,value:a,path:c}}):[]}static from(t){return new tn(t)}async get(t,e=!1){const n=zn(t).path,i=this.parsedConfig.filter(s=>s.path===n).map(({section:s,name:a,value:o})=>{const f=Fn[s]&&Fn[s][a];return f?f(o):o});return e?i:i.pop()}async getall(t){return this.get(t,!0)}async getSubsections(t){return this.parsedConfig.filter(e=>e.isSection&&e.section===t).map(e=>e.subsection)}async deleteSection(t,e){this.parsedConfig=this.parsedConfig.filter(n=>!(n.section===t&&n.subsection===e))}async append(t,e){return this.set(t,e,!0)}async set(t,e,n=!1){const{section:i,subsection:s,name:a,path:o,sectionPath:f,isSection:l}=zn(t),c=Cs(this.parsedConfig,h=>h.path===o);if(e==null)c!==-1&&this.parsedConfig.splice(c,1);else if(c!==-1){const h=this.parsedConfig[c],u=Object.assign({},h,{name:a,value:e,modified:!0});n?this.parsedConfig.splice(c+1,0,u):this.parsedConfig[c]=u}else{const h=this.parsedConfig.findIndex(d=>d.path===f),u={section:i,subsection:s,name:a,value:e,modified:!0,path:o};if(Es.test(i)&&Rs.test(a))if(h>=0)this.parsedConfig.splice(h+1,0,u);else{const d={isSection:l,section:i,subsection:s,modified:!0,path:f};this.parsedConfig.push(d,u)}}}toString(){return this.parsedConfig.map(({line:t,section:e,subsection:n,name:i,value:s,modified:a=!1})=>a?i!=null&&s!=null?typeof s=="string"&&/[#;]/.test(s)?`	${i} = "${s}"`:`	${i} = ${s}`:n!=null?`[${e} "${n}"]`:`[${e}]`:t).join(`
`)}}class it{static async get({fs:t,gitdir:e}){const n=await t.read(`${e}/config`,{encoding:"utf8"});return tn.from(n)}static async save({fs:t,gitdir:e,config:n}){await t.write(`${e}/config`,n.toString(),{encoding:"utf8"})}}const De=r=>[`${r}`,`refs/${r}`,`refs/tags/${r}`,`refs/heads/${r}`,`refs/remotes/${r}`,`refs/remotes/${r}/HEAD`],As=["config","description","index","shallow","commondir"];let en;async function Bt(r,t){return en===void 0&&(en=new I),en.acquire(r,t)}class S{static async updateRemoteRefs({fs:t,gitdir:e,remote:n,refs:i,symrefs:s,tags:a,refspecs:o=void 0,prune:f=!1,pruneTags:l=!1}){for(const _ of i.values())if(!_.match(/[0-9a-f]{40}/))throw new It(_);const c=await it.get({fs:t,gitdir:e});if(!o){if(o=await c.getall(`remote.${n}.fetch`),o.length===0)throw new ce(n);o.unshift(`+HEAD:refs/remotes/${n}/HEAD`)}const h=Je.from(o),u=new Map;if(l){const _=await S.listRefs({fs:t,gitdir:e,filepath:"refs/tags"});await S.deleteRefs({fs:t,gitdir:e,refs:_.map(k=>`refs/tags/${k}`)})}if(a){for(const _ of i.keys())if(_.startsWith("refs/tags")&&!_.endsWith("^{}")&&!await S.exists({fs:t,gitdir:e,ref:_})){const k=i.get(_);u.set(_,k)}}const d=h.translate([...i.keys()]);for(const[_,k]of d){const v=i.get(_);u.set(k,v)}const y=h.translate([...s.keys()]);for(const[_,k]of y){const v=s.get(_),C=h.translateOne(v);C&&u.set(k,`ref: ${C}`)}const b=[];if(f){for(const _ of h.localNamespaces()){const k=(await S.listRefs({fs:t,gitdir:e,filepath:_})).map(v=>`${_}/${v}`);for(const v of k)u.has(v)||b.push(v)}b.length>0&&await S.deleteRefs({fs:t,gitdir:e,refs:b})}for(const[_,k]of u)await Bt(_,async()=>t.write(m.join(e,_),`${k.trim()}
`,"utf8"));return{pruned:b}}static async writeRef({fs:t,gitdir:e,ref:n,value:i}){if(!i.match(/[0-9a-f]{40}/))throw new It(i);await Bt(n,async()=>t.write(m.join(e,n),`${i.trim()}
`,"utf8"))}static async writeSymbolicRef({fs:t,gitdir:e,ref:n,value:i}){await Bt(n,async()=>t.write(m.join(e,n),`ref: ${i.trim()}
`,"utf8"))}static async deleteRef({fs:t,gitdir:e,ref:n}){return S.deleteRefs({fs:t,gitdir:e,refs:[n]})}static async deleteRefs({fs:t,gitdir:e,refs:n}){await Promise.all(n.map(o=>t.rm(m.join(e,o))));let i=await Bt("packed-refs",async()=>t.read(`${e}/packed-refs`,{encoding:"utf8"}));const s=Ce.from(i),a=s.refs.size;for(const o of n)s.refs.has(o)&&s.delete(o);s.refs.size<a&&(i=s.toString(),await Bt("packed-refs",async()=>t.write(`${e}/packed-refs`,i,{encoding:"utf8"})))}static async resolve({fs:t,gitdir:e,ref:n,depth:i=void 0}){if(i!==void 0&&(i--,i===-1))return n;if(n.startsWith("ref: "))return n=n.slice(5),S.resolve({fs:t,gitdir:e,ref:n,depth:i});if(n.length===40&&/[0-9a-f]{40}/.test(n))return n;const s=await S.packedRefs({fs:t,gitdir:e}),a=De(n).filter(o=>!As.includes(o));for(const o of a){const f=await Bt(o,async()=>await t.read(`${e}/${o}`,{encoding:"utf8"})||s.get(o));if(f)return S.resolve({fs:t,gitdir:e,ref:f.trim(),depth:i})}throw new Q(n)}static async exists({fs:t,gitdir:e,ref:n}){try{return await S.expand({fs:t,gitdir:e,ref:n}),!0}catch{return!1}}static async expand({fs:t,gitdir:e,ref:n}){if(n.length===40&&/[0-9a-f]{40}/.test(n))return n;const i=await S.packedRefs({fs:t,gitdir:e}),s=De(n);for(const a of s)if(await Bt(a,async()=>t.exists(`${e}/${a}`))||i.has(a))return a;throw new Q(n)}static async expandAgainstMap({ref:t,map:e}){const n=De(t);for(const i of n)if(await e.has(i))return i;throw new Q(t)}static resolveAgainstMap({ref:t,fullref:e=t,depth:n=void 0,map:i}){if(n!==void 0&&(n--,n===-1))return{fullref:e,oid:t};if(t.startsWith("ref: "))return t=t.slice(5),S.resolveAgainstMap({ref:t,fullref:e,depth:n,map:i});if(t.length===40&&/[0-9a-f]{40}/.test(t))return{fullref:e,oid:t};const s=De(t);for(const a of s){const o=i.get(a);if(o)return S.resolveAgainstMap({ref:o.trim(),fullref:a,depth:n,map:i})}throw new Q(t)}static async packedRefs({fs:t,gitdir:e}){const n=await Bt("packed-refs",async()=>t.read(`${e}/packed-refs`,{encoding:"utf8"}));return Ce.from(n).refs}static async listRefs({fs:t,gitdir:e,filepath:n}){const i=S.packedRefs({fs:t,gitdir:e});let s=null;try{s=await t.readdirDeep(`${e}/${n}`),s=s.map(a=>a.replace(`${e}/${n}/`,""))}catch{s=[]}for(let a of(await i).keys())a.startsWith(n)&&(a=a.replace(n+"/",""),s.includes(a)||s.push(a));return s.sort(Ss),s}static async listBranches({fs:t,gitdir:e,remote:n}){return n?S.listRefs({fs:t,gitdir:e,filepath:`refs/remotes/${n}`}):S.listRefs({fs:t,gitdir:e,filepath:"refs/heads"})}static async listTags({fs:t,gitdir:e}){return(await S.listRefs({fs:t,gitdir:e,filepath:"refs/tags"})).filter(i=>!i.endsWith("^{}"))}}function Ds(r,t){return G(qn(r),qn(t))}function qn(r){return r.mode==="040000"?r.path+"/":r.path}function Ln(r){switch(r){case"040000":return"tree";case"100644":return"blob";case"100755":return"blob";case"120000":return"blob";case"160000":return"commit"}throw new M(`Unexpected GitTree entry mode: ${r}`)}function Ns(r){const t=[];let e=0;for(;e<r.length;){const n=r.indexOf(32,e);if(n===-1)throw new M(`GitTree: Error parsing buffer at byte location ${e}: Could not find the next space character.`);const i=r.indexOf(0,e);if(i===-1)throw new M(`GitTree: Error parsing buffer at byte location ${e}: Could not find the next null character.`);let s=r.slice(e,n).toString("utf8");s==="40000"&&(s="040000");const a=Ln(s),o=r.slice(n+1,i).toString("utf8");if(o.includes("\\")||o.includes("/"))throw new T(o);const f=r.slice(i+1,i+21).toString("hex");e=i+21,t.push({mode:s,path:o,oid:f,type:a})}return t}function Ms(r){if(typeof r=="number"&&(r=r.toString(8)),r.match(/^0?4.*/))return"040000";if(r.match(/^1006.*/))return"100644";if(r.match(/^1007.*/))return"100755";if(r.match(/^120.*/))return"120000";if(r.match(/^160.*/))return"160000";throw new M(`Could not understand file mode: ${r}`)}function Fs(r){return!r.oid&&r.sha&&(r.oid=r.sha),r.mode=Ms(r.mode),r.type||(r.type=Ln(r.mode)),r}class mt{constructor(t){if(Buffer.isBuffer(t))this._entries=Ns(t);else if(Array.isArray(t))this._entries=t.map(Fs);else throw new M("invalid type passed to GitTree constructor");this._entries.sort(V)}static from(t){return new mt(t)}render(){return this._entries.map(t=>`${t.mode} ${t.type} ${t.oid}    ${t.path}`).join(`
`)}toObject(){const t=[...this._entries];return t.sort(Ds),Buffer.concat(t.map(e=>{const n=Buffer.from(e.mode.replace(/^0/,"")),i=Buffer.from(" "),s=Buffer.from(e.path,"utf8"),a=Buffer.from([0]),o=Buffer.from(e.oid,"hex");return Buffer.concat([n,i,s,a,o])}))}entries(){return this._entries}*[Symbol.iterator](){for(const t of this._entries)yield t}}class Vt{static wrap({type:t,object:e}){const n=`${t} ${e.length}\0`,i=n.length,s=i+e.length,a=new Uint8Array(s);for(let o=0;o<i;o++)a[o]=n.charCodeAt(o);return a.set(e,i),a}static unwrap(t){const e=t.indexOf(32),n=t.indexOf(0),i=t.slice(0,e).toString("utf8"),s=t.slice(e+1,n).toString("utf8"),a=t.length-(n+1);if(parseInt(s)!==a)throw new M(`Length mismatch: expected ${s} bytes but got ${a} instead.`);return{type:i,object:Buffer.from(t.slice(n+1))}}}async function Wn({fs:r,gitdir:t,oid:e}){const n=`objects/${e.slice(0,2)}/${e.slice(2)}`,i=await r.read(`${t}/${n}`);return i?{object:i,format:"deflated",source:n}:null}function Us(r,t){const e=new H(r),n=Gn(e);if(n!==t.byteLength)throw new M(`applyDelta expected source buffer to be ${n} bytes but the provided buffer was ${t.length} bytes`);const i=Gn(e);let s;const a=Xn(e,t);if(a.byteLength===i)s=a;else{s=Buffer.alloc(i);const o=new H(s);for(o.copy(a);!e.eof();)o.copy(Xn(e,t));const f=o.tell();if(i!==f)throw new M(`applyDelta expected target buffer to be ${i} bytes but the resulting buffer was ${f} bytes`)}return s}function Gn(r){let t=0,e=0,n=null;do n=r.readUInt8(),t|=(n&127)<<e,e+=7;while(n&128);return t}function Vn(r,t,e){let n=0,i=0;for(;e--;)t&1&&(n|=r.readUInt8()<<i),t>>=1,i+=8;return n}function Xn(r,t){const e=r.readUInt8(),n=128,i=15,s=112;if(e&n){const a=Vn(r,e&i,4);let o=Vn(r,(e&s)>>4,3);return o===0&&(o=65536),t.slice(a,a+o)}else return r.slice(e)}function Hs(r){let t=[r];return{next(){return Promise.resolve({done:t.length===0,value:t.pop()})},return(){return t=[],{}},[Symbol.asyncIterator](){return this}}}function Yn(r){return r[Symbol.asyncIterator]?r[Symbol.asyncIterator]():r[Symbol.iterator]?r[Symbol.iterator]():r.next?r:Hs(r)}class Zn{constructor(t){if(typeof Buffer>"u")throw new Error("Missing Buffer dependency");this.stream=Yn(t),this.buffer=null,this.cursor=0,this.undoCursor=0,this.started=!1,this._ended=!1,this._discardedBytes=0}eof(){return this._ended&&this.cursor===this.buffer.length}tell(){return this._discardedBytes+this.cursor}async byte(){if(!this.eof()&&(this.started||await this._init(),!(this.cursor===this.buffer.length&&(await this._loadnext(),this._ended))))return this._moveCursor(1),this.buffer[this.undoCursor]}async chunk(){if(!this.eof()&&(this.started||await this._init(),!(this.cursor===this.buffer.length&&(await this._loadnext(),this._ended))))return this._moveCursor(this.buffer.length),this.buffer.slice(this.undoCursor,this.cursor)}async read(t){if(!this.eof())return this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t),this.buffer.slice(this.undoCursor,this.cursor)}async skip(t){this.eof()||(this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t))}async undo(){this.cursor=this.undoCursor}async _next(){this.started=!0;let{done:t,value:e}=await this.stream.next();return t&&(this._ended=!0,!e)?Buffer.alloc(0):(e&&(e=Buffer.from(e)),e)}_trim(){this.buffer=this.buffer.slice(this.undoCursor),this.cursor-=this.undoCursor,this._discardedBytes+=this.undoCursor,this.undoCursor=0}_moveCursor(t){this.undoCursor=this.cursor,this.cursor+=t,this.cursor>this.buffer.length&&(this.cursor=this.buffer.length)}async _accumulate(t){if(this._ended)return;const e=[this.buffer];for(;this.cursor+t>zs(e);){const n=await this._next();if(this._ended)break;e.push(n)}this.buffer=Buffer.concat(e)}async _loadnext(){this._discardedBytes+=this.buffer.length,this.undoCursor=0,this.cursor=0,this.buffer=await this._next()}async _init(){this.buffer=await this._next()}}function zs(r){return r.reduce((t,e)=>t+e.length,0)}async function qs(r,t){const e=new Zn(r);let n=await e.read(4);if(n=n.toString("utf8"),n!=="PACK")throw new M(`Invalid PACK header '${n}'`);let i=await e.read(4);if(i=i.readUInt32BE(0),i!==2)throw new M(`Invalid packfile version: ${i}`);let s=await e.read(4);if(s=s.readUInt32BE(0),!(s<1))for(;!e.eof()&&s--;){const a=e.tell(),{type:o,length:f,ofs:l,reference:c}=await Ls(e),h=new O.Inflate;for(;!h.result;){const u=await e.chunk();if(!u)break;if(h.push(u,!1),h.err)throw new M(`Pako error: ${h.msg}`);if(h.result){if(h.result.length!==f)throw new M("Inflated object size is different from that stated in packfile.");await e.undo(),await e.read(u.length-h.strm.avail_in);const d=e.tell();await t({data:h.result,type:o,num:s,offset:a,end:d,reference:c,ofs:l})}}}}async function Ls(r){let t=await r.byte();const e=t>>4&7;let n=t&15;if(t&128){let a=4;do t=await r.byte(),n|=(t&127)<<a,a+=7;while(t&128)}let i,s;if(e===6){let a=0;i=0;const o=[];do t=await r.byte(),i|=(t&127)<<a,a+=7,o.push(t);while(t&128);s=Buffer.from(o)}return e===7&&(s=await r.read(20)),{type:e,length:n,ofs:i,reference:s}}async function Qn(r){return O.inflate(r)}function Ws(r){const t=[];let e=0,n=0;do{e=r.readUInt8();const i=e&127;t.push(i),n=e&128}while(n);return t.reduce((i,s)=>i+1<<7|s,-1)}function Gs(r,t){let e=t,n=4,i=null;do i=r.readUInt8(),e|=(i&127)<<n,n+=7;while(i&128);return e}class Xt{constructor(t){Object.assign(this,t),this.offsetCache={}}static async fromIdx({idx:t,getExternalRefDelta:e}){const n=new H(t);if(n.slice(4).toString("hex")!=="ff744f63")return;const s=n.readUInt32BE();if(s!==2)throw new M(`Unable to read version ${s} packfile IDX. (Only version 2 supported)`);if(t.byteLength>2048*1024*1024)throw new M("To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.");n.seek(n.tell()+1020);const a=n.readUInt32BE(),o=[];for(let c=0;c<a;c++){const h=n.slice(20).toString("hex");o[c]=h}n.seek(n.tell()+4*a);const f=new Map;for(let c=0;c<a;c++)f.set(o[c],n.readUInt32BE());const l=n.slice(20).toString("hex");return new Xt({hashes:o,crcs:{},offsets:f,packfileSha:l,getExternalRefDelta:e})}static async fromPack({pack:t,getExternalRefDelta:e,onProgress:n}){const i={1:"commit",2:"tree",3:"blob",4:"tag",6:"ofs-delta",7:"ref-delta"},s={},a=t.slice(-20).toString("hex"),o=[],f={},l=new Map;let c=null,h=null;await qs([t],async({data:_,type:k,reference:v,offset:C,num:F})=>{c===null&&(c=F);const q=Math.floor((c-F)*100/c);q!==h&&n&&await n({phase:"Receiving objects",loaded:c-F,total:c}),h=q,k=i[k],["commit","tree","blob","tag"].includes(k)?s[C]={type:k,offset:C}:k==="ofs-delta"?s[C]={type:k,offset:C}:k==="ref-delta"&&(s[C]={type:k,offset:C})});const u=Object.keys(s).map(Number);for(const[_,k]of u.entries()){const v=_+1===u.length?t.byteLength-20:u[_+1],C=s[k],F=E.buf(t.slice(k,v))>>>0;C.end=v,C.crc=F}const d=new Xt({pack:Promise.resolve(t),packfileSha:a,crcs:f,hashes:o,offsets:l,getExternalRefDelta:e});h=null;let y=0;const b=[0,0,0,0,0,0,0,0,0,0,0,0];for(let _ in s){_=Number(_);const k=Math.floor(y*100/c);k!==h&&n&&await n({phase:"Resolving deltas",loaded:y,total:c}),y++,h=k;const v=s[_];if(!v.oid)try{d.readDepth=0,d.externalReadDepth=0;const{type:C,object:F}=await d.readSlice({start:_});b[d.readDepth]+=1;const q=await jt(Vt.wrap({type:C,object:F}));v.oid=q,o.push(q),l.set(q,_),f[q]=v.crc}catch{continue}}return o.sort(),d}async toBuffer(){const t=[],e=(l,c)=>{t.push(Buffer.from(l,c))};e("ff744f63","hex"),e("00000002","hex");const n=new H(Buffer.alloc(256*4));for(let l=0;l<256;l++){let c=0;for(const h of this.hashes)parseInt(h.slice(0,2),16)<=l&&c++;n.writeUInt32BE(c)}t.push(n.buffer);for(const l of this.hashes)e(l,"hex");const i=new H(Buffer.alloc(this.hashes.length*4));for(const l of this.hashes)i.writeUInt32BE(this.crcs[l]);t.push(i.buffer);const s=new H(Buffer.alloc(this.hashes.length*4));for(const l of this.hashes)s.writeUInt32BE(this.offsets.get(l));t.push(s.buffer),e(this.packfileSha,"hex");const a=Buffer.concat(t),o=await jt(a),f=Buffer.alloc(20);return f.write(o,"hex"),Buffer.concat([a,f])}async load({pack:t}){this.pack=t}async unload(){this.pack=null}async read({oid:t}){if(!this.offsets.get(t)){if(this.getExternalRefDelta)return this.externalReadDepth++,this.getExternalRefDelta(t);throw new M(`Could not read object ${t} from packfile`)}const e=this.offsets.get(t);return this.readSlice({start:e})}async readSlice({start:t}){if(this.offsetCache[t])return Object.assign({},this.offsetCache[t]);this.readDepth++;const e={16:"commit",32:"tree",48:"blob",64:"tag",96:"ofs_delta",112:"ref_delta"};if(!this.pack)throw new M("Tried to read from a GitPackIndex with no packfile loaded into memory");const n=(await this.pack).slice(t),i=new H(n),s=i.readUInt8(),a=s&112;let o=e[a];if(o===void 0)throw new M("Unrecognized type: 0b"+a.toString(2));const f=s&15;let l=f;s&128&&(l=Gs(i,f));let h=null,u=null;if(o==="ofs_delta"){const y=Ws(i),b=t-y;({object:h,type:o}=await this.readSlice({start:b}))}if(o==="ref_delta"){const y=i.slice(20).toString("hex");({object:h,type:o}=await this.read({oid:y}))}const d=n.slice(i.tell());if(u=Buffer.from(await Qn(d)),u.byteLength!==l)throw new M(`Packfile told us object would have length ${l} but it had length ${u.byteLength}`);return h&&(u=Buffer.from(Us(u,h))),this.readDepth>3&&(this.offsetCache[t]={type:o,object:u}),{type:o,format:"content",object:u}}}const Ne=Symbol("PackfileCache");async function Vs({fs:r,filename:t,getExternalRefDelta:e,emitter:n,emitterPrefix:i}){const s=await r.read(t);return Xt.fromIdx({idx:s,getExternalRefDelta:e})}function nn({fs:r,cache:t,filename:e,getExternalRefDelta:n,emitter:i,emitterPrefix:s}){t[Ne]||(t[Ne]=new Map);let a=t[Ne].get(e);return a||(a=Vs({fs:r,filename:e,getExternalRefDelta:n,emitter:i,emitterPrefix:s}),t[Ne].set(e,a)),a}async function Xs({fs:r,cache:t,gitdir:e,oid:n,format:i="content",getExternalRefDelta:s}){let a=await r.readdir(m.join(e,"objects/pack"));a=a.filter(o=>o.endsWith(".idx"));for(const o of a){const f=`${e}/objects/pack/${o}`,l=await nn({fs:r,cache:t,filename:f,getExternalRefDelta:s});if(l.error)throw new M(l.error);if(l.offsets.has(n)){if(!l.pack){const h=f.replace(/idx$/,"pack");l.pack=r.read(h)}const c=await l.read({oid:n,getExternalRefDelta:s});return c.format="content",c.source=`objects/pack/${o.replace(/idx$/,"pack")}`,c}}return null}async function tt({fs:r,cache:t,gitdir:e,oid:n,format:i="content"}){const s=c=>tt({fs:r,cache:t,gitdir:e,oid:c});let a;if(n==="4b825dc642cb6eb9a060e54bf8d69288fbee4904"&&(a={format:"wrapped",object:Buffer.from("tree 0\0")}),a||(a=await Wn({fs:r,gitdir:e,oid:n})),!a){if(a=await Xs({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:s}),!a)throw new Q(n);return a}if(i==="deflated"||(a.format==="deflated"&&(a.object=Buffer.from(await Qn(a.object)),a.format="wrapped"),i==="wrapped"))return a;const o=await jt(a.object);if(o!==n)throw new M(`SHA check failed! Expected ${n}, computed ${o}`);const{object:f,type:l}=Vt.unwrap(a.object);if(a.type=l,a.object=f,a.format="content",i==="content")return a;throw new M(`invalid requested format "${i}"`)}class vt extends P{constructor(t,e,n=!0){super(`Failed to create ${t} at ${e} because it already exists.${n?` (Hint: use 'force: true' parameter to overwrite existing ${t}.)`:""}`),this.code=this.name=vt.code,this.data={noun:t,where:e,canForce:n}}}vt.code="AlreadyExistsError";class fe extends P{constructor(t,e,n){super(`Found multiple ${t} matching "${e}" (${n.join(", ")}). Use a longer abbreviation length to disambiguate them.`),this.code=this.name=fe.code,this.data={nouns:t,short:e,matches:n}}}fe.code="AmbiguousError";class ue extends P{constructor(t){super(`Your local changes to the following files would be overwritten by checkout: ${t.join(", ")}`),this.code=this.name=ue.code,this.data={filepaths:t}}}ue.code="CheckoutConflictError";class he extends P{constructor(t,e){super(`Failed to checkout "${t}" because commit ${e} is not available locally. Do a git fetch to make the branch available locally.`),this.code=this.name=he.code,this.data={ref:t,oid:e}}}he.code="CommitNotFetchedError";class de extends P{constructor(){super("Empty response from git server."),this.code=this.name=de.code,this.data={}}}de.code="EmptyServerResponseError";class we extends P{constructor(){super("A simple fast-forward merge was not possible."),this.code=this.name=we.code,this.data={}}}we.code="FastForwardError";class me extends P{constructor(t,e){super(`One or more branches were not updated: ${t}`),this.code=this.name=me.code,this.data={prettyDetails:t,result:e}}}me.code="GitPushError";class Yt extends P{constructor(t,e,n){super(`HTTP Error: ${t} ${e}`),this.code=this.name=Yt.code,this.data={statusCode:t,statusMessage:e,response:n}}}Yt.code="HttpError";class Pt extends P{constructor(t){let e="invalid filepath";t==="leading-slash"||t==="trailing-slash"?e='"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.':t==="directory"&&(e='"filepath" should not be a directory.'),super(e),this.code=this.name=Pt.code,this.data={reason:t}}}Pt.code="InvalidFilepathError";class St extends P{constructor(t,e){super(`"${t}" would be an invalid git reference. (Hint: a valid alternative would be "${e}".)`),this.code=this.name=St.code,this.data={ref:t,suggestion:e}}}St.code="InvalidRefNameError";class pe extends P{constructor(t){super(`Maximum search depth of ${t} exceeded.`),this.code=this.name=pe.code,this.data={depth:t}}}pe.code="MaxDepthError";class Zt extends P{constructor(){super("Merges with conflicts are not supported yet."),this.code=this.name=Zt.code,this.data={}}}Zt.code="MergeNotSupportedError";class Qt extends P{constructor(t,e,n,i){super(`Automatic merge failed with one or more merge conflicts in the following files: ${t.toString()}. Fix conflicts then commit the result.`),this.code=this.name=Qt.code,this.data={filepaths:t,bothModified:e,deleteByUs:n,deleteByTheirs:i}}}Qt.code="MergeConflictError";class ut extends P{constructor(t){super(`No name was provided for ${t} in the argument or in the .git/config file.`),this.code=this.name=ut.code,this.data={role:t}}}ut.code="MissingNameError";class pt extends P{constructor(t){super(`The function requires a "${t}" parameter but none was provided.`),this.code=this.name=pt.code,this.data={parameter:t}}}pt.code="MissingParameterError";class ye extends P{constructor(t){super('There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more'),this.code=this.name=ye.code,this.data={errors:t},this.errors=t}}ye.code="MultipleGitError";class Ft extends P{constructor(t,e){super(`Expected "${t}" but received "${e}".`),this.code=this.name=Ft.code,this.data={expected:t,actual:e}}}Ft.code="ParseError";class Jt extends P{constructor(t){let e="";t==="not-fast-forward"?e=" because it was not a simple fast-forward":t==="tag-exists"&&(e=" because tag already exists"),super(`Push rejected${e}. Use "force: true" to override.`),this.code=this.name=Jt.code,this.data={reason:t}}}Jt.code="PushRejectedError";class Tt extends P{constructor(t,e){super(`Remote does not support the "${t}" so the "${e}" parameter cannot be used.`),this.code=this.name=Tt.code,this.data={capability:t,parameter:e}}}Tt.code="RemoteCapabilityError";class ge extends P{constructor(t,e){super(`Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${t}`),this.code=this.name=ge.code,this.data={preview:t,response:e}}}ge.code="SmartHttpError";class be extends P{constructor(t,e,n){super(`Git remote "${t}" uses an unrecognized transport protocol: "${e}"`),this.code=this.name=be.code,this.data={url:t,transport:e,suggestion:n}}}be.code="UnknownTransportError";class _e extends P{constructor(t){super(`Cannot parse remote URL: "${t}"`),this.code=this.name=_e.code,this.data={url:t}}}_e.code="UrlParseError";class Kt extends P{constructor(){super("The operation was canceled."),this.code=this.name=Kt.code,this.data={}}}Kt.code="UserCanceledError";class ke extends P{constructor(t){super(`Could not merge index: Entry for '${t}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged changes.`),this.code=this.name=ke.code,this.data={filepath:t}}}ke.code="IndexResetError";class ve extends P{constructor(t){super(`"${t}" does not point to any commit. You're maybe working on a repository with no commits yet. `),this.code=this.name=ve.code,this.data={ref:t}}}ve.code="NoCommitError";var Jn=Object.freeze({__proto__:null,AlreadyExistsError:vt,AmbiguousError:fe,CheckoutConflictError:ue,CommitNotFetchedError:he,EmptyServerResponseError:de,FastForwardError:we,GitPushError:me,HttpError:Yt,InternalError:M,InvalidFilepathError:Pt,InvalidOidError:It,InvalidRefNameError:St,MaxDepthError:pe,MergeNotSupportedError:Zt,MergeConflictError:Qt,MissingNameError:ut,MissingParameterError:pt,MultipleGitError:ye,NoRefspecError:ce,NotFoundError:Q,ObjectTypeError:dt,ParseError:Ft,PushRejectedError:Jt,RemoteCapabilityError:Tt,SmartHttpError:ge,UnknownTransportError:be,UnsafeFilepathError:T,UrlParseError:_e,UserCanceledError:Kt,UnmergedPathsError:L,IndexResetError:ke,NoCommitError:ve});function rn({name:r,email:t,timestamp:e,timezoneOffset:n}){return n=Ys(n),`${r} <${t}> ${e} ${n}`}function Ys(r){const t=Zs(Qs(r));r=Math.abs(r);const e=Math.floor(r/60);r-=e*60;let n=String(e),i=String(r);return n.length<2&&(n="0"+n),i.length<2&&(i="0"+i),(t===-1?"-":"+")+n+i}function Zs(r){return Math.sign(r)||(Object.is(r,-0)?-1:1)}function Qs(r){return r===0?r:-r}function Rt(r){return r=r.replace(/\r/g,""),r=r.replace(/^\n+/,""),r=r.replace(/\n+$/,"")+`
`,r}function Me(r){const[,t,e,n,i]=r.match(/^(.*) <(.*)> (.*) (.*)$/);return{name:t,email:e,timestamp:Number(n),timezoneOffset:Js(i)}}function Js(r){let[,t,e,n]=r.match(/(\+|-)(\d\d)(\d\d)/);return n=(t==="+"?1:-1)*(Number(e)*60+Number(n)),Ks(n)}function Ks(r){return r===0?r:-r}class wt{constructor(t){if(typeof t=="string")this._tag=t;else if(Buffer.isBuffer(t))this._tag=t.toString("utf8");else if(typeof t=="object")this._tag=wt.render(t);else throw new M("invalid type passed to GitAnnotatedTag constructor")}static from(t){return new wt(t)}static render(t){return`object ${t.object}
type ${t.type}
tag ${t.tag}
tagger ${rn(t.tagger)}

${t.message}
${t.gpgsig?t.gpgsig:""}`}justHeaders(){return this._tag.slice(0,this._tag.indexOf(`

`))}message(){const t=this.withoutSignature();return t.slice(t.indexOf(`

`)+2)}parse(){return Object.assign(this.headers(),{message:this.message(),gpgsig:this.gpgsig()})}render(){return this._tag}headers(){const t=this.justHeaders().split(`
`),e=[];for(const i of t)i[0]===" "?e[e.length-1]+=`
`+i.slice(1):e.push(i);const n={};for(const i of e){const s=i.slice(0,i.indexOf(" ")),a=i.slice(i.indexOf(" ")+1);Array.isArray(n[s])?n[s].push(a):n[s]=a}return n.tagger&&(n.tagger=Me(n.tagger)),n.committer&&(n.committer=Me(n.committer)),n}withoutSignature(){const t=Rt(this._tag);return t.indexOf(`
-----BEGIN PGP SIGNATURE-----`)===-1?t:t.slice(0,t.lastIndexOf(`
-----BEGIN PGP SIGNATURE-----`))}gpgsig(){if(this._tag.indexOf(`
-----BEGIN PGP SIGNATURE-----`)===-1)return;const t=this._tag.slice(this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),this._tag.indexOf("-----END PGP SIGNATURE-----")+27);return Rt(t)}payload(){return this.withoutSignature()+`
`}toObject(){return Buffer.from(this._tag,"utf8")}static async sign(t,e,n){const i=t.payload();let{signature:s}=await e({payload:i,secretKey:n});s=Rt(s);const a=i+s;return wt.from(a)}}function sn(r){return r.trim().split(`
`).map(t=>" "+t).join(`
`)+`
`}function ta(r){return r.split(`
`).map(t=>t.replace(/^ /,"")).join(`
`)}class et{constructor(t){if(typeof t=="string")this._commit=t;else if(Buffer.isBuffer(t))this._commit=t.toString("utf8");else if(typeof t=="object")this._commit=et.render(t);else throw new M("invalid type passed to GitCommit constructor")}static fromPayloadSignature({payload:t,signature:e}){const n=et.justHeaders(t),i=et.justMessage(t),s=Rt(n+`
gpgsig`+sn(e)+`
`+i);return new et(s)}static from(t){return new et(t)}toObject(){return Buffer.from(this._commit,"utf8")}headers(){return this.parseHeaders()}message(){return et.justMessage(this._commit)}parse(){return Object.assign({message:this.message()},this.headers())}static justMessage(t){return Rt(t.slice(t.indexOf(`

`)+2))}static justHeaders(t){return t.slice(0,t.indexOf(`

`))}parseHeaders(){const t=et.justHeaders(this._commit).split(`
`),e=[];for(const i of t)i[0]===" "?e[e.length-1]+=`
`+i.slice(1):e.push(i);const n={parent:[]};for(const i of e){const s=i.slice(0,i.indexOf(" ")),a=i.slice(i.indexOf(" ")+1);Array.isArray(n[s])?n[s].push(a):n[s]=a}return n.author&&(n.author=Me(n.author)),n.committer&&(n.committer=Me(n.committer)),n}static renderHeaders(t){let e="";if(t.tree?e+=`tree ${t.tree}
`:e+=`tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`,t.parent){if(t.parent.length===void 0)throw new M("commit 'parent' property should be an array");for(const s of t.parent)e+=`parent ${s}
`}const n=t.author;e+=`author ${rn(n)}
`;const i=t.committer||t.author;return e+=`committer ${rn(i)}
`,t.gpgsig&&(e+="gpgsig"+sn(t.gpgsig)),e}static render(t){return et.renderHeaders(t)+`
`+Rt(t.message)}render(){return this._commit}withoutSignature(){const t=Rt(this._commit);if(t.indexOf(`
gpgsig`)===-1)return t;const e=t.slice(0,t.indexOf(`
gpgsig`)),n=t.slice(t.indexOf(`-----END PGP SIGNATURE-----
`)+28);return Rt(e+`
`+n)}isolateSignature(){const t=this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),this._commit.indexOf("-----END PGP SIGNATURE-----")+27);return ta(t)}static async sign(t,e,n){const i=t.withoutSignature(),s=et.justMessage(t._commit);let{signature:a}=await e({payload:i,secretKey:n});a=Rt(a);const f=et.justHeaders(t._commit)+`
gpgsig`+sn(a)+`
`+s;return et.from(f)}}async function te({fs:r,cache:t,gitdir:e,oid:n}){if(n==="4b825dc642cb6eb9a060e54bf8d69288fbee4904")return{tree:mt.from([]),oid:n};const{type:i,object:s}=await tt({fs:r,cache:t,gitdir:e,oid:n});if(i==="tag")return n=wt.from(s).parse().object,te({fs:r,cache:t,gitdir:e,oid:n});if(i==="commit")return n=et.from(s).parse().tree,te({fs:r,cache:t,gitdir:e,oid:n});if(i!=="tree")throw new dt(n,i,"tree");return{tree:mt.from(s),oid:n}}class ea{constructor({fs:t,gitdir:e,ref:n,cache:i}){this.fs=t,this.cache=i,this.gitdir=e,this.mapPromise=(async()=>{const a=new Map;let o;try{o=await S.resolve({fs:t,gitdir:e,ref:n})}catch(l){l instanceof Q&&(o="4b825dc642cb6eb9a060e54bf8d69288fbee4904")}const f=await te({fs:t,cache:this.cache,gitdir:e,oid:o});return f.type="tree",f.mode="40000",a.set(".",f),a})();const s=this;this.ConstructEntry=class{constructor(o){this._fullpath=o,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return s.type(this)}async mode(){return s.mode(this)}async stat(){return s.stat(this)}async content(){return s.content(this)}async oid(){return s.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:n,cache:i,gitdir:s}=this,a=await this.mapPromise,o=a.get(e);if(!o)throw new Error(`No obj for ${e}`);const f=o.oid;if(!f)throw new Error(`No oid for obj ${JSON.stringify(o)}`);if(o.type!=="tree")return null;const{type:l,object:c}=await tt({fs:n,cache:i,gitdir:s,oid:f});if(l!==o.type)throw new dt(f,l,o.type);const h=mt.from(c);for(const u of h)a.set(m.join(e,u.path),u);return h.entries().map(u=>m.join(e,u.path))}async type(t){if(t._type===!1){const e=await this.mapPromise,{type:n}=e.get(t._fullpath);t._type=n}return t._type}async mode(t){if(t._mode===!1){const e=await this.mapPromise,{mode:n}=e.get(t._fullpath);t._mode=K(parseInt(n,8))}return t._mode}async stat(t){}async content(t){if(t._content===!1){const e=await this.mapPromise,{fs:n,cache:i,gitdir:s}=this,o=e.get(t._fullpath).oid,{type:f,object:l}=await tt({fs:n,cache:i,gitdir:s,oid:o});f!=="blob"?t._content=void 0:t._content=new Uint8Array(l)}return t._content}async oid(t){if(t._oid===!1){const n=(await this.mapPromise).get(t._fullpath);t._oid=n.oid}return t._oid}}function bt({ref:r="HEAD"}={}){const t=Object.create(null);return Object.defineProperty(t,Te,{value:function({fs:e,gitdir:n,cache:i}){return new ea({fs:e,gitdir:n,ref:r,cache:i})}}),Object.freeze(t),t}class na{constructor({fs:t,dir:e,gitdir:n,cache:i}){this.fs=t,this.cache=i,this.dir=e,this.gitdir=n,this.config=null;const s=this;this.ConstructEntry=class{constructor(o){this._fullpath=o,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return s.type(this)}async mode(){return s.mode(this)}async stat(){return s.stat(this)}async content(){return s.content(this)}async oid(){return s.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:n,dir:i}=this,s=await n.readdir(m.join(i,e));return s===null?null:s.map(a=>m.join(e,a))}async type(t){return t._type===!1&&await t.stat(),t._type}async mode(t){return t._mode===!1&&await t.stat(),t._mode}async stat(t){if(t._stat===!1){const{fs:e,dir:n}=this;let i=await e.lstat(`${n}/${t._fullpath}`);if(!i)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);let s=i.isDirectory()?"tree":"blob";s==="blob"&&!i.isFile()&&!i.isSymbolicLink()&&(s="special"),t._type=s,i=Et(i),t._mode=i.mode,i.size===-1&&t._actualSize&&(i.size=t._actualSize),t._stat=i}return t._stat}async content(t){if(t._content===!1){const{fs:e,dir:n,gitdir:i}=this;if(await t.type()==="tree")t._content=void 0;else{const a=await(await this._getGitConfig(e,i)).get("core.autocrlf"),o=await e.read(`${n}/${t._fullpath}`,{autocrlf:a});t._actualSize=o.length,t._stat&&t._stat.size===-1&&(t._stat.size=t._actualSize),t._content=new Uint8Array(o)}}return t._content}async oid(t){if(t._oid===!1){const e=this,{fs:n,gitdir:i,cache:s}=this;let a;await st.acquire({fs:n,gitdir:i,cache:s},async function(o){const f=o.entriesMap.get(t._fullpath),l=await t.stat(),h=await(await e._getGitConfig(n,i)).get("core.filemode"),u=typeof process<"u"?process.platform!=="win32":!0;if(!f||Be(l,f,h,u)){const d=await t.content();d===void 0?a=void 0:(a=await jt(Vt.wrap({type:"blob",object:d})),f&&a===f.oid&&(!h||l.mode===f.mode)&&Be(l,f,h,u)&&o.insert({filepath:t._fullpath,stats:l,oid:a}))}else a=f.oid}),t._oid=a}return t._oid}async _getGitConfig(t,e){return this.config?this.config:(this.config=await it.get({fs:t,gitdir:e}),this.config)}}function ee(){const r=Object.create(null);return Object.defineProperty(r,Te,{value:function({fs:t,dir:e,gitdir:n,cache:i}){return new na({fs:t,dir:e,gitdir:n,cache:i})}}),Object.freeze(r),r}function ra(r,t){const e=t-r;return Array.from({length:e},(n,i)=>r+i)}const Kn=typeof Array.prototype.flat>"u"?r=>r.reduce((t,e)=>t.concat(e),[]):r=>r.flat();class ia{constructor(){this.value=null}consider(t){t!=null&&(this.value===null?this.value=t:t<this.value&&(this.value=t))}reset(){this.value=null}}function*sa(r){const t=new ia;let e;const n=[],i=r.length;for(let s=0;s<i;s++)n[s]=r[s].next().value,n[s]!==void 0&&t.consider(n[s]);if(t.value!==null)for(;;){const s=[];e=t.value,t.reset();for(let a=0;a<i;a++)n[a]!==void 0&&n[a]===e?(s[a]=n[a],n[a]=r[a].next().value):s[a]=null,n[a]!==void 0&&t.consider(n[a]);if(yield s,t.value===null)return}}async function Ct({fs:r,cache:t,dir:e,gitdir:n,trees:i,map:s=async(f,l)=>l,reduce:a=async(f,l)=>{const c=Kn(l);return f!==void 0&&c.unshift(f),c},iterate:o=(f,l)=>Promise.all([...l].map(f))}){const f=i.map(d=>d[Te]({fs:r,dir:e,gitdir:n,cache:t})),l=new Array(f.length).fill("."),c=ra(0,f.length),h=async d=>{c.map(_=>{const k=d[_];d[_]=k&&new f[_].ConstructEntry(k)});const b=(await Promise.all(c.map(_=>{const k=d[_];return k?f[_].readdir(k):[]}))).map(_=>(_===null?[]:_)[Symbol.iterator]());return{entries:d,children:sa(b)}},u=async d=>{const{entries:y,children:b}=await h(d),_=y.find(v=>v&&v._fullpath)._fullpath,k=await s(_,y);if(k!==null){let v=await o(u,b);return v=v.filter(C=>C!==void 0),a(k,v)}};return u(l)}async function an(r,t){const e=await r.readdir(t);e==null?await r.rm(t):e.length?await Promise.all(e.map(n=>{const i=m.join(t,n);return r.lstat(i).then(s=>{if(s)return s.isDirectory()?an(r,i):r.rm(i)})})).then(()=>r.rmdir(t)):await r.rmdir(t)}function aa(r){return oa(r)&&tr(r.then)&&tr(r.catch)}function oa(r){return r&&typeof r=="object"}function tr(r){return typeof r=="function"}function er(r){return aa((e=>{try{return e.readFile().catch(n=>n)}catch(n){return n}})(r))}const nr=["readFile","writeFile","mkdir","rmdir","unlink","stat","lstat","readdir","readlink","symlink"];function rr(r,t){if(er(t))for(const e of nr)r[`_${e}`]=t[e].bind(t);else for(const e of nr)r[`_${e}`]=j(t[e].bind(t));er(t)?t.rm?r._rm=t.rm.bind(t):t.rmdir.length>1?r._rm=t.rmdir.bind(t):r._rm=an.bind(null,r):t.rm?r._rm=j(t.rm.bind(t)):t.rmdir.length>2?r._rm=j(t.rmdir.bind(t)):r._rm=an.bind(null,r)}class z{constructor(t){if(typeof t._original_unwrapped_fs<"u")return t;const e=Object.getOwnPropertyDescriptor(t,"promises");e&&e.enumerable?rr(this,t.promises):rr(this,t),this._original_unwrapped_fs=t}async exists(t,e={}){try{return await this._stat(t),!0}catch(n){if(n.code==="ENOENT"||n.code==="ENOTDIR"||(n.code||"").includes("ENS"))return!1;throw console.log('Unhandled error in "FileSystem.exists()" function',n),n}}async read(t,e={}){try{let n=await this._readFile(t,e);if(e.autocrlf==="true")try{n=new TextDecoder("utf8",{fatal:!0}).decode(n),n=n.replace(/\r\n/g,`
`),n=new TextEncoder().encode(n)}catch{}return typeof n!="string"&&(n=Buffer.from(n)),n}catch{return null}}async write(t,e,n={}){try{await this._writeFile(t,e,n);return}catch{await this.mkdir(Gt(t)),await this._writeFile(t,e,n)}}async mkdir(t,e=!1){try{await this._mkdir(t);return}catch(n){if(n===null||n.code==="EEXIST")return;if(e)throw n;if(n.code==="ENOENT"){const i=Gt(t);if(i==="."||i==="/"||i===t)throw n;await this.mkdir(i),await this.mkdir(t,!0)}}}async rm(t){try{await this._unlink(t)}catch(e){if(e.code!=="ENOENT")throw e}}async rmdir(t,e){try{e&&e.recursive?await this._rm(t,e):await this._rmdir(t)}catch(n){if(n.code!=="ENOENT")throw n}}async readdir(t){try{const e=await this._readdir(t);return e.sort(G),e}catch(e){return e.code==="ENOTDIR"?null:[]}}async readdirDeep(t){const e=await this._readdir(t);return(await Promise.all(e.map(async i=>{const s=t+"/"+i;return(await this._stat(s)).isDirectory()?this.readdirDeep(s):s}))).reduce((i,s)=>i.concat(s),[])}async lstat(t){try{return await this._lstat(t)}catch(e){if(e.code==="ENOENT"||(e.code||"").includes("ENS"))return null;throw e}}async readlink(t,e={encoding:"buffer"}){try{const n=await this._readlink(t,e);return Buffer.isBuffer(n)?n:Buffer.from(n)}catch(n){if(n.code==="ENOENT"||(n.code||"").includes("ENS"))return null;throw n}}async writelink(t,e){return this._symlink(e.toString("utf8"),t)}}function w(r,t){if(t===void 0)throw new pt(r)}async function Fe(r,t){return!r&&!t?!1:r&&!t||!r&&t?!0:!(await r.type()==="tree"&&await t.type()==="tree"||await r.type()===await t.type()&&await r.mode()===await t.mode()&&await r.oid()===await t.oid())}async function ir({fs:r,dir:t,gitdir:e=m.join(t,".git"),commit:n="HEAD",cache:i={}}){try{w("fs",r),w("dir",t),w("gitdir",e);const s=new z(r),a=[bt({ref:n}),ee(),Mt()];let o=[];await st.acquire({fs:s,gitdir:e,cache:i},async function(l){o=l.unmergedPaths});const f=await Ct({fs:s,cache:i,dir:t,gitdir:e,trees:a,map:async function(l,[c,h,u]){const d=!await Fe(h,u),y=o.includes(l),b=!await Fe(u,c);if(d||y)return c?{path:l,mode:await c.mode(),oid:await c.oid(),type:await c.type(),content:await c.content()}:void 0;if(b)return!1;throw new ke(l)}});await st.acquire({fs:s,gitdir:e,cache:i},async function(l){for(const c of f)if(c!==!1){if(!c){await s.rmdir(`${t}/${c.path}`,{recursive:!0}),l.delete({filepath:c.path});continue}if(c.type==="blob"){const h=new TextDecoder().decode(c.content);await s.write(`${t}/${c.path}`,h,{mode:c.mode}),l.insert({filepath:c.path,oid:c.oid,stage:0})}}})}catch(s){throw s.caller="git.abortMerge",s}}class ne{static async isIgnored({fs:t,dir:e,gitdir:n=m.join(e,".git"),filepath:i}){if(Pe(i)===".git")return!0;if(i===".")return!1;let s="";const a=m.join(n,"info","exclude");await t.exists(a)&&(s=await t.read(a,"utf8"));const o=[{gitignore:m.join(e,".gitignore"),filepath:i}],f=i.split("/").filter(Boolean);for(let c=1;c<f.length;c++){const h=f.slice(0,c).join("/"),u=f.slice(c).join("/");o.push({gitignore:m.join(e,h,".gitignore"),filepath:u})}let l=!1;for(const c of o){let h;try{h=await t.read(c.gitignore,"utf8")}catch(y){if(y.code==="NOENT")continue}const u=g().add(s);u.add(h);const d=Gt(c.filepath);if(d!=="."&&u.ignores(d))return!0;l?l=!u.test(c.filepath).unignored:l=u.test(c.filepath).ignored}return l}}async function ca({fs:r,gitdir:t,object:e,format:n,oid:i}){const s=`objects/${i.slice(0,2)}/${i.slice(2)}`,a=`${t}/${s}`;await r.exists(a)||await r.write(a,e)}let on=null;async function sr(r){return on===null&&(on=fa()),on?la(r):O.deflate(r)}async function la(r){const t=new CompressionStream("deflate"),e=new Blob([r]).stream().pipeThrough(t);return new Uint8Array(await new Response(e).arrayBuffer())}function fa(){try{return new CompressionStream("deflate").writable.close(),new Blob([]).stream().cancel(),!0}catch{return!1}}async function yt({fs:r,gitdir:t,type:e,object:n,format:i="content",oid:s=void 0,dryRun:a=!1}){return i!=="deflated"&&(i!=="wrapped"&&(n=Vt.wrap({type:e,object:n})),s=await jt(n),n=Buffer.from(await sr(n))),a||await ca({fs:r,gitdir:t,object:n,format:"deflated",oid:s}),s}function ar(r){let t;for(;~(t=r.indexOf(92));)r[t]=47;return r}async function or({fs:r,dir:t,gitdir:e=m.join(t,".git"),filepath:n,cache:i={},force:s=!1,parallel:a=!0}){try{w("fs",r),w("dir",t),w("gitdir",e),w("filepath",n);const o=new z(r);await st.acquire({fs:o,gitdir:e,cache:i},async f=>{const c=await(await it.get({fs:o,gitdir:e})).get("core.autocrlf");return cn({dir:t,gitdir:e,fs:o,filepath:n,index:f,force:s,parallel:a,autocrlf:c})})}catch(o){throw o.caller="git.add",o}}async function cn({dir:r,gitdir:t,fs:e,filepath:n,index:i,force:s,parallel:a,autocrlf:o}){n=Array.isArray(n)?n:[n];const f=n.map(async u=>{if(!s&&await ne.isIgnored({fs:e,dir:r,gitdir:t,filepath:u}))return;const d=await e.lstat(m.join(r,u));if(!d)throw new Q(u);if(d.isDirectory()){const y=await e.readdir(m.join(r,u));if(a){const b=y.map(_=>cn({dir:r,gitdir:t,fs:e,filepath:[m.join(u,_)],index:i,force:s,parallel:a,autocrlf:o}));await Promise.all(b)}else for(const b of y)await cn({dir:r,gitdir:t,fs:e,filepath:[m.join(u,b)],index:i,force:s,parallel:a,autocrlf:o})}else{const y=d.isSymbolicLink()?await e.readlink(m.join(r,u)).then(ar):await e.read(m.join(r,u),{autocrlf:o});if(y===null)throw new Q(u);const b=await yt({fs:e,gitdir:t,type:"blob",object:y});i.insert({filepath:u,stats:d,oid:b})}}),l=await Promise.allSettled(f),c=l.filter(u=>u.status==="rejected").map(u=>u.reason);if(c.length>1)throw new ye(c);if(c.length===1)throw c[0];return l.filter(u=>u.status==="fulfilled"&&u.value).map(u=>u.value)}async function Se({fs:r,gitdir:t,path:e}){return(await it.get({fs:r,gitdir:t})).get(e)}function cr(r,...t){for(const e of t)if(e)for(const n of Object.keys(e)){const i=e[n];i!==void 0&&(r[n]=i)}return r}async function At({fs:r,gitdir:t,author:e,commit:n}){const i=Math.floor(Date.now()/1e3),s={name:await Se({fs:r,gitdir:t,path:"user.name"}),email:await Se({fs:r,gitdir:t,path:"user.email"})||"",timestamp:i,timezoneOffset:new Date(i*1e3).getTimezoneOffset()},a=cr({},s,n?n.author:void 0,e);if(a.name!==void 0)return a}async function re({fs:r,gitdir:t,author:e,committer:n,commit:i}){const s=Math.floor(Date.now()/1e3),a={name:await Se({fs:r,gitdir:t,path:"user.name"}),email:await Se({fs:r,gitdir:t,path:"user.email"})||"",timestamp:s,timezoneOffset:new Date(s*1e3).getTimezoneOffset()},o=cr({},a,i?i.committer:void 0,e,n);if(o.name!==void 0)return o}async function lr({fs:r,cache:t,gitdir:e,oid:n}){const{type:i,object:s}=await tt({fs:r,cache:t,gitdir:e,oid:n});if(i==="tag")return n=wt.from(s).parse().object,lr({fs:r,cache:t,gitdir:e,oid:n});if(i!=="commit")throw new dt(n,i,"commit");return{commit:et.from(s),oid:n}}async function ie({fs:r,cache:t,gitdir:e,oid:n}){const{commit:i,oid:s}=await lr({fs:r,cache:t,gitdir:e,oid:n});return{oid:s,commit:i.parse(),payload:i.withoutSignature()}}async function Ue({fs:r,cache:t,onSign:e,gitdir:n,message:i,author:s,committer:a,signingKey:o,amend:f=!1,dryRun:l=!1,noUpdateBranch:c=!1,ref:h,parent:u,tree:d}){let y=!1;h||(h=await S.resolve({fs:r,gitdir:n,ref:"HEAD",depth:2}));let b,_;try{b=await S.resolve({fs:r,gitdir:n,ref:h}),_=await ie({fs:r,gitdir:n,oid:b,cache:{}})}catch{y=!0}if(f&&y)throw new ve(h);const k=f?await At({fs:r,gitdir:n,author:s,commit:_.commit}):await At({fs:r,gitdir:n,author:s});if(!k)throw new ut("author");const v=f?await re({fs:r,gitdir:n,author:k,committer:a,commit:_.commit}):await re({fs:r,gitdir:n,author:k,committer:a});if(!v)throw new ut("committer");return st.acquire({fs:r,gitdir:n,cache:t,allowUnmerged:!1},async function(C){const q=Mn(C.entries).get(".");if(d||(d=await fr({fs:r,gitdir:n,inode:q,dryRun:l})),u?u=await Promise.all(u.map(B=>S.resolve({fs:r,gitdir:n,ref:B}))):f?u=_.commit.parent:u=b?[b]:[],!i)if(f)i=_.commit.message;else throw new pt("message");let N=et.from({tree:d,parent:u,author:k,committer:v,message:i});o&&(N=await et.sign(N,e,o));const R=await yt({fs:r,gitdir:n,type:"commit",object:N.toObject(),dryRun:l});return!c&&!l&&await S.writeRef({fs:r,gitdir:n,ref:h,value:R}),R})}async function fr({fs:r,gitdir:t,inode:e,dryRun:n}){const i=e.children;for(const f of i)f.type==="tree"&&(f.metadata.mode="040000",f.metadata.oid=await fr({fs:r,gitdir:t,inode:f,dryRun:n}));const s=i.map(f=>({mode:f.metadata.mode,path:f.basename,oid:f.metadata.oid,type:f.type})),a=mt.from(s);return await yt({fs:r,gitdir:t,type:"tree",object:a.toObject(),dryRun:n})}async function xe({fs:r,cache:t,gitdir:e,oid:n,filepath:i}){if(i.startsWith("/"))throw new Pt("leading-slash");if(i.endsWith("/"))throw new Pt("trailing-slash");const s=n,a=await te({fs:r,cache:t,gitdir:e,oid:n}),o=a.tree;if(i==="")n=a.oid;else{const f=i.split("/");n=await ur({fs:r,cache:t,gitdir:e,tree:o,pathArray:f,oid:s,filepath:i})}return n}async function ur({fs:r,cache:t,gitdir:e,tree:n,pathArray:i,oid:s,filepath:a}){const o=i.shift();for(const f of n)if(f.path===o){if(i.length===0)return f.oid;{const{type:l,object:c}=await tt({fs:r,cache:t,gitdir:e,oid:f.oid});if(l!=="tree")throw new dt(s,l,"tree",a);return n=mt.from(c),ur({fs:r,cache:t,gitdir:e,tree:n,pathArray:i,oid:s,filepath:a})}}throw new Q(`file or directory found at "${s}:${a}"`)}async function se({fs:r,cache:t,gitdir:e,oid:n,filepath:i=void 0}){i!==void 0&&(n=await xe({fs:r,cache:t,gitdir:e,oid:n,filepath:i}));const{tree:s,oid:a}=await te({fs:r,cache:t,gitdir:e,oid:n});return{oid:a,tree:s.entries()}}async function $e({fs:r,gitdir:t,tree:e}){const n=mt.from(e).toObject();return await yt({fs:r,gitdir:t,type:"tree",object:n,format:"content"})}async function ua({fs:r,cache:t,onSign:e,gitdir:n,ref:i,oid:s,note:a,force:o,author:f,committer:l,signingKey:c}){let h;try{h=await S.resolve({gitdir:n,fs:r,ref:i})}catch(k){if(!(k instanceof Q))throw k}let d=(await se({fs:r,cache:t,gitdir:n,oid:h||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;if(o)d=d.filter(k=>k.path!==s);else for(const k of d)if(k.path===s)throw new vt("note",s);typeof a=="string"&&(a=Buffer.from(a,"utf8"));const y=await yt({fs:r,gitdir:n,type:"blob",object:a,format:"content"});d.push({mode:"100644",path:s,oid:y,type:"blob"});const b=await $e({fs:r,gitdir:n,tree:d});return await Ue({fs:r,cache:t,onSign:e,gitdir:n,ref:i,tree:b,parent:h&&[h],message:`Note added by 'isomorphic-git addNote'
`,author:f,committer:l,signingKey:c})}async function hr({fs:r,onSign:t,dir:e,gitdir:n=m.join(e,".git"),ref:i="refs/notes/commits",oid:s,note:a,force:o,author:f,committer:l,signingKey:c,cache:h={}}){try{w("fs",r),w("gitdir",n),w("oid",s),w("note",a),c&&w("onSign",t);const u=new z(r),d=await At({fs:u,gitdir:n,author:f});if(!d)throw new ut("author");const y=await re({fs:u,gitdir:n,author:d,committer:l});if(!y)throw new ut("committer");return await ua({fs:new z(u),cache:h,onSign:t,gitdir:n,ref:i,oid:s,note:a,force:o,author:d,committer:y,signingKey:c})}catch(u){throw u.caller="git.addNote",u}}async function dr({fs:r,gitdir:t,remote:e,url:n,force:i}){if(e!==p.clean(e))throw new St(e,p.clean(e));const s=await it.get({fs:r,gitdir:t});if(!i&&(await s.getSubsections("remote")).includes(e)&&n!==await s.get(`remote.${e}.url`))throw new vt("remote",e);await s.set(`remote.${e}.url`,n),await s.set(`remote.${e}.fetch`,`+refs/heads/*:refs/remotes/${e}/*`),await it.save({fs:r,gitdir:t,config:s})}async function wr({fs:r,dir:t,gitdir:e=m.join(t,".git"),remote:n,url:i,force:s=!1}){try{return w("fs",r),w("gitdir",e),w("remote",n),w("url",i),await dr({fs:new z(r),gitdir:e,remote:n,url:i,force:s})}catch(a){throw a.caller="git.addRemote",a}}async function ha({fs:r,cache:t,onSign:e,gitdir:n,ref:i,tagger:s,message:a=i,gpgsig:o,object:f,signingKey:l,force:c=!1}){if(i=i.startsWith("refs/tags/")?i:`refs/tags/${i}`,!c&&await S.exists({fs:r,gitdir:n,ref:i}))throw new vt("tag",i);const h=await S.resolve({fs:r,gitdir:n,ref:f||"HEAD"}),{type:u}=await tt({fs:r,cache:t,gitdir:n,oid:h});let d=wt.from({object:h,type:u,tag:i.replace("refs/tags/",""),tagger:s,message:a,gpgsig:o});l&&(d=await wt.sign(d,e,l));const y=await yt({fs:r,gitdir:n,type:"tag",object:d.toObject()});await S.writeRef({fs:r,gitdir:n,ref:i,value:y})}async function mr({fs:r,onSign:t,dir:e,gitdir:n=m.join(e,".git"),ref:i,tagger:s,message:a=i,gpgsig:o,object:f,signingKey:l,force:c=!1,cache:h={}}){try{w("fs",r),w("gitdir",n),w("ref",i),l&&w("onSign",t);const u=new z(r),d=await At({fs:u,gitdir:n,author:s});if(!d)throw new ut("tagger");return await ha({fs:u,cache:h,onSign:t,gitdir:n,ref:i,tagger:d,message:a,gpgsig:o,object:f,signingKey:l,force:c})}catch(u){throw u.caller="git.annotatedTag",u}}async function da({fs:r,gitdir:t,ref:e,object:n,checkout:i=!1,force:s=!1}){if(e!==p.clean(e))throw new St(e,p.clean(e));const a=`refs/heads/${e}`;if(!s&&await S.exists({fs:r,gitdir:t,ref:a}))throw new vt("branch",e,!1);let o;try{o=await S.resolve({fs:r,gitdir:t,ref:n||"HEAD"})}catch{}o&&await S.writeRef({fs:r,gitdir:t,ref:a,value:o}),i&&await S.writeSymbolicRef({fs:r,gitdir:t,ref:"HEAD",value:a})}async function pr({fs:r,dir:t,gitdir:e=m.join(t,".git"),ref:n,object:i,checkout:s=!1,force:a=!1}){try{return w("fs",r),w("gitdir",e),w("ref",n),await da({fs:new z(r),gitdir:e,ref:n,object:i,checkout:s,force:a})}catch(o){throw o.caller="git.branch",o}}const yr=(r,t)=>r==="."||t==null||t.length===0||t==="."?!0:t.length>=r.length?t.startsWith(r):r.startsWith(t);async function ln({fs:r,cache:t,onProgress:e,onPostCheckout:n,dir:i,gitdir:s,remote:a,ref:o,filepaths:f,noCheckout:l,noUpdateHead:c,dryRun:h,force:u,track:d=!0,nonBlocking:y=!1,batchSize:b=100}){let _;if(n)try{_=await S.resolve({fs:r,gitdir:s,ref:"HEAD"})}catch{_="0000000000000000000000000000000000000000"}let k;try{k=await S.resolve({fs:r,gitdir:s,ref:o})}catch(v){if(o==="HEAD")throw v;const C=`${a}/${o}`;if(k=await S.resolve({fs:r,gitdir:s,ref:C}),d){const F=await it.get({fs:r,gitdir:s});await F.set(`branch.${o}.remote`,a),await F.set(`branch.${o}.merge`,`refs/heads/${o}`),await it.save({fs:r,gitdir:s,config:F})}await S.writeRef({fs:r,gitdir:s,ref:`refs/heads/${o}`,value:k})}if(!l){let v;try{v=await wa({fs:r,cache:t,onProgress:e,dir:i,gitdir:s,ref:o,force:u,filepaths:f})}catch(R){throw R instanceof Q&&R.data.what===k?new he(o,k):R}const C=v.filter(([R])=>R==="conflict").map(([R,B])=>B);if(C.length>0)throw new ue(C);const F=v.filter(([R])=>R==="error").map(([R,B])=>B);if(F.length>0)throw new M(F.join(", "));if(h){n&&await n({previousHead:_,newHead:k,type:f!=null&&f.length>0?"file":"branch"});return}let q=0;const N=v.length;if(await st.acquire({fs:r,gitdir:s,cache:t},async function(R){await Promise.all(v.filter(([B])=>B==="delete"||B==="delete-index").map(async function([B,D]){const W=`${i}/${D}`;B==="delete"&&await r.rm(W),R.delete({filepath:D}),e&&await e({phase:"Updating workdir",loaded:++q,total:N})}))}),await st.acquire({fs:r,gitdir:s,cache:t},async function(R){for(const[B,D]of v)if(B==="rmdir"||B==="rmdir-index"){const W=`${i}/${D}`;try{B==="rmdir"&&await r.rmdir(W),R.delete({filepath:D}),e&&await e({phase:"Updating workdir",loaded:++q,total:N})}catch(X){if(X.code==="ENOTEMPTY")console.log(`Did not delete ${D} because directory is not empty`);else throw X}}}),await Promise.all(v.filter(([R])=>R==="mkdir"||R==="mkdir-index").map(async function([R,B]){const D=`${i}/${B}`;await r.mkdir(D),e&&await e({phase:"Updating workdir",loaded:++q,total:N})})),y){const R=v.filter(([D])=>D==="create"||D==="create-index"||D==="update"||D==="mkdir-index"),B=await gr("Update Working Dir",R.map(([D,W,X,at,Y])=>()=>pa({fs:r,cache:t,gitdir:s,dir:i},[D,W,X,at,Y])),e,b);await st.acquire({fs:r,gitdir:s,cache:t,allowUnmerged:!0},async function(D){await gr("Update Index",B.map(([W,X,at])=>()=>ma({index:D,fullpath:W,oid:X,stats:at})),e,b)})}else await st.acquire({fs:r,gitdir:s,cache:t,allowUnmerged:!0},async function(R){await Promise.all(v.filter(([B])=>B==="create"||B==="create-index"||B==="update"||B==="mkdir-index").map(async function([B,D,W,X,at]){const Y=`${i}/${D}`;try{if(B!=="create-index"&&B!=="mkdir-index"){const{object:lt}=await tt({fs:r,cache:t,gitdir:s,oid:W});if(at&&await r.rm(Y),X===33188)await r.write(Y,lt);else if(X===33261)await r.write(Y,lt,{mode:511});else if(X===40960)await r.writelink(Y,lt);else throw new M(`Invalid mode 0o${X.toString(8)} detected in blob ${W}`)}const ot=await r.lstat(Y);X===33261&&(ot.mode=493),B==="mkdir-index"&&(ot.mode=57344),R.insert({filepath:D,stats:ot,oid:W}),e&&await e({phase:"Updating workdir",loaded:++q,total:N})}catch(ot){console.log(ot)}}))});n&&await n({previousHead:_,newHead:k,type:f!=null&&f.length>0?"file":"branch"})}if(!c){const v=await S.expand({fs:r,gitdir:s,ref:o});v.startsWith("refs/heads")?await S.writeSymbolicRef({fs:r,gitdir:s,ref:"HEAD",value:v}):await S.writeRef({fs:r,gitdir:s,ref:"HEAD",value:k})}}async function wa({fs:r,cache:t,onProgress:e,dir:n,gitdir:i,ref:s,force:a,filepaths:o}){let f=0;return Ct({fs:r,cache:t,dir:n,gitdir:i,trees:[bt({ref:s}),ee(),Mt()],map:async function(l,[c,h,u]){if(l===".")return;if(o&&!o.some(y=>yr(l,y)))return null;switch(e&&await e({phase:"Analyzing workdir",loaded:++f}),[!!u,!!c,!!h].map(Number).join("")){case"000":return;case"001":return a&&o&&o.includes(l)?["delete",l]:void 0;case"010":switch(await c.type()){case"tree":return["mkdir",l];case"blob":return["create",l,await c.oid(),await c.mode()];case"commit":return["mkdir-index",l,await c.oid(),await c.mode()];default:return["error",`new entry Unhandled type ${await c.type()}`]}case"011":switch(`${await c.type()}-${await h.type()}`){case"tree-tree":return;case"tree-blob":case"blob-tree":return["conflict",l];case"blob-blob":return await c.oid()!==await h.oid()?a?["update",l,await c.oid(),await c.mode(),await c.mode()!==await h.mode()]:["conflict",l]:await c.mode()!==await h.mode()?a?["update",l,await c.oid(),await c.mode(),!0]:["conflict",l]:["create-index",l,await c.oid(),await c.mode()];case"commit-tree":return;case"commit-blob":return["conflict",l];default:return["error",`new entry Unhandled type ${c.type}`]}case"100":return["delete-index",l];case"101":switch(await u.type()){case"tree":return["rmdir-index",l];case"blob":return await u.oid()!==await h.oid()?a?["delete",l]:["conflict",l]:["delete",l];case"commit":return["rmdir-index",l];default:return["error",`delete entry Unhandled type ${await u.type()}`]}case"110":case"111":switch(`${await u.type()}-${await c.type()}`){case"tree-tree":return;case"blob-blob":{if(await u.oid()===await c.oid()&&await u.mode()===await c.mode()&&!a)return;if(h){if(await h.oid()!==await u.oid()&&await h.oid()!==await c.oid())return a?["update",l,await c.oid(),await c.mode(),await c.mode()!==await h.mode()]:["conflict",l]}else if(a)return["update",l,await c.oid(),await c.mode(),await c.mode()!==await u.mode()];return await c.mode()!==await u.mode()?["update",l,await c.oid(),await c.mode(),!0]:await c.oid()!==await u.oid()?["update",l,await c.oid(),await c.mode(),!1]:void 0}case"tree-blob":return["update-dir-to-blob",l,await c.oid()];case"blob-tree":return["update-blob-to-tree",l];case"commit-commit":return["mkdir-index",l,await c.oid(),await c.mode()];default:return["error",`update entry Unhandled type ${await u.type()}-${await c.type()}`]}}},reduce:async function(l,c){return c=Kn(c),l?l&&l[0]==="rmdir"?(c.push(l),c):(c.unshift(l),c):c}})}async function ma({index:r,fullpath:t,stats:e,oid:n}){try{r.insert({filepath:t,stats:e,oid:n})}catch(i){console.warn(`Error inserting ${t} into index:`,i)}}async function pa({fs:r,cache:t,gitdir:e,dir:n},[i,s,a,o,f]){const l=`${n}/${s}`;if(i!=="create-index"&&i!=="mkdir-index"){const{object:h}=await tt({fs:r,cache:t,gitdir:e,oid:a});if(f&&await r.rm(l),o===33188)await r.write(l,h);else if(o===33261)await r.write(l,h,{mode:511});else if(o===40960)await r.writelink(l,h);else throw new M(`Invalid mode 0o${o.toString(8)} detected in blob ${a}`)}const c=await r.lstat(l);return o===33261&&(c.mode=493),i==="mkdir-index"&&(c.mode=57344),[s,a,c]}async function gr(r,t,e,n){const i=[];try{for(let s=0;s<t.length;s+=n){const a=t.slice(s,s+n).map(f=>f());(await Promise.allSettled(a)).forEach(f=>{f.status==="fulfilled"&&i.push(f.value)}),e&&await e({phase:"Updating workdir",loaded:s+a.length,total:t.length})}return i}catch(s){console.error(`Error during ${r}: ${s}`)}return i}async function fn({fs:r,onProgress:t,onPostCheckout:e,dir:n,gitdir:i=m.join(n,".git"),remote:s="origin",ref:a,filepaths:o,noCheckout:f=!1,noUpdateHead:l=a===void 0,dryRun:c=!1,force:h=!1,track:u=!0,cache:d={},nonBlocking:y=!1,batchSize:b=100}){try{w("fs",r),w("dir",n),w("gitdir",i);const _=a||"HEAD";return await ln({fs:new z(r),cache:d,onProgress:t,onPostCheckout:e,dir:n,gitdir:i,remote:s,ref:_,filepaths:o,noCheckout:f,noUpdateHead:l,dryRun:c,force:h,track:u,nonBlocking:y,batchSize:b})}catch(_){throw _.caller="git.checkout",_}}const ya=new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");function Ut(r){const t=ya.exec(r);return t?t[1]==="remotes/"&&r.endsWith("/HEAD")?t[2].slice(0,-5):t[2]:r}async function Dt({fs:r,gitdir:t,fullname:e=!1,test:n=!1}){const i=await S.resolve({fs:r,gitdir:t,ref:"HEAD",depth:2});if(n)try{await S.resolve({fs:r,gitdir:t,ref:i})}catch{return}if(i.startsWith("refs/"))return e?i:Ut(i)}function ga(r){return r=r.replace(/^git@([^:]+):/,"https://$1/"),r=r.replace(/^ssh:\/\//,"https://"),r}function br({username:r="",password:t=""}){return`Basic ${Buffer.from(`${r}:${t}`).toString("base64")}`}async function Ee(r,t){const e=Yn(r);for(;;){const{value:n,done:i}=await e.next();if(n&&await t(n),i)break}e.return&&e.return()}async function He(r){let t=0;const e=[];await Ee(r,s=>{e.push(s),t+=s.byteLength});const n=new Uint8Array(t);let i=0;for(const s of e)n.set(s,i),i+=s.byteLength;return n}function _r(r){let t=r.match(/^https?:\/\/([^/]+)@/);if(t==null)return{url:r,auth:{}};t=t[1];const[e,n]=t.split(":");return r=r.replace(`${t}@`,""),{url:r,auth:{username:e,password:n}}}function un(r,t){const e=t.toString(16);return"0".repeat(r-e.length)+e}class rt{static flush(){return Buffer.from("0000","utf8")}static delim(){return Buffer.from("0001","utf8")}static encode(t){typeof t=="string"&&(t=Buffer.from(t));const e=t.length+4,n=un(4,e);return Buffer.concat([Buffer.from(n,"utf8"),t])}static streamReader(t){const e=new Zn(t);return async function(){try{let i=await e.read(4);if(i==null)return!0;if(i=parseInt(i.toString("utf8"),16),i===0||i===1)return null;const s=await e.read(i-4);return s??!0}catch(i){return t.error=i,!0}}}}async function kr(r){const t={};let e;for(;e=await r(),e!==!0;){if(e===null)continue;e=e.toString("utf8").replace(/\n$/,"");const n=e.indexOf("=");if(n>-1){const i=e.slice(0,n),s=e.slice(n+1);t[i]=s}else t[e]=!0}return{protocolVersion:2,capabilities2:t}}async function vr(r,{service:t}){const e=new Set,n=new Map,i=new Map,s=rt.streamReader(r);let a=await s();for(;a===null;)a=await s();if(a===!0)throw new de;if(a.includes("version 2"))return kr(s);if(a.toString("utf8").replace(/\n$/,"")!==`# service=${t}`)throw new Ft(`# service=${t}\\n`,a.toString("utf8"));let o=await s();for(;o===null;)o=await s();if(o===!0)return{capabilities:e,refs:n,symrefs:i};if(o=o.toString("utf8"),o.includes("version 2"))return kr(s);const[f,l]=hn(o,"\0","\\x00");if(l.split(" ").map(c=>e.add(c)),f!=="0000000000000000000000000000000000000000 capabilities^{}"){const[c,h]=hn(f," "," ");for(n.set(h,c);;){const u=await s();if(u===!0)break;if(u!==null){const[d,y]=hn(u.toString("utf8")," "," ");n.set(y,d)}}}for(const c of e)if(c.startsWith("symref=")){const h=c.match(/symref=([^:]+):(.*)/);h.length===3&&i.set(h[1],h[2])}return{protocolVersion:1,capabilities:e,refs:n,symrefs:i}}function hn(r,t,e){const n=r.trim().split(t);if(n.length!==2)throw new Ft(`Two strings separated by '${e}'`,r.toString("utf8"));return n}const Sr=(r,t)=>r.endsWith("?")?`${r}${t}`:`${r}/${t.replace(/^https?:\/\//,"")}`,xr=(r,t)=>{(t.username||t.password)&&(r.Authorization=br(t)),t.headers&&Object.assign(r,t.headers)},dn=async r=>{try{const t=Buffer.from(await He(r.body)),e=t.toString("utf8");return{preview:e.length<256?e:e.slice(0,256)+"...",response:e,data:t}}catch{return{}}};class ze{static async capabilities(){return["discover","connect"]}static async discover({http:t,onProgress:e,onAuth:n,onAuthSuccess:i,onAuthFailure:s,corsProxy:a,service:o,url:f,headers:l,protocolVersion:c}){let{url:h,auth:u}=_r(f);const d=a?Sr(a,h):h;(u.username||u.password)&&(l.Authorization=br(u)),c===2&&(l["Git-Protocol"]="version=2");let y,b,_=!1;do if(y=await t.request({onProgress:e,method:"GET",url:`${d}/info/refs?service=${o}`,headers:l}),b=!1,y.statusCode===401||y.statusCode===203){const k=_?s:n;if(k){if(u=await k(h,{...u,headers:{...l}}),u&&u.cancel)throw new Kt;u&&(xr(l,u),_=!0,b=!0)}}else y.statusCode===200&&_&&i&&await i(h,u);while(b);if(y.statusCode!==200){const{response:k}=await dn(y);throw new Yt(y.statusCode,y.statusMessage,k)}if(y.headers["content-type"]===`application/x-${o}-advertisement`){const k=await vr(y.body,{service:o});return k.auth=u,k}else{const{preview:k,response:v,data:C}=await dn(y);try{const F=await vr([C],{service:o});return F.auth=u,F}catch{throw new ge(k,v)}}}static async connect({http:t,onProgress:e,corsProxy:n,service:i,url:s,auth:a,body:o,headers:f}){const l=_r(s);l&&(s=l.url),n&&(s=Sr(n,s)),f["content-type"]=`application/x-${i}-request`,f.accept=`application/x-${i}-result`,xr(f,a);const c=await t.request({onProgress:e,method:"POST",url:`${s}/${i}`,body:o,headers:f});if(c.statusCode!==200){const{response:h}=dn(c);throw new Yt(c.statusCode,c.statusMessage,h)}return c}}class qe{static getRemoteHelperFor({url:t}){const e=new Map;e.set("http",ze),e.set("https",ze);const n=ba({url:t});if(!n)throw new _e(t);if(e.has(n.transport))return e.get(n.transport);throw new be(t,n.transport,n.transport==="ssh"?ga(t):void 0)}}function ba({url:r}){if(r.startsWith("git@"))return{transport:"ssh",address:r};const t=r.match(/(\w+)(:\/\/|::)(.*)/);if(t!==null){if(t[2]==="://")return{transport:t[1],address:t[0]};if(t[2]==="::")return{transport:t[1],address:t[3]}}}let Ht=null;class je{static async read({fs:t,gitdir:e}){Ht===null&&(Ht=new I);const n=m.join(e,"shallow"),i=new Set;return await Ht.acquire(n,async function(){const s=await t.read(n,{encoding:"utf8"});if(s===null||s.trim()==="")return i;s.trim().split(`
`).map(a=>i.add(a))}),i}static async write({fs:t,gitdir:e,oids:n}){Ht===null&&(Ht=new I);const i=m.join(e,"shallow");if(n.size>0){const s=[...n].join(`
`)+`
`;await Ht.acquire(i,async function(){await t.write(i,s,{encoding:"utf8"})})}else await Ht.acquire(i,async function(){await t.rm(i)})}}async function _a({fs:r,gitdir:t,oid:e}){const n=`objects/${e.slice(0,2)}/${e.slice(2)}`;return r.exists(`${t}/${n}`)}async function ka({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:i}){let s=await r.readdir(m.join(e,"objects/pack"));s=s.filter(a=>a.endsWith(".idx"));for(const a of s){const o=`${e}/objects/pack/${a}`,f=await nn({fs:r,cache:t,filename:o,getExternalRefDelta:i});if(f.error)throw new M(f.error);if(f.offsets.has(n))return!0}return!1}async function $r({fs:r,cache:t,gitdir:e,oid:n,format:i="content"}){const s=o=>tt({fs:r,cache:t,gitdir:e,oid:o});let a=await _a({fs:r,gitdir:e,oid:n});return a||(a=await ka({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:s})),a}function va(r){const i="5041434b"+"00000002"+"00000000";return r.slice(0,12).toString("hex")===i}function Er(r,t){const e=r.map(n=>n.split("=",1)[0]);return t.filter(n=>{const i=n.split("=",1)[0];return e.includes(i)})}const Le={name:"isomorphic-git",version:"1.33.1",agent:"git/isomorphic-git@1.33.1"};class We{constructor(){this._queue=[]}write(t){if(this._ended)throw Error("You cannot write to a FIFO that has already been ended!");if(this._waiting){const e=this._waiting;this._waiting=null,e({value:t})}else this._queue.push(t)}end(){if(this._ended=!0,this._waiting){const t=this._waiting;this._waiting=null,t({done:!0})}}destroy(t){this.error=t,this.end()}async next(){if(this._queue.length>0)return{value:this._queue.shift()};if(this._ended)return{done:!0};if(this._waiting)throw Error("You cannot call read until the previous call to read has returned!");return new Promise(t=>{this._waiting=t})}}function Sa(r){const t=r.indexOf("\r"),e=r.indexOf(`
`);return t===-1&&e===-1?-1:t===-1?e+1:e===-1?t+1:e===t+1?e+1:Math.min(t,e)+1}function jr(r){const t=new We;let e="";return(async()=>(await Ee(r,n=>{for(n=n.toString("utf8"),e+=n;;){const i=Sa(e);if(i===-1)break;t.write(e.slice(0,i)),e=e.slice(i)}}),e.length>0&&t.write(e),t.end()))(),t}class Rr{static demux(t){const e=rt.streamReader(t),n=new We,i=new We,s=new We,a=async function(){const o=await e();if(o===null)return a();if(o===!0){n.end(),s.end(),t.error?i.destroy(t.error):i.end();return}switch(o[0]){case 1:{i.write(o.slice(1));break}case 2:{s.write(o.slice(1));break}case 3:{const f=o.slice(1);s.write(f),n.end(),s.end(),i.destroy(new Error(f.toString("utf8")));return}default:n.write(o)}a()};return a(),{packetlines:n,packfile:i,progress:s}}}async function xa(r){const{packetlines:t,packfile:e,progress:n}=Rr.demux(r),i=[],s=[],a=[];let o=!1,f=!1;return new Promise((l,c)=>{Ee(t,h=>{const u=h.toString("utf8").trim();if(u.startsWith("shallow")){const d=u.slice(-41).trim();d.length!==40&&c(new It(d)),i.push(d)}else if(u.startsWith("unshallow")){const d=u.slice(-41).trim();d.length!==40&&c(new It(d)),s.push(d)}else if(u.startsWith("ACK")){const[,d,y]=u.split(" ");a.push({oid:d,status:y}),y||(f=!0)}else u.startsWith("NAK")?(o=!0,f=!0):(f=!0,o=!0);f&&(r.error?c(r.error):l({shallows:i,unshallows:s,acks:a,nak:o,packfile:e,progress:n}))}).finally(()=>{f||(r.error?c(r.error):l({shallows:i,unshallows:s,acks:a,nak:o,packfile:e,progress:n}))})})}function $a({capabilities:r=[],wants:t=[],haves:e=[],shallows:n=[],depth:i=null,since:s=null,exclude:a=[]}){const o=[];t=[...new Set(t)];let f=` ${r.join(" ")}`;for(const l of t)o.push(rt.encode(`want ${l}${f}
`)),f="";for(const l of n)o.push(rt.encode(`shallow ${l}
`));i!==null&&o.push(rt.encode(`deepen ${i}
`)),s!==null&&o.push(rt.encode(`deepen-since ${Math.floor(s.valueOf()/1e3)}
`));for(const l of a)o.push(rt.encode(`deepen-not ${l}
`));o.push(rt.flush());for(const l of e)o.push(rt.encode(`have ${l}
`));return o.push(rt.encode(`done
`)),o}async function wn({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:s,onAuthSuccess:a,onAuthFailure:o,gitdir:f,ref:l,remoteRef:c,remote:h,url:u,corsProxy:d,depth:y=null,since:b=null,exclude:_=[],relative:k=!1,tags:v=!1,singleBranch:C=!1,headers:F={},prune:q=!1,pruneTags:N=!1}){const R=l||await Dt({fs:r,gitdir:f,test:!0}),B=await it.get({fs:r,gitdir:f}),D=h||R&&await B.get(`branch.${R}.remote`)||"origin",W=u||await B.get(`remote.${D}.url`);if(typeof W>"u")throw new pt("remote OR url");const X=c||R&&await B.get(`branch.${R}.merge`)||l||"HEAD";d===void 0&&(d=await B.get("http.corsProxy"));const at=qe.getRemoteHelperFor({url:W}),Y=await at.discover({http:e,onAuth:s,onAuthSuccess:a,onAuthFailure:o,corsProxy:d,service:"git-upload-pack",url:W,headers:F,protocolVersion:1}),ot=Y.auth,lt=Y.refs;if(lt.size===0)return{defaultBranch:null,fetchHead:null,fetchHeadDescription:null};if(y!==null&&!Y.capabilities.has("shallow"))throw new Tt("shallow","depth");if(b!==null&&!Y.capabilities.has("deepen-since"))throw new Tt("deepen-since","since");if(_.length>0&&!Y.capabilities.has("deepen-not"))throw new Tt("deepen-not","exclude");if(k===!0&&!Y.capabilities.has("deepen-relative"))throw new Tt("deepen-relative","relative");const{oid:zt,fullref:qt}=S.resolveAgainstMap({ref:X,map:lt});for(const J of lt.keys())J===qt||J==="HEAD"||J.startsWith("refs/heads/")||v&&J.startsWith("refs/tags/")||lt.delete(J);const oe=Er([...Y.capabilities],["multi_ack_detailed","no-done","side-band-64k","ofs-delta",`agent=${Le.agent}`]);k&&oe.push("deepen-relative");const _n=C?[zt]:lt.values(),kn=C?[R]:await S.listRefs({fs:r,gitdir:f,filepath:"refs"});let _t=[];for(let J of kn)try{J=await S.expand({fs:r,gitdir:f,ref:J});const ft=await S.resolve({fs:r,gitdir:f,ref:J});await $r({fs:r,cache:t,gitdir:f,oid:ft})&&_t.push(ft)}catch{}_t=[...new Set(_t)];const nt=await je.read({fs:r,gitdir:f}),xt=Y.capabilities.has("shallow")?[...nt]:[],ht=$a({capabilities:oe,wants:_n,haves:_t,shallows:xt,depth:y,since:b,exclude:_}),Re=Buffer.from(await He(ht)),Lt=await at.connect({http:e,onProgress:n,corsProxy:d,service:"git-upload-pack",url:W,auth:ot,body:[Re],headers:F}),ct=await xa(Lt.body);Lt.headers&&(ct.headers=Lt.headers);for(const J of ct.shallows)if(!nt.has(J))try{const{object:ft}=await tt({fs:r,cache:t,gitdir:f,oid:J}),kt=new et(ft),$t=await Promise.all(kt.headers().parent.map(Ie=>$r({fs:r,cache:t,gitdir:f,oid:Ie})));$t.length===0||$t.every(Ie=>Ie)||nt.add(J)}catch{nt.add(J)}for(const J of ct.unshallows)nt.delete(J);if(await je.write({fs:r,gitdir:f,oids:nt}),C){const J=new Map([[qt,zt]]),ft=new Map;let kt=10,$t=qt;for(;kt--;){const Sn=Y.symrefs.get($t);if(Sn===void 0)break;ft.set($t,Sn),$t=Sn}const vn=lt.get($t);vn&&J.set($t,vn);const{pruned:Ie}=await S.updateRemoteRefs({fs:r,gitdir:f,remote:D,refs:J,symrefs:ft,tags:v,prune:q});q&&(ct.pruned=Ie)}else{const{pruned:J}=await S.updateRemoteRefs({fs:r,gitdir:f,remote:D,refs:lt,symrefs:Y.symrefs,tags:v,prune:q,pruneTags:N});q&&(ct.pruned=J)}if(ct.HEAD=Y.symrefs.get("HEAD"),ct.HEAD===void 0){const{oid:J}=S.resolveAgainstMap({ref:"HEAD",map:lt});for(const[ft,kt]of lt.entries())if(ft!=="HEAD"&&kt===J){ct.HEAD=ft;break}}const mo=qt.startsWith("refs/tags")?"tag":"branch";if(ct.FETCH_HEAD={oid:zt,description:`${mo} '${Ut(qt)}' of ${W}`},n||i){const J=jr(ct.progress);Ee(J,async ft=>{if(i&&await i(ft),n){const kt=ft.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);kt&&await n({phase:kt[1].trim(),loaded:parseInt(kt[2],10),total:parseInt(kt[3],10)})}})}const Ve=Buffer.from(await He(ct.packfile));if(Lt.body.error)throw Lt.body.error;const Qi=Ve.slice(-20).toString("hex"),Oe={defaultBranch:ct.HEAD,fetchHead:ct.FETCH_HEAD.oid,fetchHeadDescription:ct.FETCH_HEAD.description};if(ct.headers&&(Oe.headers=ct.headers),q&&(Oe.pruned=ct.pruned),Qi!==""&&!va(Ve)){Oe.packfile=`objects/pack/pack-${Qi}.pack`;const J=m.join(f,Oe.packfile);await r.write(J,Ve);const ft=$t=>tt({fs:r,cache:t,gitdir:f,oid:$t}),kt=await Xt.fromPack({pack:Ve,getExternalRefDelta:ft,onProgress:n});await r.write(J.replace(/\.pack$/,".idx"),await kt.toBuffer())}return Oe}async function Or({fs:r,bare:t=!1,dir:e,gitdir:n=t?e:m.join(e,".git"),defaultBranch:i="master"}){if(await r.exists(n+"/config"))return;let s=["hooks","info","objects/info","objects/pack","refs/heads","refs/tags"];s=s.map(a=>n+"/"+a);for(const a of s)await r.mkdir(a);await r.write(n+"/config",`[core]
	repositoryformatversion = 0
	filemode = false
	bare = ${t}
`+(t?"":`	logallrefupdates = true
`)+`	symlinks = false
	ignorecase = true
`),await r.write(n+"/HEAD",`ref: refs/heads/${i}
`)}async function Ea({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:s,onAuthSuccess:a,onAuthFailure:o,onPostCheckout:f,dir:l,gitdir:c,url:h,corsProxy:u,ref:d,remote:y,depth:b,since:_,exclude:k,relative:v,singleBranch:C,noCheckout:F,noTags:q,headers:N,nonBlocking:R,batchSize:B=100}){try{if(await Or({fs:r,gitdir:c}),await dr({fs:r,gitdir:c,remote:y,url:h,force:!1}),u){const X=await it.get({fs:r,gitdir:c});await X.set("http.corsProxy",u),await it.save({fs:r,gitdir:c,config:X})}const{defaultBranch:D,fetchHead:W}=await wn({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:s,onAuthSuccess:a,onAuthFailure:o,gitdir:c,ref:d,remote:y,corsProxy:u,depth:b,since:_,exclude:k,relative:v,singleBranch:C,headers:N,tags:!q});if(W===null)return;d=d||D,d=d.replace("refs/heads/",""),await ln({fs:r,cache:t,onProgress:n,onPostCheckout:f,dir:l,gitdir:c,ref:d,remote:y,noCheckout:F,nonBlocking:R,batchSize:B})}catch(D){throw await r.rmdir(c,{recursive:!0,maxRetries:10}).catch(()=>{}),D}}async function Ir({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:s,onAuthFailure:a,onPostCheckout:o,dir:f,gitdir:l=m.join(f,".git"),url:c,corsProxy:h=void 0,ref:u=void 0,remote:d="origin",depth:y=void 0,since:b=void 0,exclude:_=[],relative:k=!1,singleBranch:v=!1,noCheckout:C=!1,noTags:F=!1,headers:q={},cache:N={},nonBlocking:R=!1,batchSize:B=100}){try{return w("fs",r),w("http",t),w("gitdir",l),C||w("dir",f),w("url",c),await Ea({fs:new z(r),cache:N,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:s,onAuthFailure:a,onPostCheckout:o,dir:f,gitdir:l,url:c,corsProxy:h,ref:u,remote:d,depth:y,since:b,exclude:_,relative:k,singleBranch:v,noCheckout:C,noTags:F,headers:q,nonBlocking:R,batchSize:B})}catch(D){throw D.caller="git.clone",D}}async function Br({fs:r,onSign:t,dir:e,gitdir:n=m.join(e,".git"),message:i,author:s,committer:a,signingKey:o,amend:f=!1,dryRun:l=!1,noUpdateBranch:c=!1,ref:h,parent:u,tree:d,cache:y={}}){try{w("fs",r),f||w("message",i),o&&w("onSign",t);const b=new z(r);return await Ue({fs:b,cache:y,onSign:t,gitdir:n,message:i,author:s,committer:a,signingKey:o,amend:f,dryRun:l,noUpdateBranch:c,ref:h,parent:u,tree:d})}catch(b){throw b.caller="git.commit",b}}async function Pr({fs:r,dir:t,gitdir:e=m.join(t,".git"),fullname:n=!1,test:i=!1}){try{return w("fs",r),w("gitdir",e),await Dt({fs:new z(r),gitdir:e,fullname:n,test:i})}catch(s){throw s.caller="git.currentBranch",s}}async function ja({fs:r,gitdir:t,ref:e}){if(e=e.startsWith("refs/heads/")?e:`refs/heads/${e}`,!await S.exists({fs:r,gitdir:t,ref:e}))throw new Q(e);const i=await S.expand({fs:r,gitdir:t,ref:e}),s=await Dt({fs:r,gitdir:t,fullname:!0});if(i===s){const f=await S.resolve({fs:r,gitdir:t,ref:i});await S.writeRef({fs:r,gitdir:t,ref:"HEAD",value:f})}await S.deleteRef({fs:r,gitdir:t,ref:i});const a=Ut(e),o=await it.get({fs:r,gitdir:t});await o.deleteSection("branch",a),await it.save({fs:r,gitdir:t,config:o})}async function Tr({fs:r,dir:t,gitdir:e=m.join(t,".git"),ref:n}){try{return w("fs",r),w("ref",n),await ja({fs:new z(r),gitdir:e,ref:n})}catch(i){throw i.caller="git.deleteBranch",i}}async function Cr({fs:r,dir:t,gitdir:e=m.join(t,".git"),ref:n}){try{w("fs",r),w("ref",n),await S.deleteRef({fs:new z(r),gitdir:e,ref:n})}catch(i){throw i.caller="git.deleteRef",i}}async function Ra({fs:r,gitdir:t,remote:e}){const n=await it.get({fs:r,gitdir:t});await n.deleteSection("remote",e),await it.save({fs:r,gitdir:t,config:n})}async function Ar({fs:r,dir:t,gitdir:e=m.join(t,".git"),remote:n}){try{return w("fs",r),w("remote",n),await Ra({fs:new z(r),gitdir:e,remote:n})}catch(i){throw i.caller="git.deleteRemote",i}}async function Oa({fs:r,gitdir:t,ref:e}){e=e.startsWith("refs/tags/")?e:`refs/tags/${e}`,await S.deleteRef({fs:r,gitdir:t,ref:e})}async function Dr({fs:r,dir:t,gitdir:e=m.join(t,".git"),ref:n}){try{return w("fs",r),w("ref",n),await Oa({fs:new z(r),gitdir:e,ref:n})}catch(i){throw i.caller="git.deleteTag",i}}async function Ia({fs:r,gitdir:t,oid:e}){const n=e.slice(0,2);return(await r.readdir(`${t}/objects/${n}`)).map(s=>`${n}${s}`).filter(s=>s.startsWith(e))}async function Ba({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:i}){const s=[];let a=await r.readdir(m.join(e,"objects/pack"));a=a.filter(o=>o.endsWith(".idx"));for(const o of a){const f=`${e}/objects/pack/${o}`,l=await nn({fs:r,cache:t,filename:f,getExternalRefDelta:i});if(l.error)throw new M(l.error);for(const c of l.offsets.keys())c.startsWith(n)&&s.push(c)}return s}async function Pa({fs:r,cache:t,gitdir:e,oid:n}){const i=o=>tt({fs:r,cache:t,gitdir:e,oid:o}),s=await Ia({fs:r,gitdir:e,oid:n}),a=await Ba({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:i});for(const o of a)s.indexOf(o)===-1&&s.push(o);if(s.length===1)return s[0];throw s.length>1?new fe("oids",n,s):new Q(`an object matching "${n}"`)}async function Nr({fs:r,dir:t,gitdir:e=m.join(t,".git"),oid:n,cache:i={}}){try{return w("fs",r),w("gitdir",e),w("oid",n),await Pa({fs:new z(r),cache:i,gitdir:e,oid:n})}catch(s){throw s.caller="git.expandOid",s}}async function Mr({fs:r,dir:t,gitdir:e=m.join(t,".git"),ref:n}){try{return w("fs",r),w("gitdir",e),w("ref",n),await S.expand({fs:new z(r),gitdir:e,ref:n})}catch(i){throw i.caller="git.expandRef",i}}async function mn({fs:r,cache:t,gitdir:e,oids:n}){const i={},s=n.length;let a=n.map((o,f)=>({index:f,oid:o}));for(;a.length;){const o=new Set;for(const{oid:l,index:c}of a)i[l]||(i[l]=new Set),i[l].add(c),i[l].size===s&&o.add(l);if(o.size>0)return[...o];const f=new Map;for(const{oid:l,index:c}of a)try{const{object:h}=await tt({fs:r,cache:t,gitdir:e,oid:l}),u=et.from(h),{parent:d}=u.parseHeaders();for(const y of d)(!i[y]||!i[y].has(c))&&f.set(y+":"+c,{oid:y,index:c})}catch{}a=Array.from(f.values())}return[]}const pn=/^.*(\r?\n|$)/gm;function Ta({branches:r,contents:t}){const e=r[1],n=r[2],i=t[0],s=t[1],a=t[2],o=s.match(pn),f=i.match(pn),l=a.match(pn),c=U(o,f,l),h=7;let u="",d=!0;for(const y of c)y.ok&&(u+=y.ok.join("")),y.conflict&&(d=!1,u+=`${"<".repeat(h)} ${e}
`,u+=y.conflict.a.join(""),u+=`${"=".repeat(h)}
`,u+=y.conflict.b.join(""),u+=`${">".repeat(h)} ${n}
`);return{cleanMerge:d,mergedText:u}}async function Ca({fs:r,cache:t,dir:e,gitdir:n=m.join(e,".git"),index:i,ourOid:s,baseOid:a,theirOid:o,ourName:f="ours",baseName:l="base",theirName:c="theirs",dryRun:h=!1,abortOnConflict:u=!0,mergeDriver:d}){const y=bt({ref:s}),b=bt({ref:a}),_=bt({ref:o}),k=[],v=[],C=[],F=[],q=await Ct({fs:r,cache:t,dir:e,gitdir:n,trees:[y,b,_],map:async function(N,[R,B,D]){const W=Pe(N),X=await Fe(R,B),at=await Fe(D,B);switch(`${X}-${at}`){case"false-false":return{mode:await B.mode(),path:W,oid:await B.oid(),type:await B.type()};case"false-true":return!D&&await R.type()==="tree"?{mode:await R.mode(),path:W,oid:await R.oid(),type:await R.type()}:D?{mode:await D.mode(),path:W,oid:await D.oid(),type:await D.type()}:void 0;case"true-false":return!R&&await D.type()==="tree"?{mode:await D.mode(),path:W,oid:await D.oid(),type:await D.type()}:R?{mode:await R.mode(),path:W,oid:await R.oid(),type:await R.type()}:void 0;case"true-true":{if(R&&D&&await R.type()==="tree"&&await D.type()==="tree")return{mode:await R.mode(),path:W,oid:await R.oid(),type:"tree"};if(R&&D&&await R.type()==="blob"&&await D.type()==="blob")return Aa({fs:r,gitdir:n,path:W,ours:R,base:B,theirs:D,ourName:f,baseName:l,theirName:c,mergeDriver:d}).then(async Y=>{if(Y.cleanMerge)u||i.insert({filepath:N,oid:Y.mergeResult.oid,stage:0});else if(k.push(N),v.push(N),!u){let ot="";B&&await B.type()==="blob"&&(ot=await B.oid());const lt=await R.oid(),zt=await D.oid();i.delete({filepath:N}),ot&&i.insert({filepath:N,oid:ot,stage:1}),i.insert({filepath:N,oid:lt,stage:2}),i.insert({filepath:N,oid:zt,stage:3})}return Y.mergeResult});if(B&&!R&&D&&await B.type()==="blob"&&await D.type()==="blob"){if(k.push(N),C.push(N),!u){const Y=await B.oid(),ot=await D.oid();i.delete({filepath:N}),i.insert({filepath:N,oid:Y,stage:1}),i.insert({filepath:N,oid:ot,stage:3})}return{mode:await D.mode(),oid:await D.oid(),type:"blob",path:W}}if(B&&R&&!D&&await B.type()==="blob"&&await R.type()==="blob"){if(k.push(N),F.push(N),!u){const Y=await B.oid(),ot=await R.oid();i.delete({filepath:N}),i.insert({filepath:N,oid:Y,stage:1}),i.insert({filepath:N,oid:ot,stage:2})}return{mode:await R.mode(),oid:await R.oid(),type:"blob",path:W}}if(B&&!R&&!D&&(await B.type()==="blob"||await B.type()==="tree"))return;throw new Zt}}},reduce:k.length!==0&&(!e||u)?void 0:async(N,R)=>{const B=R.filter(Boolean);if(N&&!(N&&N.type==="tree"&&B.length===0&&N.path!==".")){if(B.length>0||N.path==="."&&B.length===0){const W=new mt(B).toObject(),X=await yt({fs:r,gitdir:n,type:"tree",object:W,dryRun:h});N.oid=X}return N}}});return k.length!==0?(e&&!u&&await Ct({fs:r,cache:t,dir:e,gitdir:n,trees:[bt({ref:q.oid})],map:async function(N,[R]){const B=`${e}/${N}`;if(await R.type()==="blob"){const D=await R.mode(),W=new TextDecoder().decode(await R.content());await r.write(B,W,{mode:D})}return!0}}),new Qt(k,v,C,F)):q.oid}async function Aa({fs:r,gitdir:t,path:e,ours:n,base:i,theirs:s,ourName:a,theirName:o,baseName:f,dryRun:l,mergeDriver:c=Ta}){const h="blob";let u="100755",d="",y="";i&&await i.type()==="blob"&&(u=await i.mode(),d=await i.oid(),y=Buffer.from(await i.content()).toString("utf8"));const b=u===await n.mode()?await s.mode():await n.mode();if(await n.oid()===await s.oid())return{cleanMerge:!0,mergeResult:{mode:b,path:e,oid:await n.oid(),type:h}};if(await n.oid()===d)return{cleanMerge:!0,mergeResult:{mode:b,path:e,oid:await s.oid(),type:h}};if(await s.oid()===d)return{cleanMerge:!0,mergeResult:{mode:b,path:e,oid:await n.oid(),type:h}};const _=Buffer.from(await n.content()).toString("utf8"),k=Buffer.from(await s.content()).toString("utf8"),{mergedText:v,cleanMerge:C}=await c({branches:[f,a,o],contents:[y,_,k],path:e}),F=await yt({fs:r,gitdir:t,type:"blob",object:Buffer.from(v,"utf8"),dryRun:l});return{cleanMerge:C,mergeResult:{mode:b,path:e,oid:F,type:h}}}async function Fr({fs:r,cache:t,dir:e,gitdir:n,ours:i,theirs:s,fastForward:a=!0,fastForwardOnly:o=!1,dryRun:f=!1,noUpdateBranch:l=!1,abortOnConflict:c=!0,message:h,author:u,committer:d,signingKey:y,onSign:b,mergeDriver:_,allowUnrelatedHistories:k=!1}){i===void 0&&(i=await Dt({fs:r,gitdir:n,fullname:!0})),i=await S.expand({fs:r,gitdir:n,ref:i}),s=await S.expand({fs:r,gitdir:n,ref:s});const v=await S.resolve({fs:r,gitdir:n,ref:i}),C=await S.resolve({fs:r,gitdir:n,ref:s}),F=await mn({fs:r,cache:t,gitdir:n,oids:[v,C]});if(F.length!==1)if(F.length===0&&k)F.push("4b825dc642cb6eb9a060e54bf8d69288fbee4904");else throw new Zt;const q=F[0];if(q===C)return{oid:v,alreadyMerged:!0};if(a&&q===v)return!f&&!l&&await S.writeRef({fs:r,gitdir:n,ref:i,value:C}),{oid:C,fastForward:!0};{if(o)throw new we;const N=await st.acquire({fs:r,gitdir:n,cache:t,allowUnmerged:!1},async B=>Ca({fs:r,cache:t,dir:e,gitdir:n,index:B,ourOid:v,theirOid:C,baseOid:q,ourName:Ut(i),baseName:"base",theirName:Ut(s),dryRun:f,abortOnConflict:c,mergeDriver:_}));if(N instanceof Qt)throw N;return h||(h=`Merge branch '${Ut(s)}' into ${Ut(i)}`),{oid:await Ue({fs:r,cache:t,gitdir:n,message:h,ref:i,tree:N,parent:[v,C],author:u,committer:d,signingKey:y,onSign:b,dryRun:f,noUpdateBranch:l}),tree:N,mergeCommit:!0}}}async function Ur({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:s,onAuthSuccess:a,onAuthFailure:o,dir:f,gitdir:l,ref:c,url:h,remote:u,remoteRef:d,prune:y,pruneTags:b,fastForward:_,fastForwardOnly:k,corsProxy:v,singleBranch:C,headers:F,author:q,committer:N,signingKey:R}){try{if(!c){const W=await Dt({fs:r,gitdir:l});if(!W)throw new pt("ref");c=W}const{fetchHead:B,fetchHeadDescription:D}=await wn({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:s,onAuthSuccess:a,onAuthFailure:o,gitdir:l,corsProxy:v,ref:c,url:h,remote:u,remoteRef:d,singleBranch:C,headers:F,prune:y,pruneTags:b});await Fr({fs:r,cache:t,gitdir:l,ours:c,theirs:B,fastForward:_,fastForwardOnly:k,message:`Merge ${D}`,author:q,committer:N,signingKey:R,dryRun:!1,noUpdateBranch:!1}),await ln({fs:r,cache:t,onProgress:n,dir:f,gitdir:l,ref:c,remote:u,noCheckout:!1})}catch(B){throw B.caller="git.pull",B}}async function Hr({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:f=m.join(o,".git"),ref:l,url:c,remote:h,remoteRef:u,corsProxy:d,singleBranch:y,headers:b={},cache:_={}}){try{w("fs",r),w("http",t),w("gitdir",f);const k={name:"",email:"",timestamp:Date.now(),timezoneOffset:0};return await Ur({fs:new z(r),cache:_,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:f,ref:l,url:c,remote:h,remoteRef:u,fastForwardOnly:!0,corsProxy:d,singleBranch:y,headers:b,author:k,committer:k})}catch(k){throw k.caller="git.fastForward",k}}async function zr({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:f=m.join(o,".git"),ref:l,remote:c,remoteRef:h,url:u,corsProxy:d,depth:y=null,since:b=null,exclude:_=[],relative:k=!1,tags:v=!1,singleBranch:C=!1,headers:F={},prune:q=!1,pruneTags:N=!1,cache:R={}}){try{return w("fs",r),w("http",t),w("gitdir",f),await wn({fs:new z(r),cache:R,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:s,onAuthFailure:a,gitdir:f,ref:l,remote:c,remoteRef:h,url:u,corsProxy:d,depth:y,since:b,exclude:_,relative:k,tags:v,singleBranch:C,headers:F,prune:q,pruneTags:N})}catch(B){throw B.caller="git.fetch",B}}async function qr({fs:r,dir:t,gitdir:e=m.join(t,".git"),oids:n,cache:i={}}){try{return w("fs",r),w("gitdir",e),w("oids",n),await mn({fs:new z(r),cache:i,gitdir:e,oids:n})}catch(s){throw s.caller="git.findMergeBase",s}}async function Lr({fs:r,filepath:t}){if(await r.exists(m.join(t,".git")))return t;{const e=Gt(t);if(e===t)throw new Q(`git root for ${t}`);return Lr({fs:r,filepath:e})}}async function Wr({fs:r,filepath:t}){try{return w("fs",r),w("filepath",t),await Lr({fs:new z(r),filepath:t})}catch(e){throw e.caller="git.findRoot",e}}async function Gr({fs:r,dir:t,gitdir:e=m.join(t,".git"),path:n}){try{return w("fs",r),w("gitdir",e),w("path",n),await Se({fs:new z(r),gitdir:e,path:n})}catch(i){throw i.caller="git.getConfig",i}}async function Da({fs:r,gitdir:t,path:e}){return(await it.get({fs:r,gitdir:t})).getall(e)}async function Vr({fs:r,dir:t,gitdir:e=m.join(t,".git"),path:n}){try{return w("fs",r),w("gitdir",e),w("path",n),await Da({fs:new z(r),gitdir:e,path:n})}catch(i){throw i.caller="git.getConfigAll",i}}async function Xr({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,url:s,headers:a={},forPush:o=!1}){try{w("http",r),w("url",s);const l=await qe.getRemoteHelperFor({url:s}).discover({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,service:o?"git-receive-pack":"git-upload-pack",url:s,headers:a,protocolVersion:1}),c={capabilities:[...l.capabilities]};for(const[h,u]of l.refs){const d=h.split("/"),y=d.pop();let b=c;for(const _ of d)b[_]=b[_]||{},b=b[_];b[y]=u}for(const[h,u]of l.symrefs){const d=h.split("/"),y=d.pop();let b=c;for(const _ of d)b[_]=b[_]||{},b=b[_];b[y]=u}return c}catch(f){throw f.caller="git.getRemoteInfo",f}}function Yr(r,t,e,n){const i=[];for(const[s,a]of r.refs){if(t&&!s.startsWith(t))continue;if(s.endsWith("^{}")){if(n){const f=s.replace("^{}",""),l=i[i.length-1],c=l.ref===f?l:i.find(h=>h.ref===f);if(c===void 0)throw new Error("I did not expect this to happen");c.peeled=a}continue}const o={ref:s,oid:a};e&&r.symrefs.has(s)&&(o.target=r.symrefs.get(s)),i.push(o)}return i}async function Zr({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,url:s,headers:a={},forPush:o=!1,protocolVersion:f=2}){try{w("http",r),w("url",s);const c=await qe.getRemoteHelperFor({url:s}).discover({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,service:o?"git-receive-pack":"git-upload-pack",url:s,headers:a,protocolVersion:f});if(c.protocolVersion===2)return{protocolVersion:c.protocolVersion,capabilities:c.capabilities2};const h={};for(const u of c.capabilities){const[d,y]=u.split("=");y?h[d]=y:h[d]=!0}return{protocolVersion:1,capabilities:h,refs:Yr(c,void 0,!0,!0)}}catch(l){throw l.caller="git.getRemoteInfo2",l}}async function Na({type:r,object:t,format:e="content",oid:n=void 0}){return e!=="deflated"&&(e!=="wrapped"&&(t=Vt.wrap({type:r,object:t})),n=await jt(t)),{oid:n,object:t}}async function Qr({object:r}){try{w("object",r),typeof r=="string"?r=Buffer.from(r,"utf8"):r instanceof Uint8Array||(r=new Uint8Array(r));const t="blob",{oid:e,object:n}=await Na({type:t,format:"content",object:r});return{oid:e,type:t,object:n,format:"wrapped"}}catch(t){throw t.caller="git.hashBlob",t}}async function Ma({fs:r,cache:t,onProgress:e,dir:n,gitdir:i,filepath:s}){try{s=m.join(n,s);const a=await r.read(s),o=l=>tt({fs:r,cache:t,gitdir:i,oid:l}),f=await Xt.fromPack({pack:a,getExternalRefDelta:o,onProgress:e});return await r.write(s.replace(/\.pack$/,".idx"),await f.toBuffer()),{oids:[...f.hashes]}}catch(a){throw a.caller="git.indexPack",a}}async function Jr({fs:r,onProgress:t,dir:e,gitdir:n=m.join(e,".git"),filepath:i,cache:s={}}){try{return w("fs",r),w("dir",e),w("gitdir",e),w("filepath",i),await Ma({fs:new z(r),cache:s,onProgress:t,dir:e,gitdir:n,filepath:i})}catch(a){throw a.caller="git.indexPack",a}}async function Kr({fs:r,bare:t=!1,dir:e,gitdir:n=t?e:m.join(e,".git"),defaultBranch:i="master"}){try{return w("fs",r),w("gitdir",n),t||w("dir",e),await Or({fs:new z(r),bare:t,dir:e,gitdir:n,defaultBranch:i})}catch(s){throw s.caller="git.init",s}}async function ti({fs:r,cache:t,gitdir:e,oid:n,ancestor:i,depth:s}){const a=await je.read({fs:r,gitdir:e});if(!n)throw new pt("oid");if(!i)throw new pt("ancestor");if(n===i)return!1;const o=[n],f=new Set;let l=0;for(;o.length;){if(l++===s)throw new pe(s);const c=o.shift(),{type:h,object:u}=await tt({fs:r,cache:t,gitdir:e,oid:c});if(h!=="commit")throw new dt(c,h,"commit");const d=et.from(u).parse();for(const y of d.parent)if(y===i)return!0;if(!a.has(c))for(const y of d.parent)f.has(y)||(o.push(y),f.add(y))}return!1}async function ei({fs:r,dir:t,gitdir:e=m.join(t,".git"),oid:n,ancestor:i,depth:s=-1,cache:a={}}){try{return w("fs",r),w("gitdir",e),w("oid",n),w("ancestor",i),await ti({fs:new z(r),cache:a,gitdir:e,oid:n,ancestor:i,depth:s})}catch(o){throw o.caller="git.isDescendent",o}}async function ni({fs:r,dir:t,gitdir:e=m.join(t,".git"),filepath:n}){try{return w("fs",r),w("dir",t),w("gitdir",e),w("filepath",n),ne.isIgnored({fs:new z(r),dir:t,gitdir:e,filepath:n})}catch(i){throw i.caller="git.isIgnored",i}}async function ri({fs:r,dir:t,gitdir:e=m.join(t,".git"),remote:n}){try{return w("fs",r),w("gitdir",e),S.listBranches({fs:new z(r),gitdir:e,remote:n})}catch(i){throw i.caller="git.listBranches",i}}async function Fa({fs:r,gitdir:t,ref:e,cache:n}){if(e){const i=await S.resolve({gitdir:t,fs:r,ref:e}),s=[];return await ii({fs:r,cache:n,gitdir:t,oid:i,filenames:s,prefix:""}),s}else return st.acquire({fs:r,gitdir:t,cache:n},async function(i){return i.entries.map(s=>s.path)})}async function ii({fs:r,cache:t,gitdir:e,oid:n,filenames:i,prefix:s}){const{tree:a}=await se({fs:r,cache:t,gitdir:e,oid:n});for(const o of a)o.type==="tree"?await ii({fs:r,cache:t,gitdir:e,oid:o.oid,filenames:i,prefix:m.join(s,o.path)}):i.push(m.join(s,o.path))}async function si({fs:r,dir:t,gitdir:e=m.join(t,".git"),ref:n,cache:i={}}){try{return w("fs",r),w("gitdir",e),await Fa({fs:new z(r),cache:i,gitdir:e,ref:n})}catch(s){throw s.caller="git.listFiles",s}}async function Ua({fs:r,cache:t,gitdir:e,ref:n}){let i;try{i=await S.resolve({gitdir:e,fs:r,ref:n})}catch(o){if(o instanceof Q)return[]}return(await se({fs:r,cache:t,gitdir:e,oid:i})).tree.map(o=>({target:o.path,note:o.oid}))}async function ai({fs:r,dir:t,gitdir:e=m.join(t,".git"),ref:n="refs/notes/commits",cache:i={}}){try{return w("fs",r),w("gitdir",e),w("ref",n),await Ua({fs:new z(r),cache:i,gitdir:e,ref:n})}catch(s){throw s.caller="git.listNotes",s}}async function oi({fs:r,dir:t,gitdir:e=m.join(t,".git"),filepath:n}){try{return w("fs",r),w("gitdir",e),S.listRefs({fs:new z(r),gitdir:e,filepath:n})}catch(i){throw i.caller="git.listRefs",i}}async function Ha({fs:r,gitdir:t}){const e=await it.get({fs:r,gitdir:t}),n=await e.getSubsections("remote");return Promise.all(n.map(async s=>{const a=await e.get(`remote.${s}.url`);return{remote:s,url:a}}))}async function ci({fs:r,dir:t,gitdir:e=m.join(t,".git")}){try{return w("fs",r),w("gitdir",e),await Ha({fs:new z(r),gitdir:e})}catch(n){throw n.caller="git.listRemotes",n}}async function za(r){const t=rt.streamReader(r),e=[];let n;for(;n=await t(),n!==!0;){if(n===null)continue;n=n.toString("utf8").replace(/\n$/,"");const[i,s,...a]=n.split(" "),o={ref:s,oid:i};for(const f of a){const[l,c]=f.split(":");l==="symref-target"?o.target=c:l==="peeled"&&(o.peeled=c)}e.push(o)}return e}async function qa({prefix:r,symrefs:t,peelTags:e}){const n=[];return n.push(rt.encode(`command=ls-refs
`)),n.push(rt.encode(`agent=${Le.agent}
`)),(e||t||r)&&n.push(rt.delim()),e&&n.push(rt.encode("peel")),t&&n.push(rt.encode("symrefs")),r&&n.push(rt.encode(`ref-prefix ${r}`)),n.push(rt.flush()),n}async function li({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,url:s,headers:a={},forPush:o=!1,protocolVersion:f=2,prefix:l,symrefs:c,peelTags:h}){try{w("http",r),w("url",s);const u=await ze.discover({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,service:o?"git-receive-pack":"git-upload-pack",url:s,headers:a,protocolVersion:f});if(u.protocolVersion===1)return Yr(u,l,c,h);const d=await qa({prefix:l,symrefs:c,peelTags:h}),y=await ze.connect({http:r,auth:u.auth,headers:a,corsProxy:i,service:o?"git-receive-pack":"git-upload-pack",url:s,body:d});return za(y.body)}catch(u){throw u.caller="git.listServerRefs",u}}async function fi({fs:r,dir:t,gitdir:e=m.join(t,".git")}){try{return w("fs",r),w("gitdir",e),S.listTags({fs:new z(r),gitdir:e})}catch(n){throw n.caller="git.listTags",n}}function La(r,t){return r.committer.timestamp-t.committer.timestamp}const Wa="e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";async function ui({fs:r,cache:t,gitdir:e,oid:n,fileId:i}){if(i===Wa)return;const s=n;let a;const o=await te({fs:r,cache:t,gitdir:e,oid:n}),f=o.tree;return i===o.oid?a=o.path:(a=await hi({fs:r,cache:t,gitdir:e,tree:f,fileId:i,oid:s}),Array.isArray(a)&&(a.length===0?a=void 0:a.length===1&&(a=a[0]))),a}async function hi({fs:r,cache:t,gitdir:e,tree:n,fileId:i,oid:s,filepaths:a=[],parentPath:o=""}){const f=n.entries().map(function(l){let c;return l.oid===i?(c=m.join(o,l.path),a.push(c)):l.type==="tree"&&(c=tt({fs:r,cache:t,gitdir:e,oid:l.oid}).then(function({object:h}){return hi({fs:r,cache:t,gitdir:e,tree:mt.from(h),fileId:i,oid:s,filepaths:a,parentPath:m.join(o,l.path)})})),c});return await Promise.all(f),a}async function Ga({fs:r,cache:t,gitdir:e,filepath:n,ref:i,depth:s,since:a,force:o,follow:f}){const l=typeof a>"u"?void 0:Math.floor(a.valueOf()/1e3),c=[],h=await je.read({fs:r,gitdir:e}),u=await S.resolve({fs:r,gitdir:e,ref:i}),d=[await ie({fs:r,cache:t,gitdir:e,oid:u})];let y,b,_;function k(v){_&&n&&c.push(v)}for(;d.length>0;){const v=d.pop();if(l!==void 0&&v.commit.committer.timestamp<=l)break;if(n){let C;try{C=await xe({fs:r,cache:t,gitdir:e,oid:v.commit.tree,filepath:n}),b&&y!==C&&c.push(b),y=C,b=v,_=!0}catch(F){if(F instanceof Q){let q=f&&y;if(q&&(q=await ui({fs:r,cache:t,gitdir:e,oid:v.commit.tree,fileId:y}),q))if(Array.isArray(q)){if(b){const N=await ui({fs:r,cache:t,gitdir:e,oid:b.commit.tree,fileId:y});if(Array.isArray(N))if(q=q.filter(R=>N.indexOf(R)===-1),q.length===1)q=q[0],n=q,b&&c.push(b);else{q=!1,b&&c.push(b);break}}}else n=q,b&&c.push(b);if(!q){if(_&&y&&(c.push(b),!o))break;if(!o&&!f)throw F}b=v,_=!1}else throw F}}else c.push(v);if(s!==void 0&&c.length===s){k(v);break}if(!h.has(v.oid))for(const C of v.commit.parent){const F=await ie({fs:r,cache:t,gitdir:e,oid:C});d.map(q=>q.oid).includes(F.oid)||d.push(F)}d.length===0&&k(v),d.sort((C,F)=>La(C.commit,F.commit))}return c}async function di({fs:r,dir:t,gitdir:e=m.join(t,".git"),filepath:n,ref:i="HEAD",depth:s,since:a,force:o,follow:f,cache:l={}}){try{return w("fs",r),w("gitdir",e),w("ref",i),await Ga({fs:new z(r),cache:l,gitdir:e,filepath:n,ref:i,depth:s,since:a,force:o,follow:f})}catch(c){throw c.caller="git.log",c}}async function wi({fs:r,onSign:t,dir:e,gitdir:n=m.join(e,".git"),ours:i,theirs:s,fastForward:a=!0,fastForwardOnly:o=!1,dryRun:f=!1,noUpdateBranch:l=!1,abortOnConflict:c=!0,message:h,author:u,committer:d,signingKey:y,cache:b={},mergeDriver:_,allowUnrelatedHistories:k=!1}){try{w("fs",r),y&&w("onSign",t);const v=new z(r),C=await At({fs:v,gitdir:n,author:u});if(!C&&(!o||!a))throw new ut("author");const F=await re({fs:v,gitdir:n,author:C,committer:d});if(!F&&(!o||!a))throw new ut("committer");return await Fr({fs:v,cache:b,dir:e,gitdir:n,ours:i,theirs:s,fastForward:a,fastForwardOnly:o,dryRun:f,noUpdateBranch:l,abortOnConflict:c,message:h,author:C,committer:F,signingKey:y,onSign:t,mergeDriver:_,allowUnrelatedHistories:k})}catch(v){throw v.caller="git.merge",v}}const Va={commit:16,tree:32,blob:48,tag:64,ofs_delta:96,ref_delta:112};async function mi({fs:r,cache:t,dir:e,gitdir:n=m.join(e,".git"),oids:i}){const s=new $,a=[];function o(c,h){const u=Buffer.from(c,h);a.push(u),s.update(u)}async function f({stype:c,object:h}){const u=Va[c];let d=h.length,y=d>15?128:0;const b=d&15;d=d>>>4;let _=(y|u|b).toString(16);for(o(_,"hex");y;)y=d>127?128:0,_=y|d&127,o(un(2,_),"hex"),d=d>>>7;o(Buffer.from(await sr(h)))}o("PACK"),o("00000002","hex"),o(un(8,i.length),"hex");for(const c of i){const{type:h,object:u}=await tt({fs:r,cache:t,gitdir:n,oid:c});await f({object:u,stype:h})}const l=s.digest();return a.push(l),a}async function Xa({fs:r,cache:t,gitdir:e,oids:n,write:i}){const s=await mi({fs:r,cache:t,gitdir:e,oids:n}),a=Buffer.from(await He(s)),f=`pack-${a.slice(-20).toString("hex")}.pack`;return i?(await r.write(m.join(e,`objects/pack/${f}`),a),{filename:f}):{filename:f,packfile:new Uint8Array(a)}}async function pi({fs:r,dir:t,gitdir:e=m.join(t,".git"),oids:n,write:i=!1,cache:s={}}){try{return w("fs",r),w("gitdir",e),w("oids",n),await Xa({fs:new z(r),cache:s,gitdir:e,oids:n,write:i})}catch(a){throw a.caller="git.packObjects",a}}async function yi({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:f=m.join(o,".git"),ref:l,url:c,remote:h,remoteRef:u,prune:d=!1,pruneTags:y=!1,fastForward:b=!0,fastForwardOnly:_=!1,corsProxy:k,singleBranch:v,headers:C={},author:F,committer:q,signingKey:N,cache:R={}}){try{w("fs",r),w("gitdir",f);const B=new z(r),D=await At({fs:B,gitdir:f,author:F});if(!D)throw new ut("author");const W=await re({fs:B,gitdir:f,author:D,committer:q});if(!W)throw new ut("committer");return await Ur({fs:B,cache:R,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:s,onAuthFailure:a,dir:o,gitdir:f,ref:l,url:c,remote:h,remoteRef:u,fastForward:b,fastForwardOnly:_,corsProxy:k,singleBranch:v,headers:C,author:D,committer:W,signingKey:N,prune:d,pruneTags:y})}catch(B){throw B.caller="git.pull",B}}async function Ya({fs:r,cache:t,dir:e,gitdir:n=m.join(e,".git"),start:i,finish:s}){const a=await je.read({fs:r,gitdir:n}),o=new Set,f=new Set;for(const h of i)o.add(await S.resolve({fs:r,gitdir:n,ref:h}));for(const h of s)try{const u=await S.resolve({fs:r,gitdir:n,ref:h});f.add(u)}catch{}const l=new Set;async function c(h){l.add(h);const{type:u,object:d}=await tt({fs:r,cache:t,gitdir:n,oid:h});if(u==="tag"){const b=wt.from(d).headers().object;return c(b)}if(u!=="commit")throw new dt(h,u,"commit");if(!a.has(h)){const b=et.from(d).headers().parent;for(h of b)!f.has(h)&&!l.has(h)&&await c(h)}}for(const h of o)await c(h);return l}async function yn({fs:r,cache:t,dir:e,gitdir:n=m.join(e,".git"),oids:i}){const s=new Set;async function a(o){if(s.has(o))return;s.add(o);const{type:f,object:l}=await tt({fs:r,cache:t,gitdir:n,oid:o});if(f==="tag"){const h=wt.from(l).headers().object;await a(h)}else if(f==="commit"){const h=et.from(l).headers().tree;await a(h)}else if(f==="tree"){const c=mt.from(l);for(const h of c)h.type==="blob"&&s.add(h.oid),h.type==="tree"&&await a(h.oid)}}for(const o of i)await a(o);return s}async function Za(r){const t={};let e="";const n=rt.streamReader(r);let i=await n();for(;i!==!0;)i!==null&&(e+=i.toString("utf8")+`
`),i=await n();const s=e.toString("utf8").split(`
`);if(i=s.shift(),!i.startsWith("unpack "))throw new Ft('unpack ok" or "unpack [error message]',i);t.ok=i==="unpack ok",t.ok||(t.error=i.slice(7)),t.refs={};for(const a of s){if(a.trim()==="")continue;const o=a.slice(0,2),f=a.slice(3);let l=f.indexOf(" ");l===-1&&(l=f.length);const c=f.slice(0,l),h=f.slice(l+1);t.refs[c]={ok:o==="ok",error:h}}return t}async function Qa({capabilities:r=[],triplets:t=[]}){const e=[];let n=`\0 ${r.join(" ")}`;for(const i of t)e.push(rt.encode(`${i.oldoid} ${i.oid} ${i.fullRef}${n}
`)),n="";return e.push(rt.flush()),e}async function Ja({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:s,onAuthSuccess:a,onAuthFailure:o,onPrePush:f,gitdir:l,ref:c,remoteRef:h,remote:u,url:d,force:y=!1,delete:b=!1,corsProxy:_,headers:k={}}){const v=c||await Dt({fs:r,gitdir:l});if(typeof v>"u")throw new pt("ref");const C=await it.get({fs:r,gitdir:l});u=u||await C.get(`branch.${v}.pushRemote`)||await C.get("remote.pushDefault")||await C.get(`branch.${v}.remote`)||"origin";const F=d||await C.get(`remote.${u}.pushurl`)||await C.get(`remote.${u}.url`);if(typeof F>"u")throw new pt("remote OR url");const q=h||await C.get(`branch.${v}.merge`);if(typeof F>"u")throw new pt("remoteRef");_===void 0&&(_=await C.get("http.corsProxy"));const N=await S.expand({fs:r,gitdir:l,ref:v}),R=b?"0000000000000000000000000000000000000000":await S.resolve({fs:r,gitdir:l,ref:N}),B=qe.getRemoteHelperFor({url:F}),D=await B.discover({http:e,onAuth:s,onAuthSuccess:a,onAuthFailure:o,corsProxy:_,service:"git-receive-pack",url:F,headers:k,protocolVersion:1}),W=D.auth;let X;if(!q)X=N;else try{X=await S.expandAgainstMap({ref:q,map:D.refs})}catch(nt){if(nt instanceof Q)X=q.startsWith("refs/")?q:`refs/heads/${q}`;else throw nt}const at=D.refs.get(X)||"0000000000000000000000000000000000000000";if(f&&!await f({remote:u,url:F,localRef:{ref:b?"(delete)":N,oid:R},remoteRef:{ref:X,oid:at}}))throw new Kt;const Y=!D.capabilities.has("no-thin");let ot=new Set;if(!b){const nt=[...D.refs.values()];let xt=new Set;if(at!=="0000000000000000000000000000000000000000"){const ht=await mn({fs:r,cache:t,gitdir:l,oids:[R,at]});for(const Re of ht)nt.push(Re);Y&&(xt=await yn({fs:r,cache:t,gitdir:l,oids:ht}))}if(!nt.includes(R)){const ht=await Ya({fs:r,cache:t,gitdir:l,start:[R],finish:nt});ot=await yn({fs:r,cache:t,gitdir:l,oids:ht})}if(Y){try{const ht=await S.resolve({fs:r,gitdir:l,ref:`refs/remotes/${u}/HEAD`,depth:2}),{oid:Re}=await S.resolveAgainstMap({ref:ht.replace(`refs/remotes/${u}/`,""),fullref:ht,map:D.refs}),Lt=[Re];for(const ct of await yn({fs:r,cache:t,gitdir:l,oids:Lt}))xt.add(ct)}catch{}for(const ht of xt)ot.delete(ht)}if(R===at&&(y=!0),!y){if(N.startsWith("refs/tags")&&at!=="0000000000000000000000000000000000000000")throw new Jt("tag-exists");if(R!=="0000000000000000000000000000000000000000"&&at!=="0000000000000000000000000000000000000000"&&!await ti({fs:r,cache:t,gitdir:l,oid:R,ancestor:at,depth:-1}))throw new Jt("not-fast-forward")}}const lt=Er([...D.capabilities],["report-status","side-band-64k",`agent=${Le.agent}`]),zt=await Qa({capabilities:lt,triplets:[{oldoid:at,oid:R,fullRef:X}]}),qt=b?[]:await mi({fs:r,cache:t,gitdir:l,oids:[...ot]}),oe=await B.connect({http:e,onProgress:n,corsProxy:_,service:"git-receive-pack",url:F,auth:W,headers:k,body:[...zt,...qt]}),{packfile:_n,progress:kn}=await Rr.demux(oe.body);if(i){const nt=jr(kn);Ee(nt,async xt=>{await i(xt)})}const _t=await Za(_n);if(oe.headers&&(_t.headers=oe.headers),u&&_t.ok&&_t.refs[X].ok&&!N.startsWith("refs/tags")){const nt=`refs/remotes/${u}/${X.replace("refs/heads","")}`;b?await S.deleteRef({fs:r,gitdir:l,ref:nt}):await S.writeRef({fs:r,gitdir:l,ref:nt,value:R})}if(_t.ok&&Object.values(_t.refs).every(nt=>nt.ok))return _t;{const nt=Object.entries(_t.refs).filter(([xt,ht])=>!ht.ok).map(([xt,ht])=>`
  - ${xt}: ${ht.error}`).join("");throw new me(nt,_t)}}async function gi({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:s,onAuthFailure:a,onPrePush:o,dir:f,gitdir:l=m.join(f,".git"),ref:c,remoteRef:h,remote:u="origin",url:d,force:y=!1,delete:b=!1,corsProxy:_,headers:k={},cache:v={}}){try{return w("fs",r),w("http",t),w("gitdir",l),await Ja({fs:new z(r),cache:v,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:s,onAuthFailure:a,onPrePush:o,gitdir:l,ref:c,remoteRef:h,remote:u,url:d,force:y,delete:b,corsProxy:_,headers:k})}catch(C){throw C.caller="git.push",C}}async function bi({fs:r,cache:t,gitdir:e,oid:n}){const{type:i,object:s}=await tt({fs:r,cache:t,gitdir:e,oid:n});if(i==="tag")return n=wt.from(s).parse().object,bi({fs:r,cache:t,gitdir:e,oid:n});if(i!=="blob")throw new dt(n,i,"blob");return{oid:n,blob:new Uint8Array(s)}}async function _i({fs:r,cache:t,gitdir:e,oid:n,filepath:i=void 0}){return i!==void 0&&(n=await xe({fs:r,cache:t,gitdir:e,oid:n,filepath:i})),await bi({fs:r,cache:t,gitdir:e,oid:n})}async function ki({fs:r,dir:t,gitdir:e=m.join(t,".git"),oid:n,filepath:i,cache:s={}}){try{return w("fs",r),w("gitdir",e),w("oid",n),await _i({fs:new z(r),cache:s,gitdir:e,oid:n,filepath:i})}catch(a){throw a.caller="git.readBlob",a}}async function gn({fs:r,dir:t,gitdir:e=m.join(t,".git"),oid:n,cache:i={}}){try{return w("fs",r),w("gitdir",e),w("oid",n),await ie({fs:new z(r),cache:i,gitdir:e,oid:n})}catch(s){throw s.caller="git.readCommit",s}}async function Ka({fs:r,cache:t,gitdir:e,ref:n="refs/notes/commits",oid:i}){const s=await S.resolve({gitdir:e,fs:r,ref:n}),{blob:a}=await _i({fs:r,cache:t,gitdir:e,oid:s,filepath:i});return a}async function vi({fs:r,dir:t,gitdir:e=m.join(t,".git"),ref:n="refs/notes/commits",oid:i,cache:s={}}){try{return w("fs",r),w("gitdir",e),w("ref",n),w("oid",i),await Ka({fs:new z(r),cache:s,gitdir:e,ref:n,oid:i})}catch(a){throw a.caller="git.readNote",a}}async function Si({fs:r,dir:t,gitdir:e=m.join(t,".git"),oid:n,format:i="parsed",filepath:s=void 0,encoding:a=void 0,cache:o={}}){try{w("fs",r),w("gitdir",e),w("oid",n);const f=new z(r);s!==void 0&&(n=await xe({fs:f,cache:o,gitdir:e,oid:n,filepath:s}));const c=await tt({fs:f,cache:o,gitdir:e,oid:n,format:i==="parsed"?"content":i});if(c.oid=n,i==="parsed")switch(c.format="parsed",c.type){case"commit":c.object=et.from(c.object).parse();break;case"tree":c.object=mt.from(c.object).entries();break;case"blob":a?c.object=c.object.toString(a):(c.object=new Uint8Array(c.object),c.format="content");break;case"tag":c.object=wt.from(c.object).parse();break;default:throw new dt(c.oid,c.type,"blob|commit|tag|tree")}else(c.format==="deflated"||c.format==="wrapped")&&(c.type=c.format);return c}catch(f){throw f.caller="git.readObject",f}}async function to({fs:r,cache:t,gitdir:e,oid:n}){const{type:i,object:s}=await tt({fs:r,cache:t,gitdir:e,oid:n,format:"content"});if(i!=="tag")throw new dt(n,i,"tag");const a=wt.from(s);return{oid:n,tag:a.parse(),payload:a.payload()}}async function xi({fs:r,dir:t,gitdir:e=m.join(t,".git"),oid:n,cache:i={}}){try{return w("fs",r),w("gitdir",e),w("oid",n),await to({fs:new z(r),cache:i,gitdir:e,oid:n})}catch(s){throw s.caller="git.readTag",s}}async function $i({fs:r,dir:t,gitdir:e=m.join(t,".git"),oid:n,filepath:i=void 0,cache:s={}}){try{return w("fs",r),w("gitdir",e),w("oid",n),await se({fs:new z(r),cache:s,gitdir:e,oid:n,filepath:i})}catch(a){throw a.caller="git.readTree",a}}async function Ei({fs:r,dir:t,gitdir:e=m.join(t,".git"),filepath:n,cache:i={}}){try{w("fs",r),w("gitdir",e),w("filepath",n),await st.acquire({fs:new z(r),gitdir:e,cache:i},async function(s){s.delete({filepath:n})})}catch(s){throw s.caller="git.remove",s}}async function eo({fs:r,cache:t,onSign:e,gitdir:n,ref:i="refs/notes/commits",oid:s,author:a,committer:o,signingKey:f}){let l;try{l=await S.resolve({gitdir:n,fs:r,ref:i})}catch(y){if(!(y instanceof Q))throw y}let h=(await se({fs:r,gitdir:n,oid:l||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;h=h.filter(y=>y.path!==s);const u=await $e({fs:r,gitdir:n,tree:h});return await Ue({fs:r,cache:t,onSign:e,gitdir:n,ref:i,tree:u,parent:l&&[l],message:`Note removed by 'isomorphic-git removeNote'
`,author:a,committer:o,signingKey:f})}async function ji({fs:r,onSign:t,dir:e,gitdir:n=m.join(e,".git"),ref:i="refs/notes/commits",oid:s,author:a,committer:o,signingKey:f,cache:l={}}){try{w("fs",r),w("gitdir",n),w("oid",s);const c=new z(r),h=await At({fs:c,gitdir:n,author:a});if(!h)throw new ut("author");const u=await re({fs:c,gitdir:n,author:h,committer:o});if(!u)throw new ut("committer");return await eo({fs:c,cache:l,onSign:t,gitdir:n,ref:i,oid:s,author:h,committer:u,signingKey:f})}catch(c){throw c.caller="git.removeNote",c}}async function no({fs:r,gitdir:t,oldref:e,ref:n,checkout:i=!1}){if(n!==p.clean(n))throw new St(n,p.clean(n));if(e!==p.clean(e))throw new St(e,p.clean(e));const s=`refs/heads/${e}`,a=`refs/heads/${n}`;if(await S.exists({fs:r,gitdir:t,ref:a}))throw new vt("branch",n,!1);const f=await S.resolve({fs:r,gitdir:t,ref:s,depth:1});await S.writeRef({fs:r,gitdir:t,ref:a,value:f}),await S.deleteRef({fs:r,gitdir:t,ref:s});const c=await Dt({fs:r,gitdir:t,fullname:!0})===s;(i||c)&&await S.writeSymbolicRef({fs:r,gitdir:t,ref:"HEAD",value:a})}async function Ri({fs:r,dir:t,gitdir:e=m.join(t,".git"),ref:n,oldref:i,checkout:s=!1}){try{return w("fs",r),w("gitdir",e),w("ref",n),w("oldref",i),await no({fs:new z(r),gitdir:e,ref:n,oldref:i,checkout:s})}catch(a){throw a.caller="git.renameBranch",a}}async function Oi({gitdir:r,type:t,object:e}){return jt(Vt.wrap({type:t,object:e}))}async function Ii({fs:r,dir:t,gitdir:e=m.join(t,".git"),filepath:n,ref:i,cache:s={}}){try{w("fs",r),w("gitdir",e),w("filepath",n);const a=new z(r);let o,f;try{o=await S.resolve({fs:a,gitdir:e,ref:i||"HEAD"})}catch(h){if(i)throw h}if(o)try{o=await xe({fs:a,cache:s,gitdir:e,oid:o,filepath:n})}catch{o=null}let l={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:0,uid:0,gid:0,size:0};const c=t&&await a.read(m.join(t,n));c&&(f=await Oi({gitdir:e,type:"blob",object:c}),o===f&&(l=await a.lstat(m.join(t,n)))),await st.acquire({fs:a,gitdir:e,cache:s},async function(h){h.delete({filepath:n}),o&&h.insert({filepath:n,stats:l,oid:o})})}catch(a){throw a.caller="git.reset",a}}async function Bi({fs:r,dir:t,gitdir:e=m.join(t,".git"),ref:n,depth:i}){try{return w("fs",r),w("gitdir",e),w("ref",n),await S.resolve({fs:new z(r),gitdir:e,ref:n,depth:i})}catch(s){throw s.caller="git.resolveRef",s}}async function Pi({fs:r,dir:t,gitdir:e=m.join(t,".git"),path:n,value:i,append:s=!1}){try{w("fs",r),w("gitdir",e),w("path",n);const a=new z(r),o=await it.get({fs:a,gitdir:e});s?await o.append(n,i):await o.set(n,i),await it.save({fs:a,gitdir:e,config:o})}catch(a){throw a.caller="git.setConfig",a}}async function Ti({fs:r,gitdir:t,commit:e}){const n=et.from(e).toObject();return await yt({fs:r,gitdir:t,type:"commit",object:n,format:"content"})}class Ge{static get timezoneOffsetForRefLogEntry(){const t=new Date().getTimezoneOffset(),e=Math.abs(Math.floor(t/60)),n=Math.abs(t%60).toString().padStart(2,"0");return`${t>0?"-":"+"}${e.toString().padStart(2,"0")}${n}`}static createStashReflogEntry(t,e,n){const i=t.name.replace(/\s/g,""),s="0000000000000000000000000000000000000000",a=Math.floor(Date.now()/1e3),o=Ge.timezoneOffsetForRefLogEntry;return`${s} ${e} ${i} ${t.email} ${a} ${o}	${n}
`}static getStashReflogEntry(t,e=!1){return t.split(`
`).filter(s=>s).reverse().map((s,a)=>e?`stash@{${a}}: ${s.split("	")[1]}`:s)}}const ro={stage:Mt,workdir:ee};let bn;async function ae(r,t){return bn===void 0&&(bn=new I),bn.acquire(r,t)}async function io(r,t,e,n,i=null){const s=m.join(e,n),a=await r.lstat(s);if(!a)throw new Q(s);if(a.isDirectory())throw new M(`${s}: file expected, but found directory`);const o=i?await Wn({fs:r,gitdir:t,oid:i}):void 0;let f=o?i:void 0;return o||await ae({fs:r,gitdir:t,currentFilepath:s},async()=>{const l=a.isSymbolicLink()?await r.readlink(s).then(ar):await r.read(s);if(l===null)throw new Q(s);f=await yt({fs:r,gitdir:t,type:"blob",object:l})}),f}async function so({fs:r,dir:t,gitdir:e,entries:n}){async function i(s){if(s.type==="tree"){if(!s.oid){const a=await Promise.all(s.children.map(i));s.oid=await $e({fs:r,gitdir:e,tree:a}),s.mode=16384}}else s.type==="blob"&&(s.oid=await io(r,e,t,s.path,s.oid),s.mode=33188);return s.path=s.path.split("/").pop(),s}return Promise.all(n.map(i))}async function Ci({fs:r,dir:t,gitdir:e,treePair:n}){const i=n[1]==="stage",s=n.map(d=>typeof d=="string"?ro[d]():d),a=[],c=await Ct({fs:r,cache:{},dir:t,gitdir:e,trees:s,map:async(d,[y,b])=>{if(!(d==="."||await ne.isIgnored({fs:r,dir:t,gitdir:e,filepath:d}))&&b)return(!y||await y.oid()!==await b.oid()&&await b.oid()!==void 0)&&a.push([y,b]),{mode:await b.mode(),path:d,oid:await b.oid(),type:await b.type()}},reduce:async(d,y)=>(y=y.filter(Boolean),d?(d.children=y,d):y.length>0?y:void 0),iterate:async(d,y)=>{const b=[];for(const _ of y){const[k,v]=_;i?v&&(await r.exists(`${t}/${v.toString()}`)?b.push(_):a.push([null,v])):k&&(v?b.push(_):a.push([k,null]))}return b.length?Promise.all(b.map(d)):[]}});if(a.length===0||c.length===0)return null;const u=(await so({fs:r,dir:t,gitdir:e,entries:c})).filter(Boolean).map(d=>({mode:d.mode,path:d.path,oid:d.oid,type:d.type}));return $e({fs:r,gitdir:e,tree:u})}async function ao({fs:r,dir:t,gitdir:e,stashCommit:n,parentCommit:i,wasStaged:s}){const a=[],o=[],f=await Ct({fs:r,cache:{},dir:t,gitdir:e,trees:[bt({ref:i}),bt({ref:n})],map:async(l,[c,h])=>{if(l==="."||await ne.isIgnored({fs:r,dir:t,gitdir:e,filepath:l}))return;const u=h?await h.type():await c.type();if(u!=="tree"&&u!=="blob")return;if(!h&&c){const y=u==="tree"?"rmdir":"rm";return u==="tree"&&a.push(l),u==="blob"&&s&&o.push({filepath:l,oid:await c.oid()}),{method:y,filepath:l}}const d=await h.oid();if(!c||await c.oid()!==d)return u==="tree"?{method:"mkdir",filepath:l}:(s&&o.push({filepath:l,oid:d,stats:await r.lstat(m.join(t,l))}),{method:"write",filepath:l,oid:d})}});await ae({fs:r,gitdir:e,dirRemoved:a,ops:f},async()=>{for(const l of f){const c=m.join(t,l.filepath);switch(l.method){case"rmdir":await r.rmdir(c);break;case"mkdir":await r.mkdir(c);break;case"rm":await r.rm(c);break;case"write":if(!a.some(h=>c.startsWith(h))){const{object:h}=await tt({fs:r,cache:{},gitdir:e,oid:l.oid});await r.exists(c)&&await r.rm(c),await r.write(c,h)}break}}}),await st.acquire({fs:r,gitdir:e,cache:{}},async l=>{o.forEach(({filepath:c,stats:h,oid:u})=>{l.insert({filepath:c,stats:h,oid:u})})})}class Ot{constructor({fs:t,dir:e,gitdir:n=m.join(e,".git")}){Object.assign(this,{fs:t,dir:e,gitdir:n,_author:null})}static get refStash(){return"refs/stash"}static get refLogsStash(){return"logs/refs/stash"}get refStashPath(){return m.join(this.gitdir,Ot.refStash)}get refLogsStashPath(){return m.join(this.gitdir,Ot.refLogsStash)}async getAuthor(){if(!this._author&&(this._author=await At({fs:this.fs,gitdir:this.gitdir,author:{}}),!this._author))throw new ut("author");return this._author}async getStashSHA(t,e){return await this.fs.exists(this.refStashPath)?(e||await this.readStashReflogs({parsed:!1}))[t].split(" ")[1]:null}async writeStashCommit({message:t,tree:e,parent:n}){return Ti({fs:this.fs,gitdir:this.gitdir,commit:{message:t,tree:e,parent:n,author:await this.getAuthor(),committer:await this.getAuthor()}})}async readStashCommit(t){const e=await this.readStashReflogs({parsed:!1});if(t!==0&&(t<0||t>e.length-1))throw new St(`stash@${t}`,"number that is in range of [0, num of stash pushed]");const n=await this.getStashSHA(t,e);return n?ie({fs:this.fs,cache:{},gitdir:this.gitdir,oid:n}):{}}async writeStashRef(t){return S.writeRef({fs:this.fs,gitdir:this.gitdir,ref:Ot.refStash,value:t})}async writeStashReflogEntry({stashCommit:t,message:e}){const n=await this.getAuthor(),i=Ge.createStashReflogEntry(n,t,e),s=this.refLogsStashPath;await ae({filepath:s,entry:i},async()=>{const a=await this.fs.exists(s)?await this.fs.read(s,"utf8"):"";await this.fs.write(s,a+i,"utf8")})}async readStashReflogs({parsed:t=!1}){if(!await this.fs.exists(this.refLogsStashPath))return[];const n=(await this.fs.read(this.refLogsStashPath)).toString();return Ge.getStashReflogEntry(n,t)}}async function oo({fs:r,dir:t,gitdir:e,message:n=""}){const i=new Ot({fs:r,dir:t,gitdir:e});await i.getAuthor();const s=await Dt({fs:r,gitdir:e,fullname:!1}),a=await S.resolve({fs:r,gitdir:e,ref:"HEAD"}),f=(await gn({fs:r,dir:t,gitdir:e,oid:a})).commit.message,l=[a];let c=null,h=bt({ref:"HEAD"});const u=await Ci({fs:r,dir:t,gitdir:e,treePair:[bt({ref:"HEAD"}),"stage"]});if(u){const _=await i.writeStashCommit({message:`stash-Index: WIP on ${s} - ${new Date().toISOString()}`,tree:u,parent:l});l.push(_),c=u,h=Mt()}const d=await Ci({fs:r,dir:t,gitdir:e,treePair:[h,"workdir"]});if(d){const _=await i.writeStashCommit({message:`stash-WorkDir: WIP on ${s} - ${new Date().toISOString()}`,tree:d,parent:[l[l.length-1]]});l.push(_),c=d}if(!c||!u&&!d)throw new Q("changes, nothing to stash");const y=(n.trim()||`WIP on ${s}`)+`: ${a.substring(0,7)} ${f}`,b=await i.writeStashCommit({message:y,tree:c,parent:l});return await i.writeStashRef(b),await i.writeStashReflogEntry({stashCommit:b,message:y}),await fn({fs:r,dir:t,gitdir:e,ref:s,track:!1,force:!0}),b}async function Ai({fs:r,dir:t,gitdir:e,refIdx:n=0}){const s=await new Ot({fs:r,dir:t,gitdir:e}).readStashCommit(n),{parent:a=null}=s.commit?s.commit:{};if(!(!a||!Array.isArray(a)))for(let o=0;o<a.length-1;o++){const l=(await ie({fs:r,cache:{},gitdir:e,oid:a[o+1]})).commit.message.startsWith("stash-Index");await ao({fs:r,dir:t,gitdir:e,stashCommit:a[o+1],parentCommit:a[o],wasStaged:l})}}async function Di({fs:r,dir:t,gitdir:e,refIdx:n=0}){const i=new Ot({fs:r,dir:t,gitdir:e});if(!(await i.readStashCommit(n)).commit)return;const a=i.refStashPath;await ae(a,async()=>{await r.exists(a)&&await r.rm(a)});const o=await i.readStashReflogs({parsed:!1});if(!o.length)return;o.splice(n,1);const f=i.refLogsStashPath;await ae({reflogEntries:o,stashReflogPath:f,stashMgr:i},async()=>{if(o.length){await r.write(f,o.join(`
`),"utf8");const l=o[o.length-1].split(" ")[1];await i.writeStashRef(l)}else await r.rm(f)})}async function co({fs:r,dir:t,gitdir:e}){return new Ot({fs:r,dir:t,gitdir:e}).readStashReflogs({parsed:!0})}async function lo({fs:r,dir:t,gitdir:e}){const n=new Ot({fs:r,dir:t,gitdir:e}),i=[n.refStashPath,n.refLogsStashPath];await ae(i,async()=>{await Promise.all(i.map(async s=>{if(await r.exists(s))return r.rm(s)}))})}async function fo({fs:r,dir:t,gitdir:e,refIdx:n=0}){await Ai({fs:r,dir:t,gitdir:e,refIdx:n}),await Di({fs:r,dir:t,gitdir:e,refIdx:n})}async function Ni({fs:r,dir:t,gitdir:e=m.join(t,".git"),op:n="push",message:i="",refIdx:s=0}){w("fs",r),w("dir",t),w("gitdir",e),w("op",n);const a={push:oo,apply:Ai,drop:Di,list:co,clear:lo,pop:fo},o=["apply","drop","pop"];try{const f=new z(r);["refs","logs","logs/refs"].map(h=>m.join(e,h)).forEach(async h=>{await f.exists(h)||await f.mkdir(h)});const c=a[n];if(c){if(o.includes(n)&&s<0)throw new St(`stash@${s}`,"number that is in range of [0, num of stash pushed]");return await c({fs:f,dir:t,gitdir:e,message:i,refIdx:s})}throw new Error(`To be implemented: ${n}`)}catch(f){throw f.caller="git.stash",f}}async function Mi({fs:r,dir:t,gitdir:e=m.join(t,".git"),filepath:n,cache:i={}}){try{w("fs",r),w("gitdir",e),w("filepath",n);const s=new z(r);if(await ne.isIgnored({fs:s,gitdir:e,dir:t,filepath:n}))return"ignored";const o=await uo({fs:s,cache:i,gitdir:e}),f=await Fi({fs:s,cache:i,gitdir:e,tree:o,path:n}),l=await st.acquire({fs:s,gitdir:e,cache:i},async function(b){for(const _ of b)if(_.path===n)return _;return null}),c=await s.lstat(m.join(t,n)),h=f!==null,u=l!==null,d=c!==null,y=async()=>{if(u&&!Be(l,c))return l.oid;{const b=await s.read(m.join(t,n)),_=await Oi({gitdir:e,type:"blob",object:b});return u&&l.oid===_&&c.size!==-1&&st.acquire({fs:s,gitdir:e,cache:i},async function(k){k.insert({filepath:n,stats:c,oid:_})}),_}};if(!h&&!d&&!u)return"absent";if(!h&&!d&&u)return"*absent";if(!h&&d&&!u)return"*added";if(!h&&d&&u)return await y()===l.oid?"added":"*added";if(h&&!d&&!u)return"deleted";if(h&&!d&&u)return f===l.oid,"*deleted";if(h&&d&&!u)return await y()===f?"*undeleted":"*undeletemodified";if(h&&d&&u){const b=await y();return b===f?b===l.oid?"unmodified":"*unmodified":b===l.oid?"modified":"*modified"}}catch(s){throw s.caller="git.status",s}}async function Fi({fs:r,cache:t,gitdir:e,tree:n,path:i}){typeof i=="string"&&(i=i.split("/"));const s=i.shift();for(const a of n)if(a.path===s){if(i.length===0)return a.oid;const{type:o,object:f}=await tt({fs:r,cache:t,gitdir:e,oid:a.oid});if(o==="tree"){const l=mt.from(f);return Fi({fs:r,cache:t,gitdir:e,tree:l,path:i})}if(o==="blob")throw new dt(a.oid,o,"blob",i.join("/"))}return null}async function uo({fs:r,cache:t,gitdir:e}){let n;try{n=await S.resolve({fs:r,gitdir:e,ref:"HEAD"})}catch(s){if(s instanceof Q)return[]}const{tree:i}=await se({fs:r,cache:t,gitdir:e,oid:n});return i}async function Ui({fs:r,dir:t,gitdir:e=m.join(t,".git"),ref:n="HEAD",filepaths:i=["."],filter:s,cache:a={},ignored:o=!1}){try{w("fs",r),w("gitdir",e),w("ref",n);const f=new z(r);return await Ct({fs:f,cache:a,dir:t,gitdir:e,trees:[bt({ref:n}),ee(),Mt()],map:async function(l,[c,h,u]){if(!c&&!u&&h&&!o&&await ne.isIgnored({fs:f,dir:t,filepath:l})||!i.some(N=>yr(l,N)))return null;if(s&&!s(l))return;const[d,y,b]=await Promise.all([c&&c.type(),h&&h.type(),u&&u.type()]),_=[d,y,b].includes("blob");if((d==="tree"||d==="special")&&!_)return;if(d==="commit")return null;if((y==="tree"||y==="special")&&!_)return;if(b==="commit")return null;if((b==="tree"||b==="special")&&!_)return;const k=d==="blob"?await c.oid():void 0,v=b==="blob"?await u.oid():void 0;let C;d!=="blob"&&y==="blob"&&b!=="blob"?C="42":y==="blob"&&(C=await h.oid());const F=[void 0,k,C,v],q=F.map(N=>F.indexOf(N));return q.shift(),[l,...q]}})}catch(f){throw f.caller="git.statusMatrix",f}}async function Hi({fs:r,dir:t,gitdir:e=m.join(t,".git"),ref:n,object:i,force:s=!1}){try{w("fs",r),w("gitdir",e),w("ref",n);const a=new z(r);if(n===void 0)throw new pt("ref");n=n.startsWith("refs/tags/")?n:`refs/tags/${n}`;const o=await S.resolve({fs:a,gitdir:e,ref:i||"HEAD"});if(!s&&await S.exists({fs:a,gitdir:e,ref:n}))throw new vt("tag",n);await S.writeRef({fs:a,gitdir:e,ref:n,value:o})}catch(a){throw a.caller="git.tag",a}}async function zi({fs:r,dir:t,gitdir:e=m.join(t,".git"),cache:n={},filepath:i,oid:s,mode:a,add:o,remove:f,force:l}){try{w("fs",r),w("gitdir",e),w("filepath",i);const c=new z(r);if(f)return await st.acquire({fs:c,gitdir:e,cache:n},async function(u){if(!l){const d=await c.lstat(m.join(t,i));if(d){if(d.isDirectory())throw new Pt("directory");return}}u.has({filepath:i})&&u.delete({filepath:i})});let h;if(!s){if(h=await c.lstat(m.join(t,i)),!h)throw new Q(`file at "${i}" on disk and "remove" not set`);if(h.isDirectory())throw new Pt("directory")}return await st.acquire({fs:c,gitdir:e,cache:n},async function(u){if(!o&&!u.has({filepath:i}))throw new Q(`file at "${i}" in index and "add" not set`);let d;if(s)d={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:a,uid:0,gid:0,size:0};else{d=h;const y=d.isSymbolicLink()?await c.readlink(m.join(t,i)):await c.read(m.join(t,i));s=await yt({fs:c,gitdir:e,type:"blob",format:"content",object:y})}return u.insert({filepath:i,oid:s,stats:d}),s})}catch(c){throw c.caller="git.updateIndex",c}}function qi(){try{return Le.version}catch(r){throw r.caller="git.version",r}}async function Li({fs:r,dir:t,gitdir:e=m.join(t,".git"),trees:n,map:i,reduce:s,iterate:a,cache:o={}}){try{return w("fs",r),w("gitdir",e),w("trees",n),await Ct({fs:new z(r),cache:o,dir:t,gitdir:e,trees:n,map:i,reduce:s,iterate:a})}catch(f){throw f.caller="git.walk",f}}async function Wi({fs:r,dir:t,gitdir:e=m.join(t,".git"),blob:n}){try{return w("fs",r),w("gitdir",e),w("blob",n),await yt({fs:new z(r),gitdir:e,type:"blob",object:n,format:"content"})}catch(i){throw i.caller="git.writeBlob",i}}async function Gi({fs:r,dir:t,gitdir:e=m.join(t,".git"),commit:n}){try{return w("fs",r),w("gitdir",e),w("commit",n),await Ti({fs:new z(r),gitdir:e,commit:n})}catch(i){throw i.caller="git.writeCommit",i}}async function Vi({fs:r,dir:t,gitdir:e=m.join(t,".git"),type:n,object:i,format:s="parsed",oid:a,encoding:o=void 0}){try{const f=new z(r);if(s==="parsed"){switch(n){case"commit":i=et.from(i).toObject();break;case"tree":i=mt.from(i).toObject();break;case"blob":i=Buffer.from(i,o);break;case"tag":i=wt.from(i).toObject();break;default:throw new dt(a||"",n,"blob|commit|tag|tree")}s="content"}return a=await yt({fs:f,gitdir:e,type:n,object:i,oid:a,format:s}),a}catch(f){throw f.caller="git.writeObject",f}}async function Xi({fs:r,dir:t,gitdir:e=m.join(t,".git"),ref:n,value:i,force:s=!1,symbolic:a=!1}){try{w("fs",r),w("gitdir",e),w("ref",n),w("value",i);const o=new z(r);if(n!==p.clean(n))throw new St(n,p.clean(n));if(!s&&await S.exists({fs:o,gitdir:e,ref:n}))throw new vt("ref",n);a?await S.writeSymbolicRef({fs:o,gitdir:e,ref:n,value:i}):(i=await S.resolve({fs:o,gitdir:e,ref:i}),await S.writeRef({fs:o,gitdir:e,ref:n,value:i}))}catch(o){throw o.caller="git.writeRef",o}}async function ho({fs:r,gitdir:t,tag:e}){const n=wt.from(e).toObject();return await yt({fs:r,gitdir:t,type:"tag",object:n,format:"content"})}async function Yi({fs:r,dir:t,gitdir:e=m.join(t,".git"),tag:n}){try{return w("fs",r),w("gitdir",e),w("tag",n),await ho({fs:new z(r),gitdir:e,tag:n})}catch(i){throw i.caller="git.writeTag",i}}async function Zi({fs:r,dir:t,gitdir:e=m.join(t,".git"),tree:n}){try{return w("fs",r),w("gitdir",e),w("tree",n),await $e({fs:new z(r),gitdir:e,tree:n})}catch(i){throw i.caller="git.writeTree",i}}var wo={Errors:Jn,STAGE:Mt,TREE:bt,WORKDIR:ee,add:or,abortMerge:ir,addNote:hr,addRemote:wr,annotatedTag:mr,branch:pr,checkout:fn,clone:Ir,commit:Br,getConfig:Gr,getConfigAll:Vr,setConfig:Pi,currentBranch:Pr,deleteBranch:Tr,deleteRef:Cr,deleteRemote:Ar,deleteTag:Dr,expandOid:Nr,expandRef:Mr,fastForward:Hr,fetch:zr,findMergeBase:qr,findRoot:Wr,getRemoteInfo:Xr,getRemoteInfo2:Zr,hashBlob:Qr,indexPack:Jr,init:Kr,isDescendent:ei,isIgnored:ni,listBranches:ri,listFiles:si,listNotes:ai,listRefs:oi,listRemotes:ci,listServerRefs:li,listTags:fi,log:di,merge:wi,packObjects:pi,pull:yi,push:gi,readBlob:ki,readCommit:gn,readNote:vi,readObject:Si,readTag:xi,readTree:$i,remove:Ei,removeNote:ji,renameBranch:Ri,resetIndex:Ii,updateIndex:zi,resolveRef:Bi,status:Mi,statusMatrix:Ui,tag:Hi,version:qi,walk:Li,writeBlob:Wi,writeCommit:Gi,writeObject:Vi,writeRef:Xi,writeTag:Yi,writeTree:Zi,stash:Ni};return A.Errors=Jn,A.STAGE=Mt,A.TREE=bt,A.WORKDIR=ee,A.abortMerge=ir,A.add=or,A.addNote=hr,A.addRemote=wr,A.annotatedTag=mr,A.branch=pr,A.checkout=fn,A.clone=Ir,A.commit=Br,A.currentBranch=Pr,A.default=wo,A.deleteBranch=Tr,A.deleteRef=Cr,A.deleteRemote=Ar,A.deleteTag=Dr,A.expandOid=Nr,A.expandRef=Mr,A.fastForward=Hr,A.fetch=zr,A.findMergeBase=qr,A.findRoot=Wr,A.getConfig=Gr,A.getConfigAll=Vr,A.getRemoteInfo=Xr,A.getRemoteInfo2=Zr,A.hashBlob=Qr,A.indexPack=Jr,A.init=Kr,A.isDescendent=ei,A.isIgnored=ni,A.listBranches=ri,A.listFiles=si,A.listNotes=ai,A.listRefs=oi,A.listRemotes=ci,A.listServerRefs=li,A.listTags=fi,A.log=di,A.merge=wi,A.packObjects=pi,A.pull=yi,A.push=gi,A.readBlob=ki,A.readCommit=gn,A.readNote=vi,A.readObject=Si,A.readTag=xi,A.readTree=$i,A.remove=Ei,A.removeNote=ji,A.renameBranch=Ri,A.resetIndex=Ii,A.resolveRef=Bi,A.setConfig=Pi,A.stash=Ni,A.status=Mi,A.statusMatrix=Ui,A.tag=Hi,A.updateIndex=zi,A.version=qi,A.walk=Li,A.writeBlob=Wi,A.writeCommit=Gi,A.writeObject=Vi,A.writeRef=Xi,A.writeTag=Yi,A.writeTree=Zi,A}var Xo=Vo();const pc=fs(Xo);function Yo(x){let I=[x];return{next(){return Promise.resolve({done:I.length===0,value:I.pop()})},return(){return I=[],{}},[Symbol.asyncIterator](){return this}}}function Zo(x){return x[Symbol.asyncIterator]?x[Symbol.asyncIterator]():x[Symbol.iterator]?x[Symbol.iterator]():x.next?x:Yo(x)}async function Qo(x,I){const $=Zo(x);for(;;){const{value:m,done:E}=await $.next();if(m&&await I(m),E)break}$.return&&$.return()}async function Jo(x){let I=0;const $=[];await Qo(x,O=>{$.push(O),I+=O.byteLength});const m=new Uint8Array(I);let E=0;for(const O of $)m.set(O,E),E+=O.byteLength;return m}function Ko(x){if(x[Symbol.asyncIterator])return x;const I=x.getReader();return{next(){return I.read()},return(){return I.releaseLock(),{}},[Symbol.asyncIterator](){return this}}}async function tc({onProgress:x,url:I,method:$="GET",headers:m={},body:E}){E&&(E=await Jo(E));const O=await fetch(I,{method:$,headers:m,body:E}),j=O.body&&O.body.getReader?Ko(O.body):[new Uint8Array(await O.arrayBuffer())];m={};for(const[g,p]of O.headers.entries())m[g]=p;return{url:O.url,method:O.method,statusCode:O.status,statusMessage:O.statusText,body:j,headers:m}}var yc={request:tc};export{hc as F,pc as g,yc as i};
