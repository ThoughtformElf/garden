// src/sidebar/files.js
import { Modal } from '../util/modal.js';

/**
 * Helper to build a hierarchical tree from a flat list of file paths.
 * @param {string[]} files - A flat array of file paths (e.g., ['/ideas/project-a', '/notes/meeting.md']).
 * @returns {object} A nested object representing the folder structure.
 */
function buildTree(files) {
    const tree = {};
    files.forEach(file => {
        // Remove leading slash for splitting, e.g., '/foo/bar' -> ['foo', 'bar']
        const parts = file.substring(1).split('/');
        let currentNode = tree;
        parts.forEach((part, index) => {
            if (index === parts.length - 1) { // This is the file part of the path
                currentNode[part] = { type: 'file', path: file };
            } else { // This is a folder part of the path
                if (!currentNode[part]) {
                    currentNode[part] = {
                        type: 'folder',
                        path: '/' + parts.slice(0, index + 1).join('/'),
                        children: {}
                    };
                }
                currentNode = currentNode[part].children;
            }
        });
    });
    return tree;
}

/**
 * Helper to recursively render the HTML for the file tree.
 * @param {object} nodes - A node from the file tree generated by buildTree.
 * @param {Map} statuses - A map of file statuses.
 * @param {string} currentFile - The path of the currently active file in the editor.
 * @param {Set} expandedFolders - A set of paths for folders that should be rendered as expanded.
 * @param {number} depth - The current recursion depth, used for indentation.
 * @returns {string} The generated HTML string.
 */
function renderTreeNodes(nodes, statuses, currentFile, expandedFolders, depth) {
    // Sort so folders appear before files, then alphabetically
    const sortedKeys = Object.keys(nodes).sort((a, b) => {
        const nodeA = nodes[a];
        const nodeB = nodes[b];
        if (nodeA.type === 'folder' && nodeB.type !== 'folder') return -1;
        if (nodeA.type !== 'folder' && nodeB.type === 'folder') return 1;
        return a.localeCompare(b, undefined, { numeric: true });
    });

    let html = '';
    for (const key of sortedKeys) {
        const node = nodes[key];
        const indentStyle = `padding-left: ${depth * 20}px;`;

        if (node.type === 'folder') {
            const isExpanded = expandedFolders.has(node.path);
            html += `
                <li class="file-tree-item is-folder ${isExpanded ? 'expanded' : ''}" data-path="${node.path}" style="${indentStyle}" draggable="true">
                    <span class="folder-name">${key}</span>
                </li>
                <ul class="nested-list ${isExpanded ? 'active' : ''}">
                    ${renderTreeNodes(node.children, statuses, currentFile, expandedFolders, depth + 1)}
                </ul>
            `;
        } else { // type is 'file'
            const status = statuses.get(node.path) || 'unmodified';
            const classes = [];
            if (node.path === currentFile) {
                classes.push('active');
            }
            html += `
                <li class="file-tree-item is-file ${classes.join(' ')}" data-path="${node.path}" style="${indentStyle}" draggable="true">
                    <a href="#${node.path}" class="status-${status}" data-filepath="${node.path}">${key}</a>
                </li>
            `;
        }
    }
    return html;
}


export const fileActions = {
  async renderFiles(statusMatrix) {
    try {
      const files = await this.listFiles(this.gitClient, '/');
      const statuses = new Map();
      for (const [filepath, head, workdir] of statusMatrix) {
          if (head !== workdir) {
              statuses.set(`/${filepath}`, 'modified');
          }
      }

      const currentFile = decodeURIComponent(window.location.hash.substring(1));
      const fileTree = buildTree(files);

      const expandedFoldersRaw = sessionStorage.getItem(`expanded_folders_${this.gitClient.gardenName}`);
      const expandedFolders = new Set(expandedFoldersRaw ? JSON.parse(expandedFoldersRaw) : []);
      
      if (currentFile) {
        const parts = currentFile.split('/').filter(p => p);
        let currentPath = '';
        for (let i = 0; i < parts.length - 1; i++) {
          currentPath += `/${parts[i]}`;
          expandedFolders.add(currentPath);
        }
      }

      const treeHTML = renderTreeNodes(fileTree, statuses, currentFile, expandedFolders, 0);

      this.contentContainer.innerHTML = `<ul class="file-tree-root">${treeHTML}</ul>`;
      
      this.contentContainer.querySelectorAll('.is-folder').forEach(folderEl => {
        folderEl.addEventListener('click', (e) => {
            if (e.target.closest('a')) return; // Ignore clicks on links inside
            const path = folderEl.dataset.path;
            const nestedList = folderEl.nextElementSibling;
            
            const currentExpandedRaw = sessionStorage.getItem(`expanded_folders_${this.gitClient.gardenName}`);
            const currentExpanded = new Set(currentExpandedRaw ? JSON.parse(currentExpandedRaw) : []);

            folderEl.classList.toggle('expanded');
            nestedList.classList.toggle('active');
            
            if (folderEl.classList.contains('expanded')) {
                currentExpanded.add(path);
            } else {
                currentExpanded.delete(path);
            }
            sessionStorage.setItem(`expanded_folders_${this.gitClient.gardenName}`, JSON.stringify(Array.from(currentExpanded)));
        });
      });

      // --- DRAG AND DROP EVENT LISTENERS ---
      let draggedElement = null;
      const self = this; // Capture 'this' context for event handlers

      this.contentContainer.addEventListener('dragstart', (e) => {
          const target = e.target.closest('.file-tree-item');
          if (target) {
              draggedElement = target;
              e.dataTransfer.setData('text/plain', target.dataset.path);
              e.dataTransfer.effectAllowed = 'move';
              setTimeout(() => target.classList.add('is-dragging'), 0);
          }
      });

      this.contentContainer.addEventListener('dragend', (e) => {
          if (draggedElement) {
              draggedElement.classList.remove('is-dragging');
              draggedElement = null;
          }
      });

      this.contentContainer.addEventListener('dragover', (e) => {
          e.preventDefault();
          const target = e.target.closest('.file-tree-item.is-folder');
          if (target && target !== draggedElement && !target.dataset.path.startsWith(draggedElement.dataset.path + '/')) {
              this.contentContainer.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
              target.classList.add('drop-target');
          }
      });

      this.contentContainer.addEventListener('dragleave', (e) => {
          const target = e.target.closest('.drop-target');
          if (target) {
              target.classList.remove('drop-target');
          }
      });

      this.contentContainer.addEventListener('drop', async (e) => {
          e.preventDefault();
          const dropTarget = e.target.closest('.drop-target');
          this.contentContainer.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));

          if (dropTarget && draggedElement) {
              const sourcePath = e.dataTransfer.getData('text/plain');
              const destFolderPath = dropTarget.dataset.path;
              await self.handleFileMove(sourcePath, destFolderPath);
          }
      });

    } catch (e) {
      console.error('Error rendering file list:', e);
      this.contentContainer.innerHTML = `<p class="sidebar-error">Could not load files.</p>`;
    }
  },

  async handleFileMove(sourcePath, destFolderPath) {
    const sourceFilename = sourcePath.split('/').pop();
    const newPath = `${destFolderPath}/${sourceFilename}`;

    // Safety check: prevent moving a parent into its own child
    if (destFolderPath.startsWith(sourcePath + '/')) {
      await this.showAlert({ title: 'Invalid Move', message: 'Cannot move a folder into one of its own sub-folders.' });
      return;
    }

    // Safety check: check for name collisions
    try {
      await this.gitClient.pfs.stat(newPath);
      await this.showAlert({ title: 'Move Failed', message: `An item named "${sourceFilename}" already exists in the destination folder.` });
      return;
    } catch (e) {
      // ENOENT is expected, means no collision
      if (e.code !== 'ENOENT') throw e;
    }

    const confirmed = await this.showConfirm({
        title: 'Move Item?',
        message: `This will move the item to the new location. <br><br><strong>Warning:</strong> This will NOT automatically update wikilinks, which may cause them to break.`,
        okText: 'Move Item',
    });

    if (confirmed) {
        try {
            await this.gitClient.pfs.rename(sourcePath, newPath);
            
            // If we moved the currently active file, update the URL
            if (decodeURIComponent(window.location.hash) === `#${sourcePath}`) {
                window.location.hash = `#${newPath}`;
            }

            await this.refresh();
        } catch(e) {
            console.error('Error moving file:', e);
            await this.showAlert({ title: 'Error', message: 'Failed to move the item. Check the console for details.' });
        }
    }
  },

  async handleNewFile() {
    const newName = await Modal.prompt({
      title: 'New File',
      label: 'Enter new file name (including folders, e.g., "projects/new-idea"):',
    });
    if (!newName) return;
    const newPath = `/${newName}`;
    try {
      await this.gitClient.pfs.stat(newPath);
      await this.showAlert({ title: 'File Exists', message: `File "${newName}" already exists.` });
    } catch (e) {
      if (e.code === 'ENOENT') {
        await this.gitClient.writeFile(newPath, '');
        window.location.hash = `#${newPath}`;
      } else {
        console.error('Error checking for file:', e);
        await this.showAlert({ title: 'Error', message: 'An error occurred while creating the file.' });
      }
    }
  },

  async handleRename(oldPath) {
    const newName = await Modal.prompt({
        title: 'Rename File',
        label: `Enter new name for ${oldPath.substring(1)}:`,
        defaultValue: oldPath.substring(1)
    });
    if (!newName || newName === oldPath.substring(1)) return;
    const newPath = `/${newName}`;
    
    try {
      const dirname = newPath.substring(0, newPath.lastIndexOf('/'));
      if (dirname) {
        await this.ensureDir(dirname);
      }
      await this.gitClient.pfs.rename(oldPath, newPath);
      
      if (decodeURIComponent(window.location.hash) === `#${oldPath}`) {
        window.location.hash = `#${newPath}`;
      } else {
        await this.refresh();
      }
    } catch (e) {
      console.error(`Error renaming file:`, e);
      await this.showAlert({ title: 'Error', message: 'Failed to rename file. Check console for details.' });
    }
  },
  
  async handleDuplicate(filepath) {
    const directory = filepath.substring(0, filepath.lastIndexOf('/'));
    const originalFilename = filepath.substring(filepath.lastIndexOf('/') + 1);
    const lastDotIndex = originalFilename.lastIndexOf('.');
    const hasExtension = lastDotIndex > 0;
    let defaultName;
    if (hasExtension) {
        const base = originalFilename.substring(0, lastDotIndex);
        const ext = originalFilename.substring(lastDotIndex);
        defaultName = `${base} (copy)${ext}`;
    } else {
        defaultName = `${originalFilename} (copy)`;
    }
    
    const newFilename = await Modal.prompt({
        title: 'Duplicate File',
        label: 'Enter name for duplicated file:',
        defaultValue: defaultName
    });
    if (!newFilename) return;
    const newPath = `${directory}/${newFilename}`;
    try {
      const rawContent = await this.gitClient.readFile(filepath);
      await this.gitClient.writeFile(newPath, rawContent);
      await this.refresh();
    } catch (e) {
      console.error('Error duplicating file:', e);
      await this.showAlert({ title: 'Error', message: 'Failed to duplicate file.' });
    }
  },

  async handleDelete(filepath) {
    const confirmed = await this.showConfirm({
      title: 'Delete File',
      message: `Are you sure you want to permanently delete "${filepath}"? This cannot be undone.`,
      okText: 'Delete',
      destructive: true
    });
    if (confirmed) {
      try {
        const wasViewingDeletedFile = decodeURIComponent(window.location.hash) === `#${filepath}`;
        await this.gitClient.pfs.unlink(filepath);
        if (wasViewingDeletedFile) {
          window.location.hash = '#/home';
        } else {
          await this.refresh();
        }
      } catch (e) {
        console.error(`Error deleting file:`, e);
        await this.showAlert({ title: 'Error', message: 'Failed to delete file.' });
      }
    }
  }
};