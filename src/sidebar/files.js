// src/sidebar/files.js
import { Modal } from '../util/modal.js';

/**
 * Helper to build a hierarchical tree from a flat list of file paths.
 * @param {string[]} files - A flat array of file paths (e.g., ['/ideas/project-a', '/notes/meeting.md']).
 * @returns {object} A nested object representing the folder structure.
 */
function buildTree(files) {
    const tree = {};
    files.forEach(file => {
        // Remove leading slash for splitting, e.g., '/foo/bar' -> ['foo', 'bar']
        const parts = file.substring(1).split('/');
        let currentNode = tree;
        parts.forEach((part, index) => {
            if (index === parts.length - 1) { // This is the file part of the path
                currentNode[part] = { type: 'file', path: file };
            } else { // This is a folder part of the path
                if (!currentNode[part]) {
                    currentNode[part] = {
                        type: 'folder',
                        path: '/' + parts.slice(0, index + 1).join('/'),
                        children: {}
                    };
                }
                currentNode = currentNode[part].children;
            }
        });
    });
    return tree;
}

/**
 * Helper to recursively render the HTML for the file tree.
 * @param {object} nodes - A node from the file tree generated by buildTree.
 * @param {Map} statuses - A map of file statuses.
 * @param {string} currentFile - The path of the currently active file in the editor.
 * @param {Set} expandedFolders - A set of paths for folders that should be rendered as expanded.
 * @param {number} depth - The current recursion depth, used for indentation.
 * @returns {string} The generated HTML string.
 */
function renderTreeNodes(nodes, statuses, currentFile, expandedFolders, depth) {
    // Sort so folders appear before files, then alphabetically
    const sortedKeys = Object.keys(nodes).sort((a, b) => {
        const nodeA = nodes[a];
        const nodeB = nodes[b];
        if (nodeA.type === 'folder' && nodeB.type !== 'folder') return -1;
        if (nodeA.type !== 'folder' && nodeB.type === 'folder') return 1;
        return a.localeCompare(b, undefined, { numeric: true });
    });

    let html = '';
    for (const key of sortedKeys) {
        const node = nodes[key];
        const indentStyle = `padding-left: ${depth * 20}px;`;

        if (node.type === 'folder') {
            const isExpanded = expandedFolders.has(node.path);
            html += `
                <li class="file-tree-item is-folder ${isExpanded ? 'expanded' : ''}" data-path="${node.path}" style="${indentStyle}">
                    <span class="folder-name">${key}</span>
                </li>
                <ul class="nested-list ${isExpanded ? 'active' : ''}">
                    ${renderTreeNodes(node.children, statuses, currentFile, expandedFolders, depth + 1)}
                </ul>
            `;
        } else { // type is 'file'
            const status = statuses.get(node.path) || 'unmodified';
            const classes = [];
            // Note: The active class is now applied to the parent <li> for easier styling
            if (node.path === currentFile) {
                classes.push('active');
            }
            html += `
                <li class="file-tree-item is-file ${classes.join(' ')}" style="${indentStyle}">
                    <a href="#${node.path}" class="status-${status}" data-filepath="${node.path}">${key}</a>
                </li>
            `;
        }
    }
    return html;
}


export const fileActions = {
  async renderFiles(statusMatrix) {
    try {
      const files = await this.listFiles(this.gitClient, '/');
      const statuses = new Map();
      for (const [filepath, head, workdir] of statusMatrix) {
          if (head !== workdir) {
              statuses.set(`/${filepath}`, 'modified');
          }
      }

      const currentFile = decodeURIComponent(window.location.hash.substring(1));
      const fileTree = buildTree(files);

      const expandedFoldersRaw = sessionStorage.getItem(`expanded_folders_${this.gitClient.gardenName}`);
      const expandedFolders = new Set(expandedFoldersRaw ? JSON.parse(expandedFoldersRaw) : []);
      
      // --- NEW LOGIC STARTS HERE ---
      // If there's an active file, ensure all its parent folders are expanded.
      if (currentFile) {
        const parts = currentFile.split('/').filter(p => p); // e.g., ['/projects', 'idea', 'file'] -> ['projects', 'idea', 'file']
        let currentPath = '';
        // Iterate through the parts to build parent folder paths, excluding the filename itself.
        for (let i = 0; i < parts.length - 1; i++) {
          currentPath += `/${parts[i]}`; // builds up to '/projects' then '/projects/idea'
          expandedFolders.add(currentPath);
        }
      }
      // --- NEW LOGIC ENDS HERE ---

      const treeHTML = renderTreeNodes(fileTree, statuses, currentFile, expandedFolders, 0);

      this.contentContainer.innerHTML = `<ul class="file-tree-root">${treeHTML}</ul>`;
      
      // Add event listeners to toggle folders on click
      this.contentContainer.querySelectorAll('.is-folder').forEach(folderEl => {
        folderEl.addEventListener('click', () => {
            const path = folderEl.dataset.path;
            const nestedList = folderEl.nextElementSibling;
            
            const currentExpandedRaw = sessionStorage.getItem(`expanded_folders_${this.gitClient.gardenName}`);
            const currentExpanded = new Set(currentExpandedRaw ? JSON.parse(currentExpandedRaw) : []);

            folderEl.classList.toggle('expanded');
            nestedList.classList.toggle('active');
            
            if (folderEl.classList.contains('expanded')) {
                currentExpanded.add(path);
            } else {
                currentExpanded.delete(path);
            }
            sessionStorage.setItem(`expanded_folders_${this.gitClient.gardenName}`, JSON.stringify(Array.from(currentExpanded)));
        });
      });

    } catch (e) {
      console.error('Error rendering file list:', e);
      this.contentContainer.innerHTML = `<p class="sidebar-error">Could not load files.</p>`;
    }
  },

  async handleNewFile() {
    const newName = await Modal.prompt({
      title: 'New File',
      label: 'Enter new file name (including folders, e.g., "projects/new-idea"):',
    });
    if (!newName) return;
    const newPath = `/${newName}`;
    try {
      await this.gitClient.pfs.stat(newPath);
      await this.showAlert({ title: 'File Exists', message: `File "${newName}" already exists.` });
    } catch (e) {
      if (e.code === 'ENOENT') {
        // Create an empty file, writeFile will handle creating parent directories
        await this.gitClient.writeFile(newPath, '');
        window.location.hash = `#${newPath}`;
      } else {
        console.error('Error checking for file:', e);
        await this.showAlert({ title: 'Error', message: 'An error occurred while creating the file.' });
      }
    }
  },

  async handleRename(oldPath) {
    const newName = await Modal.prompt({
        title: 'Rename File',
        label: `Enter new name for ${oldPath.substring(1)}:`,
        defaultValue: oldPath.substring(1)
    });
    if (!newName || newName === oldPath.substring(1)) return;

    const newPath = `/${newName}`;
    
    try {
      const dirname = newPath.substring(0, newPath.lastIndexOf('/'));
      if (dirname) {
        await this.ensureDir(dirname);
      }
      await this.gitClient.pfs.rename(oldPath, newPath);
      
      if (decodeURIComponent(window.location.hash) === `#${oldPath}`) {
        window.location.hash = `#${newPath}`;
      } else {
        await this.refresh();
      }
    } catch (e) {
      console.error(`Error renaming file:`, e);
      await this.showAlert({ title: 'Error', message: 'Failed to rename file. Check console for details.' });
    }
  },
  
  async handleDuplicate(filepath) {
    const directory = filepath.substring(0, filepath.lastIndexOf('/'));
    const originalFilename = filepath.substring(filepath.lastIndexOf('/') + 1);
    const lastDotIndex = originalFilename.lastIndexOf('.');
    const hasExtension = lastDotIndex > 0;
    let defaultName;
    if (hasExtension) {
        const base = originalFilename.substring(0, lastDotIndex);
        const ext = originalFilename.substring(lastDotIndex);
        defaultName = `${base} (copy)${ext}`;
    } else {
        defaultName = `${originalFilename} (copy)`;
    }
    
    const newFilename = await Modal.prompt({
        title: 'Duplicate File',
        label: 'Enter name for duplicated file:',
        defaultValue: defaultName
    });
    if (!newFilename) return;
    const newPath = `${directory}/${newFilename}`;
    try {
      const rawContent = await this.gitClient.readFile(filepath);
      await this.gitClient.writeFile(newPath, rawContent);
      await this.refresh();
    } catch (e) {
      console.error('Error duplicating file:', e);
      await this.showAlert({ title: 'Error', message: 'Failed to duplicate file.' });
    }
  },

  async handleDelete(filepath) {
    const confirmed = await this.showConfirm({
      title: 'Delete File',
      message: `Are you sure you want to permanently delete "${filepath}"? This cannot be undone.`,
      okText: 'Delete',
      destructive: true
    });
    if (confirmed) {
      try {
        const wasViewingDeletedFile = decodeURIComponent(window.location.hash) === `#${filepath}`;
        await this.gitClient.pfs.unlink(filepath);
        if (wasViewingDeletedFile) {
          window.location.hash = '#/home';
        } else {
          await this.refresh();
        }
      } catch (e) {
        console.error(`Error deleting file:`, e);
        await this.showAlert({ title: 'Error', message: 'Failed to delete file.' });
      }
    }
  }
};